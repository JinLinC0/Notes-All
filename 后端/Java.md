# `Java`

## 基本概念

`Java` 是一种广泛使用的高级编程语言，由 `Sun Microsystems`公司（现为` Oracle `甲骨文公司所有）于 1995 年正式发布（第一个版本）由`James Gosling`编写。它以跨平台性、面向对象和健壮性著称，是当今企业级应用、移动开发和大数据领域的核心技术之一，`Java`使用最多的版本是8和11

***

### `Java`的重要特点

- `Java`语言是面向对象的（`oop`）

- `Java`语言是健壮性的，`Java`的强类型机制、异常处理、垃圾的自动收集等是健壮性的重要保证

- `Java`语言是跨平台性的：编译后的`.class`文件可以在跨平台上进行运行，不需要重新进行编译（由于底层中有`Java`虚拟机机制（`JVM`）的存在）

  ![image-20250311171735772](..\images\image-20250311171735772.png)

- `Java`语言是解释型性的

  解释性语言有：`JavaScript`、`PHP`、`Java`

  编译性语言有：`c`、`c++`

  解释性语言，编译后的代码不能直接被机器执行，需要解释器来执行；编译性语言，编译后的代码可以直接被机器执行（编译后的代码已经是二进制的了）

***

### 环境安装

#### 代码编辑器安装

一开始在学习的时候，推荐使用`Sublime Text`代码编辑器进行敲代码，后续大规模开发的时候，推荐使用`IDEA`代码编辑器进行代码的编写，该编辑器有较好的代码提示，能帮助我们快速的编写代码

##### `Sublime Text`

###### 常见的问题

1. 汉化`Sublime Text`
   - 打开`Sublime Text`代码编辑器
   - 使用快捷键`shift+ctrl+p`
   - 输入`Package Control: Install Package`
   - 在搜索框中输入`Chinese`，选择下拉框中的`ChineseLocalizations`
   - 下载完重新打开编辑器，即可汉化
2. `Sublime`里面找不到`GBK`编码格式 
   - 打开`Sublime Text`代码编辑器
   - 使用快捷键`shift+ctrl+p`
   - 输入`Package Control: Install Package`
   - 在搜索框输入`converToUTF8`，选择并安装
   - 后续在文件->`Set File Encoding to`中就可以选择`gbk`进行编码了

##### `IntelliJ IDEA`

[下载官网](https://www.jetbrains.com/)

- 从官网下载安装包，推荐使用专业版

- 右键，以管理员身份运行

- 指定安装目录，选择64位，其他都不选，点击下一步

- 打开安装好的代码编辑器，新建一个项目，选择一个`Java`项目，默认会加载电脑中安装的`JDK`环境，如果没有加载上，我们手动添加即可，选择到本地安装的`JDK`的顶级安装目录即可

- 创建具体项目的名称，并指定具体目录的位置

- 在项目文件中的`src`文件中创建开发文件：单机`src`文件夹右键-->`new`-->`Java Class`-->输入具体项目的文件名

- 编写好代码后，直接通过代码左边的绿色小箭头，或者右键，选择`run`即可编译运行，在终端得到结果

  在`idea`中，当我们`run`一个文件时，会先编译成`.class`，再运行

  具体的文件结构逻辑：编译运行后，会在项目根目录文件夹中生成`out`文件夹，文件夹下有`production`文件，里面就有编译后的类文件

###### 基本设置

- 设置字体大小：菜单`file`-->`settings`-->`Appearance`-->选中`use custom font`-->设置合适字体大小
- 字符编码设置：菜单`file`-->`settings`-->`Editor`-->`File Encoding`-->在`Global Encoding`设置`UTF-8`（设置全局编码，默认是`UTF-8`），也可以在`Project Encoding`设置项目编码

###### `IDEA`快捷键自定义配置

快捷键自定义配置：菜单`file`-->`settings`-->`Keymap`-->选择具体的规则进行快捷键的修改

- 删除当前行：建议设置为`ctrl+d`

- 复制当前行：建议设置为`ctrl+alt+向下光标`

- 补全代码：`alt+/`

- 添加或取消注释：`ctrl+/`

- 导入该行需要的类：配置`auto import`

  ![image-20250329165813284](..\images\image-20250329165813284.png)

  然后使用`alt+enter`即可

- 快速格式化代码：`ctrl+alt+l`

- 快速运行程序：建议设置为`alt+r`

- 生成构造器的快捷键：`alt+insert`

- 查看一个类的层级关系：`ctrl+h`

- 定位到具体的方法：`ctrl+b`  将光标放在一个方法上，输入快捷键，可以定位到对应的方法

- 自动分配变量名：在变量后面加`.var`回车即可

###### 模板快捷键

模块快捷键可以帮助我们加快代码的编写速度，只需要输入定义的快捷键内容，就可以得到对于的代码模板

我们可以在`file`-->`settings`-->`editor`-->`Live templates`-->查看有哪些模板快捷键/自定义模板快捷键

系统提供的常用模板快捷键有：

- `main`模板快捷键对应的内容：

  ```java
  public static void main(String[] args) {
      
  }
  ```

- `sout`模板快捷键对应的内容：

  ```java
  System.out.println("hello,world");
  ```

- `fori`模板快捷键对应的内容：

  ```java
  for (int i = 0; i < ; i++) {
      
  }
  ```

对于自定义的模板快捷键，我们点击右上角的加号，输入快捷键的名字和内容，同时设置应用的范围，我们一般要应用给`Java`使用

#### `JDK`的安装

`JDK`是`Java`开发工具包，`JDK`=`JRE`+`Java`的开发工具（`java`、`javac`、`javadoc`、`javap`等）

`JRE`是`Java`的运行环境，包括了`Java`虚拟机和`Java`程序所需的核心类库等，如果想要运行一个开发好的（编译好的）`Java`程序，计算机中只需安装`JRE`即可

安装后的文件系统结构：

- `bin`目录：包含了所有的`Java`开发工具

  安装后，需要配置环境变量，将`bin`目录的路径添加到环境变量中

- `jre`目录：`jdk`中安装的`jre`目录

- `src.zip`：是`JDK`的源码包，里面有其源代码

***

### 运行机制

程序：计算机执行某些操作或解决某个问题而编写的一系列**有序指令的集合**

`Java`的运行机制和过程：`Java`程序可以运行在跨平台的系统上，其根本原因是由于`JVM`（`Java`的虚拟计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器），每个操作系统都可以去下载其对应的`JVM`，从而去运行`Java`程序，`JVM`是包含在`JDK`中的

`Java`虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行：

- 编译：将`Java`源文件通过编译器将其编译成`JVM`可以识别的字节码文件

  编译指令：`javac 编写的Java文件`

  如果程序没有错误，就可以编译成功，会在源文件目录中出现一个字节码文件，也就是可执行的`Java`程序

- 运行：通过运行工具`java.exe`对字节码文件进行执行，本质就是将`.class`文件装载到`jvm`机执行

- 运行指令：`java 编译后的Java文件`

![image-20250311211020786](..\images\image-20250311211020786.png)

对修改后的源文件，需要进行重新编译，生成新的`.class`文件，再执行，**才能生效**

***

### 第一个`Java`程序

```java
// 第一个java程序
// 编写一个类
public class Hello {
	// 编写一个类方法
	public static void main(String[] args) {
		System.out.println("helloWorld!");    // 一个结束语句要以分号结尾
	}
}
```

> 声明`Hello`是一个公有的类
>
> `public static void main(String[] args)`表示定义一个主方法，是一个程序执行的入口
>
> `static`表示定义一个静态的方法
>
> `System.out.printIn()`：内置的输入方法，将内容输出到屏幕上
>
> 在编译的时候，如果文件内有中文，包括注释，我们需要将编码方式改为`gbk`的形式，这样才能正常编译

使用命令行终端，在当前代码的目录下输入`javac Hello.java`进行编译，成功编译后，会出现`Hello.class`的编译结果文件，使用命令`java Hello`即可运行，得到运行结果

![image-20250311210554522](..\images\image-20250311210554522.png)

***

### 注释

注释是用于说明解释程序的文字提示，提高了代码的可读性，编写程序需要养成注释的好习惯，推荐先将自己的思想通过注释整理出来，再用代码去实现

- 单行注释

  ```java
  // 单行注释
  ```

  > 单行注释快捷键：选中区域+`ctrl`+`/ `取消注释同样是这个快捷键

- 多行注释

  ```java
  /* 多行
     注释 */
  ```

  > 多行注释中不能嵌套多行注释
  >
  > 多行注释快捷键：选中区域+`Ctrl`+`shift`+/ 取消注释是选中区域+Ctrl+shift+
  > 选中区域+Ctrl+shift+\

- 文档注释

  文档注释的内容可以被`JDK`提供的工具`javadoc`所解析，生成一套以网页文件形式体现的该程序的说明文档，文档注释一般写在类中（想要对类提供相关的注释，我们一般使用文档注释），只放在类、接口、成员变量、方法之前（因为Javadoc只处理这些地方的文档注释，而忽略其他地方的文档注释）

  文档注释要按照`javadoc`工具提供的标签进行，以`/**`开始， 以`*/`结束：

  ```java
  /**
   * @author  jlc
   * @version 1.0
   */
  ```

  > 将文档标签生成网页文件的命令：`javadoc -d 存放生成文档标签的文件夹目录地址 -xx -yy 要编译的文件`
  >
  > 对应的`xx`和`yy`，分别是文档注释中使用了的标签：`author`和`version`
  >
  > 文档注释在协作化项目开发过程中使用的是非常多的
  >
  > 文档注释快捷键：`alt`+`shift`+`j`

  文档注释常见的`javadoc`标签有：

  |      标签       |                             描述                             |
  | :-------------: | :----------------------------------------------------------: |
  |    `@author`    |                           作者标识                           |
  |  `@deprecated`  | 标识当前`API`已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个`API` |
  |  `{@docRoot}`   |                   指明当前文档根目录的路径                   |
  |  `@exception`   |                     标志一个类抛出的异常                     |
  | `{@inheritDoc}` |                     从直接父类继承的注释                     |
  |    `{@link}`    |               链接到某个特定的成员对应的文档中               |
  | `{@linkplain}`  |     插入一个到另一个主题的链接，但是该链接显示纯文本字体     |
  |    `@param`     |     方法的入参名及描述信息，如入参有特别要求，可在此注释     |
  |    `@return`    |                      对函数返回值的注释                      |
  |     `@see`      |            引用,查看相关内容，如类、方法、变量等             |
  |    `@serial`    |                      说明一个序列化属性                      |
  |  `@serialData`  |  说明通过`writeObject( )` 和` writeExternal( )`方法写的数据  |
  | `@serialField`  |               说明一个`ObjectStreamField`组件                |
  |    `@since`     |          描述文本,API在什么程序的什么版本后开发支持          |
  |    `@throws`    |                 构造函数或方法所会抛出的异常                 |
  |   `{@value}`    |             显示常量的值，该常量必须是static属性             |
  |   `@version`    |                            版本号                            |

***

### 标识符命名规则和规范

`Java`对各种变量、方法和类等命名时使用的字符序列称为标识符（凡是可以自己起名字的地方都叫标识符）

标识符命名规则（必须遵守的）：

- 由26个英文字母大小写，0-9.`_`或`$`组成

- 不可以以数字开头

- 不可以使用关键字和保留字，但是可以包括关键字和保留字

  `Java`中的关键字：被`Java`语言赋予了特殊的含义，用于专门用途的字符串（单词）

  ![image-20250317214437350](..\images\image-20250317214437350.png)

  ![image-20250317214623428](..\images\image-20250317214623428.png)

  `Java`中的保留字：现有的`Java`版本没有使用，但以后的版本可能会作为关键字使用

  ![image-20250317214751465](..\images\image-20250317214751465.png)

- 严格区分大小写，长度无限制

- 标识符不能包含空格

标识符命名规范（规范可以显得代码更加专业）：

- 包名：多单词组成时所有字母都小写：`aaa.bbb.ccc`
- 类名、接口名：多单词组成时，所有单词的首字母大写：`XxxYyy`（大驼峰形式）
- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：`xxxYyy`（小驼峰形式，简称驼峰法）
- 常量名：所有字母都大写，多单词时每个单词用下划线连接：`XXX_YYY`

***

### 开发规范

在`Java`开发过程中，我们需要遵守一些开发细节，这样才能减少一些不必要的错误：

1. `Java`应用程序的执行入口是`main()`方法，有固定的书写格式：

   `public static void main(String[] args) {...}`

2. `Java`严格区分大小写

3. `Java`方法由一条语句构成，每个语句以`;`结束

4. 大括号是成对出现的，建议先写`{}`，再写代码

5. 一个源文件中最多只能有一个`public`类，其他类的个数不限，但是，只要有一个类，不管是不是`public`类，在编译后，都会生成一个`.class`文件，即有几个类，就生成几个`.class`文件

6. 如果源文件包含一个`public`类，则文件名必须按照该类进行命名

7. 可以将`main`方法写在非`public`类中，然后指定运行编译后的非`public`类，这样入口方法就是非`public`的`main`方法，也就是说会运行这个类中的入口方法

8. 我们需要确保文件名和主类名保持一致，否则会编译出错

开发规范：

- 对于类、方法的注释，要以`javadoc`的方式来进行编写
- 对于非`javadoc`的注释，往往是给代码的维护者看的，着重告诉读者为什么这么写，如何修改，要注意什么问题等
- 运算符和等号左右各加一个空格
- 源文件使用`utf-8`编码
- 行宽不要超过80个字符

***

### `windows`系统下的`DOS`指令

`DOS`：磁盘操作系统，可以使用指令的方式对文件系统进行操作，常见的指令有：

- `dir`：查看当前目录中有什么

- `tree`：查看指定的目录下所有的子级目录

- `cd`：切换到其他目录    `cd .. `：返回上一级    `cd \`：切换到根目录

  切换到`C`盘：`cd /D c:`

- `md`：新建文件夹（目录）

- `rd`：删除文件夹（目录）

- `cls`：清除终端屏幕中的内容，清屏

- `exit`：退出命令行终端

- `type`：创建文件    `type nul > 文件名`

- `echo`：输入内容到文件中

  `echo hello > hello.txt`   在`hello.txt`文件中就插入了`hello`内容，先创建在写入

- `copy`：复制文件

- `move`：剪切文件

- `del`：删除文件

相对路径：从当前目录开始定位，形成的一个路径

绝对路径：从根目录（顶级目录）开始定位，形成的路径

***

### 断点调试

在开发过程中，断点调试可以一步步的看源码的执行过程，从而帮助我们发现错误所在

重要提示：在断点调试的过程中，是运行状态，对象是以运行类型来执行的

断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后可以一步步的往下调试，调试过程中可以看各个变量的当前值，出错的话，调试到出错的代码执行会显示错误，程序停止，我们可以进行分析找打`Bug`

断点调试可以帮助我们查看`Java`的底层代码执行过程，提高程序员的代码水平

断点可以在`debug`过程中，动态的进行下断点的

在`IDEA`中，断点调试的快捷键：

- `F7`（跳入方法内）、`F8`（跳过，逐行执行代码）、`shift+F8`（跳出当前方法）、`F9`（`resume`，执行到下一个断点）

对于系统的方法，我们无法进入源码的设置：

点击`Setting`-->`Build,Exection,Deployment`-->`Debugger`-->`Stepping`-->把`Do not step into the classes`中的`java.*`、`javax.*`取消勾选，这样我们就可以通过快捷键`F7`进入源码了



## 转义字符

`Java`中常见的转义字符有：

- `\t`：一个制表位，实现左对齐的功能

- `\n`：换行符

- `\\`：一个`\`      如果要在控制台中输出两个`\`，需要使用两个斜杠进行转义：`\\\\`

- `\"`：一个`"`

- `\'`：一个`‘`

- `\r`：一个回车

  回车是将光标放到最前面，如`System.out.println("jlc\r1")`，打印的结果就是：`1lc`

  光标回到最前面，在打印1，将第一个字符覆盖掉了



## 进制

对于一个整数，有四种表示方式：

- 二进制：0，1     满2进1    以`0b`或者`0B`开头
- 十进制：0 - 9     满10进1
- 八进制：0 - 7     满8进1    以数字`0`开头
- 十六进制：0 - 9以及A(10) - F(15)  （A-F不区分大小写） 满16进1    以`0x`或者`0X`开头

***

### 进制的转换

进制的转换是程序员的一个基本功

#### 其他进制转十进制

- 二进制转十进制

  从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，再求和

  0b1011 = 1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3 = 11

- 八进制转十进制

  从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，再求和

  0234 = 4 * 8^0 + 3 * 8^1 + 2 * 8^2 = 156

- 十六进制转十进制

  从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，再求和

  0x23A = 10 * 16^0 + 3 * 16^1 + 2 * 16^2 = 570

#### 十进制转其他进制

- 十进制转二进制

  将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就得到对应的二进制

  34 = 0B100010

  ![image-20250318161833331](..\images\image-20250318161833331.png)

  由于一个字节是有八位的，所以最后的结果位34 = 0B00100010

- 十进制转八进制

  将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就得到对应的八进制

  131 = 0203

  ![image-20250318162118043](..\images\image-20250318162118043.png)

- 十进制转十六进制

  将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就得到对应的十六进制

  237 = 0XED

  ![image-20250318162316565](..\images\image-20250318162316565.png)

#### 其他进制转二进制

- 八进制转二进制

  将八进制的每一位，转成对应的一个3位二进制即可

  0237 = 0b010011111

  由于一个字节是有八位的，所以最后的结果位0237 = 0b10011111

- 十六进制转二进制

  将十六进制的每一位，转成对应的一个4位二进制即可

  0x23B = 0b001000111011

#### 二进制转其他进制

- 二进制转八进制

  从低位开始，将二进制数每三位一组，转成对应的八进制即可

  0b11010101 = 0325

- 二进制转十六进制

  从低位开始，将二进制数每四位一组，转成对应的十六进制即可

  0b11010101 = 0xd5



## 变量

程序中需要变量，我们可以通过不同类型的变量来代表不同的数据，变量是程序的基本组成单位

变量相当于内存中一个数据存储空间的表示，通过变量名，我们可以访问到这个变量的具体值（总之，变量可以代表一个变化的值）

变量有三个基本的要素：类型、名称和值，如`int a = 1;`

- 变量需要先声明，再使用，可以简写声明和赋值在同一行
- 变量的值可以在同一类型中进行不断的变化，即可以重复的进行同一类型的赋值
- 变量是在内存中的一个存储区域，不同类型的变量，占用的空间大小是不同的，如`int`占4个字节，`double`占8个字节
- 变量名在同一个作用域不能重名

***

### 数据类型

`Java`是强类型语言，每一种数据都要明确数据类型

在实际的使用中，有很多的数据类型，对于不同用途的数据，我们声明不同数据类型的变量

#### 基本数据类型

##### 数值型

- 整数类型，用来存放整数：

  - `byte[1]`：`byte`类型（字节），占1个字节，范围-128~127
  - `short[2]`：`short`类型（短整型），占2个字节，范围-32768~32767
  - `int[4]`：`int`类型（整型），占4个字节，范围-2147483648~2147483647
  - `long[8]`：`long`类型（长整型），占8个字节，范围-2^63~2^63-1

  > `bit`是计算机中的最小存储单位，1`byte` =8`bit`，字节`byte`是计算机中的基本存储单位
  >
  > `byte b = 10;`通常情况下，10在`Java`中默认是一个`int`类型，但是当把具体的数赋值给`byte`（`short`类型同理）时，系统会先判断当前值是否在`byte`范围内，如果是，就可以正常的赋值，但是以下的方式是不正确的：
  >
  > ```java
  > int n = 1;
  > byte b = n;   // 编译报错，变量赋值，需要先判断类型
  > ```
  >
  > n在内存中先声明了4个字节大小的存储空间中，但是b声明的存储空间只有1个字节
  >
  > 总之，具体数赋值，先判断范围；变量赋值，先判断类型
  >
  > `Java`的整型常量（具体值）默认为`int`型，声明`long`型常量需后面加上`l`或`L`，如`long n = 1L;`

- 浮点型，用来存放小数：

  - `float[4]`：单精度浮点类型，占4个字节，范围-3.403E38~3.403E38
  - `double[8]`：双精度浮点类型，占8个字节，范围-1.798E308~1.798E308

  > 浮点数在计算机中的存放形式：浮点数=符号位+指数位+尾数位
  >
  > 其中，尾数部分可能丢失，造成精度的损失（小数都是近似值）
  >
  > `Java`的浮点型常量（具体值）默认为`double`型，声明`float`型常量，需后面加`f`或者`F`，如`float n = 1.1F;`（`float n = 1.1;`会报错，不能将`double`类型赋值给`float`类型的变量），大的字节范围不能往小的字节范围内放，但是小的字节范围可以往大的字节范围内放，如`double n = 1.1f;`是正确的，编译不会报错
  >
  > 通常情况下，我们应该使用`double`类型，因为它的精度比`float`型更精确（精度低，会导致过长的小数点后的内容丢失）
  >
  > 浮点型常量有两种表示形式：
  >
  > - 十进制数形式：如：5.12     512.0f    .512（前面的0可以省略，但是必须有小数点）
  > - 科学计数法形式：如：5.12e2（5.12*10的2次方，返回的是512.0，因为是浮点数类型）    5.12E-2
  >
  > 浮点数的使用陷阱：
  >
  > ![image-20250313201321542](..\images\image-20250313201321542.png)
  >
  > 计算机在接收8.1的时候，不能确定8.1小数位的1后面是否还有其他的位数，它可能认为是8.10000001，所以，在计算结果的时候，也是以精度的方式进行返回的
  >
  > 所以说，当我们对小数的运行结果进行相等判断的时候，要格外的注意，应该通过两个数的差值的绝对值，在某个精度范围内进行判断

##### 字符型

- 字符类型：`char[2]`，存放单个字符`'a'`，该类型占两个字节，可以存放一个汉字

> 字符常量是用单引号`''`括起来的单个字符，不能使用双引号，如果使用双引号，就是字符串类型了
>
> 如`char c = "9";`编译器就会报错，字符串类型不能赋值给字符类型的变量
>
> `String`字符串类型，不是基本数据类型，实际上它是一个类，多个字符，我们使用字符串来存放
>
> 在`Java`中，`char`的本质是一个整数，在输出的时候，是`unicode`码对应的字符，字符类型也可以直接存放一个数字：`char c = 97;`，但是输出的是`a`，97在计算机中的`ASSCII`码中对应的是`a`，对于任意的汉字字符，也有具体对应的`unicode`码，如果我们想要将对应的字符转换为对应的`unicode`码，我们将这个字符通过`int`类型进行转化即可得到对应的`unicode`码
>
> `Java`中允许使用转义字符`\`，来将其后面跟着的字符转变为特殊字符型常量，如`char c = '\n';`
>
> `char`类型是可以进行运算的，该类型相当于一个整数，任何字符都要对应的`unicode`码
>
> 字符串的比较，使用到了`equals`的字符串方法：`"jlc".equals(name);`   判断`name`字符串类型的值是不是`“jlc”`，如果是，返回`true`，否则返回`false`

字符类型的本质讨论：字符型数据存储到计算机中，需要将字符对应的码值（整数）找出来，如`'a'`字符：

存储：`'a'`  --->  码值  --->   二进制    --->   存储

读取：二进制   --->   97   --->   `'a'`   --->   显示

##### 布尔型

- `boolean[1]`：布尔类型，占1个字节，只允许取`true`和 `false`

  `boolean`类型适用于逻辑运算

  在`Java`语言中，不能使用0或非0的整数来代替`false`和`true`，这一点和`C`语言是不同的

##### 自动类型转换

当`Java`程序在进行赋值或者运算时，精度小的类型可以自动转换为精度大的数据类型，这个就是自动类型的转换

![image-20250315160649836](..\images\image-20250315160649836.png)

箭头的流向表示低精度向高精度进行转换

在理论上，`int a = 'c';`该语句的语法是错误的，不能将`char`字符类型赋值给`int`数值类型，但是有了自动类型转换，精度低的`char`类型，可以自动的转化为`int`类型，所有`int a = 'c';`该语句在编译的过程中不会报错

低精度的类型，可以连跨级别的向高精度的类型进行自动转换

自动类型转换细节：

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量（精度）最大的那种数据类型，然后再进行计算

2. 当我们把容量（精度）大的数据类型赋值给容量（精度）小的数据类型时，就会报错，反之则会进行自动类型的转换

3. （`byte`、`short`）和`char`之间不会互相自动转换

   ```java
   byte b = 10;
   char c = b;   // 报错，byte类型不会自动转换为char类型
   ```

4. `byte`、`short`和`char`它们三者可以计算，在计算时（不管是单独类型的计算还是混合类型的计算）首先转换为`int`类型

   ```java
   byte b = 1;
   short s1 = 1;
   short s2 = b + s1;   // 报错，运算后，转化成了int类型，不能赋值给精度小的short类型
   
   byte b2 = 1;
   byte b3 = b + b2;   // 报错，byte类型在运算后会转化为int类型
   ```

5. `boolean`类型不参与转换

6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

##### 强制类型转化

强制类型转化是自动类型转换的逆过程，将容量（精度）大的数据类型转换为容量（精度）小的数据类型，使用时需要加上强制转换符`()`，但是，强制类型转换可能会造成精度的降低或溢出，需要格外注意

```java
int i = (int)1.9;    // 强制将double类型转换为int类型，精度损失了，结果输出为1，掉了小数位
```

强制类型转换细节：

1. 强制符号只针对于最近的操作数有效，往往会使用小括号提升优先级

   ```java
   int x = (int)10 * 3.5 + 6 * 1.5;    // 编译不通过，不能将double类型赋值给int类型
   
   int x = (int)(10 * 3.5 + 6 * 1.5);  // 结果为44
   ```

#### 引用数据类型

- 类（`class`）
- 接口（`interface`）
- 数组（`[]`）

#### 基本数据类型和`String`类型的转换

- 基本数据类型转`String`类型，语法：将基本类型的值+`""`即可：

  ```java
  int n = 100;
  float f = 1.1F;
  double d = 4.5;
  bollean b = true;
  // 基本数据类型转String字符串
  String s1 = n + "";
  String s2 = f + "";
  String s3 = d + "";
  String s4 = b + "";
  ```

- `String`类型转基本数据类型，语法：通过基本类型的包装类调用`parseXX`方法：

  ```java
  String s = "123";
  // String字符串转换为基本数据类型
  int n = Integer.parseInt(s);  // 123
  double d = Double.parseDouble(s);  // 123.0
  float f = Float.parseFloat(s);   // 123.0
  Long l = Long.parseLong(s);   // 123
  byte b = Byte.parseByte(s);   // 123
  short s = Short.parseShort(s);  // 123
  boolean b = Boolean.parseBoolean("true");   // true
  ```

  > 使用基本数据类型对应包装类的相应方法进行转换，将字符串类型转换为基本数据类型

  对于将字符串转换成字符`char`类型，是将字符串的第一个字符取下来：

  ```java
  String s = "123";
  s.charAt(0);   // '1'
  ```

  注意：将字符串类型转换成基本的数据类型时，要确保字符串类型能够转成有效的数据，如，不能将字母转换成整数，如果格式不正确，系统会抛出异常

***

### 加号的使用

在程序中，加号有不同的用途：

- 当左右两边都是数值型时，则做加法运算
- 当左右两边有一方为字符串，则做拼接运算

***

### 编码

字符和码值的对应关系是通过字符编码决定的（是规定好的）常见的字符编码表有：

- `ASCII`：一个字节表示，一共表示了128个字符，实际上一个字节可以表示256个字符，但是`ASCII`字符集只使用了128个字符，这个编码是为英文国家创建的，英文只有26个字母，加上一些符号，128个字符足够使用了
- `Unicode`：`ASCII`表的一个扩展（`Unicode`码是兼容`ASCII`码的，同样的`'a'`都是用97来表示），固定大小的编码，使用两个字节来表示字符，字母和汉字统一都是占用两个字节，比较浪费空间
- `utf-8`：大小可变的编码，可以使用1至6个字节来表示一个符号，根据不同的符号而变化字节长度，字母使用一个字节，汉字使用三个字节，在互联网中使用最广的一种`Unicode` 的实现形式
- `gbk`：可以表示汉字，而且范围广，字母使用一个字节，汉字使用两个字节（编码的汉字种类较`utf-8`少，`utf-8`汉字是使用三个字节的，涉及到的汉字种类范围广）
- `big5`：可以表示繁体中文

不同的编码，对文件的大小是有影响的，有的编码汉字是用两个字节表示的，有的编码汉字是用三个字节表示的，会对保存的文件大小造成影响



## 运算符

运算符是一种特殊的符号，用于表示数据的运算、赋值和比较等

### 算数运算符

算数运算符是对数值类型的变量进行运算的，常见的算数运算符有：

![image-20250316101219733](..\images\image-20250316101219733.png)

```java
System.out.println(10 / 4);   // 结果显示2   10和4都是整数，结果也要是整数，会把小数部分去掉
System.out.println(10.0 / 4);  // 结果为2.5
double d = 10 / 4;   // 结果为2.0

System.out.println(10 % 3);   // 结果显示1
System.out.println(-10 % 3);   // 结果显示-1
System.out.println(10 % -3);   // 结果显示1
System.out.println(-10 % -3);   // 结果显示-1
```

> 在`Java`中，`a % b`取模的本质是`a - a / b * b`

```java
// 如果独立使用++，前自增和后自增是一样的
int i = 10;
i++;   // 等价于 i = i + 1
++i;   // 等价于 i = i + 1
System.out.println(i);  // 结果显示12

// 如果自增作为表达式使用，前++：先自增后赋值；后++：先赋值后自增
int i = 8;
int k = ++i;   // k为9，i为9
int j = 8;
int h = j++;   // h为8，j为9
```

***

### 关系运算符

关系运算符也叫比较运算符，运算结果都是`boolean`类型，也就是要么是`true`，要么是`false`

关系运算符经常用在`if`结构的条件中或循环结构的条件中，常见的关系运算符有：

![image-20250316110533527](..\images\image-20250316110533527.png)

关系运算符组成的表达式，我们称为关系表达式

***

### 逻辑运算符

逻辑运算符是用于连接多个条件（多个关系表达式），最终的结果也是一个布尔类型

逻辑运算符有两种形式：

![image-20250316111346482](..\images\image-20250316111346482.png)

逻辑运算符规则：

- 逻辑与：`a & b`，当`a`和`b`同时为真时，结果为真，否则为假

- 逻辑或：`a | b`，当`a`和`b`有一个为真时，结果为真，否则为假

- 逻辑非：`!a`，取反运算，当`a`为真时，结果为假

- 短路与：`a && b`，当`a`和`b`同时为真时，结果为真，否则为假，如果`a`为假，则`b`语句将不会执行判断

  ```java
  int a = 4;
  int b = 9;
  if (a < 1 && ++b < 50) {
      System.out.println('ok');    // 不执行
  }
  System.out.println(a, b);   // 结果显示4,9
  ```

  但是对于逻辑与来说，如果`a`为假，`b`语句还会进行判断：

  ```java
  int a = 4;
  int b = 9;
  if (a < 1 & ++b < 50) {
      System.out.println('ok');    // 不执行
  }
  System.out.println(a, b);   // 结果显示4,10
  ```

- 短路或：`a || b`，当`a`和`b`有一个为真时，结果为真，否则为假，如果`a`为真，则`b`语句将不会执行判断

  但是对于逻辑或来说，如果`a`为真，`b`语句还会进行判断

- 逻辑异或：`a ^ b`，当`a`和`b`不同时，结果为真，否则为假

> - 在开发中，基本上都是使用短路与为主，因为前一个为假，后面的就不在判断执行了，效率高
> - 在开发中，基本上都是使用短路或为主，因为前一个为真，后面的就不在判断执行了，效率高

***

### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量

- 基本赋值运算符  `=`
- 复合赋值运算符  `+=`、`-=`、`*=`、`/=`、`%=`

注意事项：

- 赋值运算符的运算顺序是从右往左

- 赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值

- 复合赋值运算符会进行类型的强制转换

  ```java
  byte b = 2;
  b += 3;   // 等价于 b = (byte)(b + 3);    b + 3的类型是int，如果没有进行类型转换是编译不了的
  ```

***

### 三元运算符

基本语法：`条件表达式 ? 表达式1 : 表达式2;`

如果条件表达式为`true`，运算后的结果是表达式1；如果条件表达式为`false`，运算后的结果是表达式2

如果执行了表达式1，那么表达式2是不会执行的，反之同理

注意事项：

- 表达式1和表达式2要为可以赋给接收变量的类型（或可以进行自动转换）

  ```java
  int a = 3;
  int b = 4;
  int c = a > b ? 1.1 : 3.4;     // 报错，编译不通过，double类型不能赋值给int类型
  double d = a > b ? a ; b;  // 不会报错，可以进行自动的类型转换，int类型可以自动转化到double类型
  ```

***

### 位运算符

计算机内部处理信息都是采用二进制数来表示

原码、反码和补码的概念：

对于有符号的数而言，有以下的八个规则（要背下来）：

1. 二进制的最高位是符号位：0表示正数；1表示负数
2. 正数的原码、反码和补码都一样
3. 负数的反码=它的原码符号位不变，其他位取反
4. 负数的补码=它的反码+1；   负数的反码=负数的补码-1
5. 0的反码、补码都是0
6. `Java`没有无符号数，也就是说`Java`中的数都是有符号的
7. 在计算机运算的时候，都是以补码的方式进行运算的（补码可以解决正数和负数）
8. 当我们看运算结果的时候，要看他的原码

常见的位运算符有：位运算符的使用，先将两边的值先全部转成二进制，再得到这个二进制的补码，最后参与运算，运算后的结果先转回二进制的原码，再转回十进制

- `~`按位取反：0变1，1变0

  ~-2的运算过程：

  ![image-20250318205143135](..\images\image-20250318205143135.png)

  ~2的运算过程：

  ![image-20250318205419910](..\images\image-20250318205419910.png)

- `&`按位与：两位全为1，结果为1，否则为0

  2 & 3的运算过程：由于是`int`类型，占4个字节

  ![image-20250318204848579](..\images\image-20250318204848579.png)

- `|`按位或：两位有一个为1，结果为1，否则为0

- `^`按位异或：两位一个为0一个为1，结果为1，否则为0

- `>>`算数右移：低位溢出，符号位不变，并用符号位补溢出的高位

  `1 >> 2;`结果为0，表示将十进制的1先转为二进制，再向右位移两位，本质就是`1/2/2`

- `<<`算数左移：符号位不变，低位补0

  ``1 << 2;`结果为4，表示将十进制的1先转为二进制，再向左位移两位，本质是`1*2*2`

- `>>>`无符号右移：低位溢出，高位补0

***

### 运算符的优先级

运算符有不同的优先级，下图中的运算符优先级从高到低依次为：

![image-20250317203153087](..\images\image-20250317203153087.png)

只有单目运算符、赋值运算符是从右往左的，其他运算符都是从左到右的

优先级由高到低大致优先级分类为括号、单目运算符、算数运算符、位移运算符、比较运算符、逻辑运算符、三元运算符、赋值运算符



## 键盘输入语句

在编程中，需要接收用户输入的数据，我们可以使用键盘输入语句来进行获取

使用键盘输入语句需要使用一个扫描器对象（`Scanner`）

```java
import java.util.Scanner;    // 将包java.util下的Scanner类进行导入
pubilc class Input {
    public static void main(String[] args) {
        // 创建Scanner对象
        Scanner myScanner = new Scanner(System,in);
        // 接收用户的输入，使用相关的方法
        System.out.println("请输入名字");
        String name = myScanner.next();   // 程序执行到这句话时，会等待用户进行输入
        
        System.out.println("请输入年龄");
        int age = myScanner.nextInt();
        
        System.out.println("请输入成绩");
        double score = myScanner.nextDouble();
    }
}
```



## 控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，控制结构主要有三大流程控制语句

### 顺序控制

程序从上到下逐行执行，中间没有任何判断和跳转，顺序控制是程序默认的控制语句

***

### 分支控制

#### `if else`分支

分支控制是让程序有选择（根据判断进行选择）的执行，分支控制有三种形式：

- 单分支

  基本语法：

  ```java
  if(条件表达式) {
      执行代码块;
  }
  ```

  > 当条件表达式为`true`时，就会执行`{}`的代码，如果`{}`中只有一条语句，可以不使用`{}`进行包裹

- 双分支

  基本语法：

  ```java
  if(条件表达式) {
      执行代码块1;
  }
  else {
      执行代码块2;
  }
  ```

  > 当条件表达式为`true`时，执行代码块1，否则执行代码块2

- 多分支

  基本语法：

  ```java
  if(条件表达式1) {
      执行代码块1;
  }
  else if(条件表达式2) {
      执行代码块2;
  }
  ...
  else {
      执行代码块n;
  }
  ```

  > 当对应的表达式为`true`时，执行对应的代码块，如果条件表达式都不成立，则执行代码块n
  >
  > 多分支可以没有`else`，如果所有的条件表达式都不成立，则一个执行入口都没有

嵌套分支：在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支，但是建议分支不要超过3层，因为可读性不好

基本语法：

```java
if(条件表达式1) {
    if(条件表达式2) {
        执行代码块2;
    }
    else {
        执行代码块3;
    }
}
```

#### `switch`分支

基本语法：

```java
switch(表达式) {
    case 常量1:
        语句块1;
        break;
    case 常量2:
        语句块2;
        break;
    default:
        default语句块;
        break;
}
```

> 如果表达式的结果和`case`常量1匹配，就执行语句块1，如果没有匹配，就继续和`case`常量2进行匹配，以此类推，如果一个都没有匹配上，执行`default`语句块
>
> `break`表示退出`switch`语句
>
> 如果执行完一个`case`语句块后，没有执行`break`语句，那么不会退出`switch`语句，会继续进行后面`case`的语句块，不需要进行匹配，会直接穿透执行，同时，如果前面没有`break`的话还会执行`default`的语句块
>
> 对于`default`匹配项，有没有`break`是无所谓的，执行了`default`语句块都会退出`switch`语句

注意细节：

- 表达式的数据类型，应该和`case`后面的常量类型一致，或者是可以自动转换成可以相互比较的类型（如输入的是字符，而常量是`int`）

- `switch`（表达式）中表达式的返回值必须是

  ```java
  double c = 1.1;
  switch(c) {   // 报错double类型不能使用
      case 1.1:
          ...
  }
  ```

- `case`句子中的值必须是常量（具体的值），或者是计算表达式（得到的也是常量），不能是变量

- `default`句子是可选的，当没有匹配的`case`时，执行`default`

- `break`语句用来执行完一个`case`分支后使程序跳出`seitch`语句块，如果没有写`break`，程序会顺序执行到`switch`结尾

#### `if`和`switch`使用的选择

- 如果判断的具体数值不多，而且符合（`byte`、`short`、`int`、`char`、`enum`、`String`）这六种类型，建议使用`switch`语句
- 其他情况，对区间判断，对结果为`boolean`类型判断，使用`if`语句，`if`语句的使用范围更广

***

### 循环控制

循环控制就是让代码可以循环的执行

#### `for`循环

基本语法：

```java
for(循环变量初始化;循环条件;循环变量迭代) {
    循环操作(语句);
}
```

> 如果循环条件为`true`，就会执行一次循环操作

注意事项：

- 循环条件是返回一个布尔值的表达式

- `for(;循环条件;)`中的初始化和变量迭代可以其它地方，但是两边的分号不能省略

  ```java
  int i = 1;
  for(;i <= 10;) {
      循环操作(语句);
      i++;
  }
  ```

- 循环的初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

  ```java
  int count = 3;
  for(int i = 0, j = 0; i < count; i++, j += 2) {
      System.out.println(i, j);     // 0,0   1,2   2,4
  }
  ```

  编程思想：化繁为简（将复杂的需求先拆分一个个简单的需求，逐步完成），先死后活（先考虑固定的值，再转成可以灵活变化的值）

#### `while`循环

基本语法：

```java
循环变量初始化;
while(循环条件) {
    循环体(语句);
    循环变量迭代;
}
```

注意事项：

- 循环条件是返回一个布尔值的表达式
- `while`循环是先判断，再执行语句

#### `do..while`循环

基本语法：

```java
循环变量初始化;
do {
    循环体(语句);
    循环变量迭代;
}while(循环条件);
```

注意事项：

- `do..while`循环是先执行，再判断，也就是说至少会执行一次

#### 多重循环控制

将一个循环放在另一个循环体内，就形成了嵌套循环，一般建议使用两层即可，最多不要超过三层，否则代码可读性大大降低

实际上，嵌套循环就是把内层循环当外层循环的循环体，当只有内存循环的循环条件为`false`时，才会完全跳出内层循环，才可以结束外层的当次循环，开始外层的下一次循环

设置外层循环次数为`m`次，内层循环为`n`次，则内层循环体一共执行`m*n`次

```java
// 打印空心金字塔
public class HollowPyramids {
	public static void main(String[] args) {
		int totalLevel = 5;
		for(int i = 1; i <= totalLevel; i++) {
			for(int k = 1; k <= totalLevel - i; k++) {
				System.out.print(" ");
			}
			for(int j = 1; j <= 2 * i - 1; j++) {
				if (j == 1 || j == 2 * i - 1 || i == totalLevel) {
					System.out.print("*");
				}
				else {
					System.out.print(" ");
				}
			}
			System.out.println(" ");
		}
	}
}
```

> `System.out.print("*");`表示输出后不换行
>
> `System.out.println("*");`表示输出后换行

#### `break`关键字

在循环语句的流程控制中，我们可以使用`break`语句来终止某个语句块的执行

基本语法：

```java
{
    ...
    break;
}
```

> 执行到`break`时跳出整个循环，用于提前终止循环
>
> ```java
> for(int i = 0; i < 10; i++) {
>     if(i == 3) {
>         break;
>     }
>     System.out.print(i);
> }
> // 结果输出  012
> ```

`break`语句出现在多层嵌套语句块中时，可以通过标签指明要终止的是哪一层语句块

```java
label1: {   ......
label2:		{   ......
label3:			{   ......
    				break label2;
                 	......
				}    
			}    
        }
```

> `break`语句可以指定退出到哪层
>
> `label1`是标签，名称由程序员指定，`break`后指定到哪个`label`，就退出到哪里
>
> 如果没有指定`break`，则默认退出最近的循环体
>
> 在实际开发中，尽量不要使用标签，会导致可读性变差

#### `continue`关键字

`continue`语句用于结束本次循环，继续执行下一次循环

基本语法：

```java
{
    ...   
    continue;
    // 执行了continue语句，本次循环后面的内容就不执行了
}
```

如果`continue`语句出现在多层嵌套的循环语句体中，可以通过标签指明要跳出哪一层循环

#### `return`关键字

`return`通常与方法函数一起使用，表示跳出所在的方法，如果`return`写在`main`方法中，会退出主程序



## 数组

数组可以存放多个同一类型的数据，数组也是一种数据类型，是引用类型

数组就是一组数据

数组的定义：

```java
double[] newArray = {1.2, 2, 3.5};
```

> `double[] newArray `等价于`double newArray[] `
>
> `double[]`表示声明`double`类型的数组，数组中的数据都应该是`double`类型
>
> `newArray`表示定义的数组名
>
> `{1.2, 2, 3.5}`表示数组的值（数组的元素），我们可以通过元素的下标来进行数组中具体元素的访问`[i]`
>
> 下标是从0开始编号的，表示数组中的第一个元素

数组可以通过`for`循环进行遍历，从而读取数组中的每个元素：

```java
double[] newArray = {1.2, 2, 3.5};
for (int i = 0; i < newArray.length; i++) {
    System.out.println(newArray[i]);
}
```

注意事项：

- 数组是多个相同类型数据的组合，实现对这些数据的统一管理

- 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但不能混用

  如果满足自动类型转换的，那么可以混合使用

- 数组创建后，如果没有赋值，有默认值，不同的类型默认值不一样：`int 0`、`short 0`、`byte 0`、`long 0`、`float 0.0`、`double 0.0`、`char \u0000`、`boolean false`、`String null`

- 使用数组的步骤：1.声明数组并开辟空间；2.给数组各个元素赋值；3.使用数组

- 数组的下标是从0开始的

- 数组下标必须在指定范围内使用，下标的最大值是数组的长度减一，否则会报错：下标越界异常

- 数组属于引用类型，数组的数据类型是对象`object`

***

### 动态初始化

动态初始化方式一：`数据类型 数组名[] = new 数据类型[大小];`

如：`int a[] = new int[5];`   创建了一个数组，名字为`a`，存放5个`int`类型的数据，变量`a[0]`就指向了数组中的第一个元素

动态初始化方式二：

- 先声明数组：`数据类型 数组名[];`      如：`int a[];`   内存中有了数组`a`变量，但是是空值，没有返回空间
- 再创建数组：`数组名 = new 数据类型[大小];`     如：`a = new int[10];`    内存中开辟了空间

***

### 静态初始化

直接在声明的时候给定具体的值：`数据类型 数组名[] = {元素值, 元素值, ...};`

***

### 数组赋值机制

对于基本数据类型赋值，这个值就是具体的数据，且互相不影响，这种赋值方式为值拷贝，但是对于数组进行赋值，数组在默认情况下是引用传递，赋的值是地址，赋值方式为地址拷贝或者引用拷贝

```java
int arr1[] = {1, 2, 3};
int arr2[] = arr1;     
arr2[0] = 10; // arr1数组的第一个值也变成了10，数组arr2的变化会影响arr1的变化，两个数组共有一共内存地址
```

从内存地址的角度进行分析：

![image-20250322211151308](..\images\image-20250322211151308.png)

> 在`jvm`中，内存由三个部分组成：栈、堆和方法区
>
> 对于值传递\值拷贝：会在栈中开辟一块空间（基本类型的存储都是在栈中开辟空间的），如果将`n1`赋值给`n2`，会将值拷贝一份，放到一个新开辟的内存空间，后续`n2`的值发生改变，不会对`n1`的值造成任何影响
>
> 对于引用传递\地址拷贝：数组会在栈中开辟一块空间，用于存放地址，地址的具体内容在堆中存放，通过地址可以访问到堆中的数据，如果数组进行赋值，会将地址进行拷贝，但是指向的还是同一个区域，所有对`arr2`数组的内容进行修改，会影响`arr1`的内容

***

### 数组的拷贝

经过数组的赋值机制，我们知道，我们对数组的赋值只是地址拷贝，两个数组公用一个内存地址

如果我们就想要得到一个完整的数组，我们需要进行数组的拷贝，这样两个数组的数据空间是独立的

```java
int arr1[] = {10, 20, 30};
// 为arr2开辟一个新的数据空间，大小和arr1数组一样
int arr2[] = new int[arr1.length];
for(int i = 0; i < arr1.length; i++) {
    arr2[i] = arr1[i];
}
```

***

### 数组的反转

将数组中的元素值进行反转，第一个元素变成最后一个

常见方法：

```java
int arr[] = {11, 22, 33, 44, 55, 66};
int length = arr.length;
int temp = 0;
for(int i = 0; i < length / 2; i++) {
    temp = arr[length - 1 - i];  // 使用临时变量进行保存
    arr[arr.length - 1 - i] = arr[i];
    arr[i] = temp;
}
```

逆序遍历：创建一个相等大小的新数组，逆序遍历，顺序拷贝，最后将原数组进行指向（原数组就会被垃圾回收）

```java
int arr[] = {11, 22, 33, 44, 55, 66};
int arr2[] = new int[arr.length];
for(int i = arr.length - 1; i >= 0; i--) {
    arr2[arr2.length - i] = arr[i]; 
}
arr = arr2;
```

***

### 数组的扩容

数组的扩容也叫数组的添加，可以实现动态的给数组添加元素，实现对数组的扩容

我们需要定义一个新的数组，其数组的大小是原先数组大小加一，将原数组的数组值依次进行拷贝，最后一个数组值存放新的内容，最后将原数组进行指向这个新的数组：

```java
int arr[] = {1, 2, 3};
int arr2[] = new int[arr.length + 1];
for(int i = 0; i < arr.length; i++) {
    arr2[i] = arr[i];
}
arr2[arr2.lengh - 1] = 4;
arr = arr2;
```

数组的缩减和数组的扩容思路类似

***

### 排序

排序是将多个数据，依指定的顺序进行排序的过程

排序的分类：

- 内部排序：将需要处理的所有数据都加载到内部存储器中进行排序，包括：交换式排序法、选择式排序法和插入式排序法
- 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序，包括：合并排序法和直接合并排序法

#### 冒泡排序法

通过对待排序序列从前向后（从下标小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒

![image-20250324203453472](..\images\image-20250324203453472.png)

> 有多少个元素，就进行了几轮的排序（可以看成是外层循环），每一轮排序会确定一个数的位置（如第一轮排序确定最大数，第二轮排序确定第二大的数）
>
> 当进行比较时，如果发现前面的数大于后面的数，就交换两个数的位置
>
> 每一轮的比较在逐渐减小（因为每一轮比较的数据量在减小）

代码实现：

```java
int arr[] = {24, 69, 80, 57, 13};
int temp = 0;
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j <  arr.length - 1 - i; j++) {
        if(arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
    System.out.println("\n==第" + (i + 1) + "轮排序==");
    for(int j = 0; j < arr.length; j++) {
        System.out.print(arr[j] + "\t");
    }
}
```

***

### 查找

在`java`中，常见的查找方式有两种：

1. 顺序查找：先和第一个元素进行比较，如果不匹配，再和下一个元素进行比较，如果找到了，就将结果返回即可
2. 二分查找：对一个排列从小到大的有序数组进行查找，先查找中间这个数，如果匹配就返回，如果不匹配，就和中间这个数进行判断大小，如果要查找的数组比中间这个数大，就往右边（后面）查找，依次二分类推

***

### 二维数组

对于一维数组中的每一个元素，如果这个元素还是一个数组，我们将这个数组称为二维数组

动态初始化：`类型[][] 数组名 = new 类型[大小][大小];`    如：`int a[][] = new int[2][3];`

> 第一个大小表示包含几个一维数组；第二个大小表示一维数组中包含几个元素

定义二维数组（静态初始化）：`数据类型 数组名[][] = {一维数组, 一维数组};`    其中`[][]`可以写在数据类型的后面，二维数组的每一个元素都是一个一维数组，二维数组中只能放一维数组，不能放其他基本类型的数据

输出二维数组：

```java
int arr[][] = {{1, 2}, {2, 3}};
for(int i = 0; i < arr.length; i++) {   // 统计多少个一维数组
    // 遍历二维数组的每个元素
    // arr[i]表示二维数组的第i个元素
    // arr[i].length表示得到对应的一维数组的长度
    for(int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j]);
    } 
    System.out.println();  // 换行
}
```

> 对于二维数组，如果要访问第(i+1)个元素的第(j+1)个值，我们应该这样访问：`arr[i][j]`

二维数组在内存中的存在形式：（重要）

![image-20250325100957997](..\images\image-20250325100957997.png)

> 二维数组在栈中，通过一个地址指向堆中的一个空间，该空间中存放的还是地址，用于被一维数组进行指向，一维数组通过地址指向堆中的另一个空间，这个空间中存放具体的值

二维数组动态初始化--列数不确定方式：在`Java`中允许二维数组中的一维数组的长度可以不相同

创建如下方式的二维数组：（一共有三个一维数组，每个一维数组的长度不一致）

![image-20250325101414605](..\images\image-20250325101414605.png)

```java
int[][] arr = new int [3][];  // 创建了二维数组，一共有3个一维数组，但是列数不确定
for(int i = 0; i < arr.length; i++) {   // 遍历arr每个一维数组
    // 给每个一维数组开辟空间，如果没有给一维数组new，那么arr[i]就是null
    arr[i] = new int[i + 1];
    
    // 遍历一维数组，并给一维数组的每个元素赋值
    for(int j = 0; j < arr[i].length; j++) {
        arr[i][j] = i + 1;   // 赋值
    }
}
```

输出10行的杨辉三角：

```java
int arr[][] = new int[10][];
for(int i = 0; i < arr.length; i++) {
    arr[i] = new int[i + 1];
    for(int j = 0; j < arr[i].length; j++) {
        if(j == 0 || j == arr[i].length - 1) {
            arr[i][j] = 1;
        }
        else {
            arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
        }
    }
}
```

注意事项：

- 对于二维数组的声明方式，有以下几种合法的方法：`int[][] arr`、`int[] arr[]`和`int arr[][]`
- 二维数组的本质是由多个一维数组构成的，它的各个一维数组的长度可以相同，也可以不相同



## 类与对象

单独使用定义变量的方式和数组的方式进行大量数据的管理，效率低下

在面向对象中，我们使用对象来体现各种各样的事物，对象中有两个关键的内容：属性（内在的特征，与自身关联，如年龄，名字等）和行为（行为方法。如修改名称等），将属性提取出来，就形成了一个类（类是一个数据类型）

类与对象的关系示意图：

![image-20250327104828374](..\images\image-20250327104828374.png)

> 将猫类的所有属性提取出来，形成一个猫类的数据类型（自己定义的数据类型，`int`是`Java`系统提供的数据类型），这个数据类型有以下常用的属性：`name`、`age`等，当然所有的猫都有行为，如：跑、叫和吃等
>
> 对于一个猫类，我们可以使用这个类定义许多的猫，这些猫就是对象（简而言之，我们可以通过猫类来创建猫对象，即创建一只具体的猫）

```java
// 定义一个猫类（自定义的数据类型）
class Cat {
    String name;
    int age;
    String color;
}

// 使用OOP面向对象解决
// 实例化一只猫对象
Cat cat1 = new Cat();
// 为对象添加属性
cat1.name = "小白";
cat1.age = 3;
cat1.color = "白色";
```

综上所述：类就是一个数据类型，对象就是一个具体的实例，从类到对象有几种说法：

- 创建了一个对象
- 实例化一个对象
- 把类实例化

***

### 对象的内存布局

`Java`内存的结构分析：

- 栈：一般存放基本数据类型（局部变量）
- 堆：存放对象（自定义类，数组等）
- 方法区：常量池（常量、比如字符串），类的加载信息（自定义的类信息只会加载一次）

对象在内存中的存在形式（重要）：

![image-20250327111603422](..\images\image-20250327111603422.png)

> 字符串是一个引用类型，在堆中存放的是地址，实际上将数据放在方法区中的常量池中，基础数据类型的值会直接存放到堆中
>
> 在执行实例化对象的时候，会将类的信息（属性信息和方法信息）加载到方法区中
>
> `Java`创建对象流程的简单分析：
>
> 1. 先加载`Cat`类信息（属性和方法信息，只会加载一次）
> 2. 在堆中分配空间，进行默认初始化（和数组初始化类似）
> 3. 把地址赋值给`cat`（创建的对象名），对象名就指向这个对象
> 4. 进行指定初始化，如`cat.age = 12;`

将实例化的对象赋值给另一个对象名，`Person p2 = p1;`   把`p1`赋值给了`p2`，或者说让`p2`指向`p1`，是引用类型，实现的是地址拷贝，指向的都是同一个堆中的对象，其内存分配过程如下：

![image-20250327131535351](..\images\image-20250327131535351.png)

小练习：

![image-20250327132602592](..\images\image-20250327132602592.png)

***

### 属性的概念

属性也叫成员变量，或者叫`field`字段，属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）

```java
public class Object {
    // main方法
    public static void main(String[] args) {
        // 实例化一个对象
        // cat1是对象名，new Cat()是真正的对象，在堆中创建了对象空间，将地址与对象名的指向地址联系起来
        Cat cat1 = new Cat();
        // 访问属性
        cat1.name;
    }
}

// 定义一个猫类（自定义的数据类型）
class Cat {
    // 定义属性/成员变量
    String name;
    int age;
    String color;
    String[] master;  // 属性可以是引用数据类型
}
```

注意事项：

- 属性的定义语法同变量的定义，但是多了一个访问修饰符的概念：`访问修饰符 属性类型 属性名;`

  访问修饰符是用于控制属性的范围，有四种访问修饰符：`public`、`proctected`、`默认情况`、`private`

- 属性的定义类型可以为任意类型，包含基本类型或引用类型

- 属性如果不赋值，有默认值，规则和数组一致

***

### 方法的概念

成员方法的定义：

```java
访问修饰符 返回的数据类型 方法名(形参列表..) {
    方法体语句;
    return 返回值;
}
```

> - 访问修饰符：控制方法的使用范围，常用的方法修饰符有四个
>
> - 形参列表：表示成员方法的输入
>
>   - 一个方法可以有0个参数，也可以有多个参数，中间使用逗号隔开
>   - 参数类型可以为任意类型，包含基本类型或引用类型，同一列表的参数类型可以是不同的类型
>   - 调用参数的方法时，一定对应着参数列表传入相同类型或兼容类型（可以进行自动转换）的参数
>   - 方法定义时的参数称为形式参数，简称行参；方法调用时传入的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致
>
> - 返回的数据类型：表示成员方法输出，`void`表示没有返回值，返回的类型可以为任意类型，包含基本类型和引用类型，但是接收返回值时，需要声明与返回值同类型的变量去接收
>
>   一个方法最多只有一个返回值，如果需要多个返回值，我们可以返回数组
>
>   ```java
>   // 返回两个数的和差
>   class Num {
>       public int[] getSumAndSub(int n1, int n2) {
>           int res[] = new int[2];
>           res[0] = n1 + n2;
>           res[1] = n1 - n2;
>           return res;
>       }
>   }
>   ```
>
> - 方法主体：表示为了实现某一功能代码块，可以为输入、输出、运算、分支、循环、方法调用，但是在方法主体中不能再定义方法，即：方法不能嵌套定义
>
> - `return`语句不是必须的，如果方法要求有返回数据类型，则方法体中最后的执行语句必须为`return`值，而且要求返回值类型必须和`return`的值类型一致或者兼容（可以自动转换的）
>
>   ```java
>   // 类型一样，编译通过
>   public double f1() {
>       return 1.1;
>   }
>                                   
>   // 兼容（可以自动转换），编译通过
>   public double f1() {
>       int n = 1;
>       return n;
>   }
>                                   
>   // 类型不一致，且不能自动转换，编译不通过
>   public int f1() {
>       return 1.1;
>   }
>   ```
>
>   如果方法是`void`，则方法中可以没有`return`语句，或者只写`return;`，但是不能返回具体的内容

成员方法简称为方法，用于声明一些具体的行为

```java
public class Object {
    // main方法
    public static void main(String[] args) {
        // 实例化一个对象
        Person person1 = new Person();
        // 调用方法
        person1.speak();
        person1.cal(6);
        int data = person1.getSum(3, 6);  // 将方法返回的值赋给data
    }
}

// 定义一个猫类（自定义的数据类型）
class Person {
    // 定义属性/成员变量
    String name;
    int age;
    // 定义方法/成员方法
    // public表示方法是公开的；void表示方法没有返回值；speak表示方法名
    public void speak() {
        System.out.println("我是一个好人");
    }
    // (int n)表示形参列表，表示当前有一个形参n，可以接收调用者的输入
    public void cal(int n) {
        int res = 0;
        for(int i; i <= n; i++) {
            res += i;
        }
        System.out.println("计算结果=" + res);
    }
    // 方法有返回值的形式
    // int表示方法执行后，返回一个int值
    public int getSum(int num1, int num2) {
        int res = num1 + num2;
        return res;
    }
}
```

方法调用机制的原理图：（重要）

![image-20250327135857719](..\images\image-20250327135857719.png)

首先会在栈中创建一个栈空间（`main`栈空间），当执行了方法时，会在开辟一个独立的栈空间（栈和栈之间不会相互影响），进行形参的赋值，执行完方法后，会将结果进行返回，当返回之后，这个临时开辟的独立栈空间就会被释放

成员方法的好处：减少代码冗余，提高了代码的复用性；同时可以将实现的细节封装起来，然后供其他用户来调用

方法调用细节：

- 同一个类中的方法调用：直接调用即可

  ```java
  class A {
      public void print(int n) {
          System.out.println("print()方法被调用 n=" + n);
      }
      
      public void sayOk() {
          // 调用同一个类中的print()方法
          print(10);
      }
  }
  ```

- 跨类中的方法A类调用B类的方法：需要通过对象名调用，跨类的方法调用共和方法访问修饰符相关

  ```java
  class A {
      public void print(int n) {
          System.out.println("print()方法被调用 n=" + n);
      }
  }
  
  class B {
      public void sayOk() {
          // 创建一个A类的对象
          A a = new A();
          // 调用a对象的方法
          a.print(10);
      }
  }
  ```

#### 方法的传参机制

方法的传参机制在编程中是非常重要的：

- 对于基本数据类型的传参机制，传递的是值（值拷贝），形参的任何改变不影响实参

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          int a = 10;
          int b = 20;
          // 实例化AA对象
          AA obj = new AA();
          obj.swap(a, b);
          System.out.prinln(a, b);    // 10 20
  	}
  }
  
  class AA {
      public void swap(int a, int b) {
          System.out.prinln(a, b);   // 10 20
          int temp = a;
          a = b;
          b = temp;
          System.out.prinln(a, b);   // 20 10
      }
  }
  ```

  通过内存来进行辅助理解：

  调用`obj.swap(a, b);`方法，传递的是10和20，`swap()`方法中接收的是10和20，两个栈是独立的空间，其基本数据类型的变量是不冲突的

- 对于引用数据类型的传参机制，传递的是地址（传递的也是值，但这个值是地址），形参的改变会影响实参

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          int[] arr = {1, 2, 3};
          BB obj = new BB();
          obj.test(arr);    // 200 2 3
          
          // 遍历数组
          for(int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + "\t");
          }
          System.out.println();    // 200 2 3
  	}
  }
  
  class BB {
      public void test(int arr) {
          arr[0] = 200;   // 修改了传递进来的数组元素
          // 遍历数组
          for(int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + "\t");
          }
          System.out.println();
      }
  }
  ```

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          Person p = new Person();
          p.name = "jlc";
          p.age = 25;
          BB b = new BB();
          b.test(p);
          System.out.println(p.age);   // 100
  	}
  }
  
  class Person {
      String name;
      int age;
  }
  
  class BB {
      public void test(Person p) {
          p.age = 100;
      }
  }
  ```

  小变化：

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          Person p = new Person();
          p.name = "jlc";
          p.age = 25;
          BB b = new BB();
          b.test(p);
          System.out.println(p.age);   // 10
  	}
  }
  
  class Person {
      String name;
      int age;
  }
  
  class BB {
      public void test(Person p) {
          p = null;
      }
  }
  ```

  `BB`类中的将传入的`p`对象设置为`null`，是切断了当前方法栈空间中的`P`指向的堆中的对象，但是不会影响原先`main`栈空间中`p`的指向，`p`还是指向堆中的对象，因此，其值还是25

  ![image-20250327211100538](..\images\image-20250327211100538.png)

#### 方法的递归调用

递归调用就是方法调用自己，每次调用时传入不同的变量，递归有助于解决复杂的问题，同时让代码更简洁

递归调用的本质仍然是方法的调用

递归使用规则：

- 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
- 一般传递的是基本类型数据，所以方法的局部变量是独立的，不会相互影响
- 如果方法中使用的是引用类型的变量，如数组，就会共享该引用类型的数据
- 递归必须向退出递归的条件逼近，否则就是无限递归
- 当一个方法执行完毕，或者遇到`return`，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕了，开辟的空间也会清除掉

![image-20250328131533079](..\images\image-20250328131533079.png)

每一次调用方法的递归，都会在栈空间中开辟一块方法空间，当方法执行完后，方法空间会消失，同时会返回到上一个调用空间，在哪里调用就返回给哪里，依次递归的返回，最后返回到`main`方法中，执行完后退出

##### 阶乘

```java
// 递归调用---阶乘
public int factorial(int n) {
    if(n == 1) {
        return 1;
    }
    else {
        return factorial(n - 1) * n;
    }
}
```

![image-20250328133518263](..\images\image-20250328133518263.png)

##### 斐波那契

斐波那契是指，一个数为前面两个数的和

```java
// 递归调用---斐波那契
public int fibonacci(int n) {
    if(n == 1 || n == 2) {
        return 1;
    }
    else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

#### 方法的重载

在`Java`中允许同一个类中有多个同名方法的存在，但要求形参列表不一致，方法重载有利于减轻了起名和记名的麻烦，如系统定义的`System.out.println()`方法，方法名都是`println()`，但是可以输出数值，字符串等，是由于使用了方法的重载，设置了同名的方法，但是传递的形参列表不一致

```java
class MyCalculator {
    // 计算两个整数的和
    public int calculate(int n1, int n2) {
        return n1 + n2;
    }
    // 计算一个整数，一个浮点数的和
    public double calculate(int n1, double n2) {
        return n1 + n2;
    }
}
```

方法重载的注意事项：

- 方法名必须相同
- 形参列表必须不同（形参类型或个数或顺序，至少有一个是不同的，参数名无要求）
- 返回类型无要求（返回类型不是构成方法重载的条件）

#### 可变参数

`Java`允许将同一个类中多个同名同功能但参数个数不同的方法，重载成一个方法，但是这样要不断的重复编写，对于这个问题，我们可以通过可变参数进行简化

可变参数的基本语法：

```java
访问修饰符 返回类型 方法名(数据类型... 形参名) {}

// 对传入的所有参数进行求和
// int...表示接收的是可变参数，类型为int类型，可以接收多个int类型的参数（0-n个）
public int sum(int... nums) {
    int res = 0;
    // 使用可变参数的时候，我们可以将其当作数值进行使用，即传入的nums可以当作数组
    for(int i = 0; i < nums.length; i++) {
        res += nums[i];
    }
    return res;
}
```

注意事项：

- 可变参数的实参可以为0个或者任意多个

- 可变参数的实参可以为数组

  ```java
  public class VarParameterDetail {
  	public static void main(String[] args) {
          int[] arr = {1, 2, 3};
          T t = new T();
          t.f1(arr);
  	}
  }
  
  class T {
      public void f1(int... nums) {
          System.out.println(nums.length);
      }
  }
  ```

- 可变参数的本质就是数组

- 可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后

- 一个形参列表中只能出现一个可变参数

***

### 克隆对象

克隆对象，要求新对象和原来对象是两个独立的对象，只是他们的属性和属性值完全相同

```java
public class MethodParameter {
	public static void main(String[] args) {
        Person p = new Person();
        p.name = "jlc";
        p.age = 25;
        MyTools myTools = new MyTools();
        Person p2 = myTools.copyPerson(p);
        // p和p2都是Person对象，但是是两个独立的对象，其属性和属性值相同
	}
}

class Person {
    String name;
    int age;
}

class MyTools {
    public Person copyPerson(Person p) {
        // 创建一个新对象
        Person p2 = new Person();
        p2.name = p.name;   // 将原来对象的名字赋值给p2.name
        p2.age = p.age;
        return p2;
    }
}
```

***

### 作用域

在面向对象编程中，变量的作用域是非常重要的知识点

在`Java`中，主要的变量就是属性（成员变量）和局部变量（在成员方法或者代码块中定义的变量）

- 全局变量：也就是属性，作用域为整个类体，全局变量可以不赋值，直接使用，因为有默认值
- 局部变量：除了属性之外的其他变量，作用域定义在它的代码块中，局部变量必须赋值后才能使用，因为它没有默认值

```java
class T {
    // 定义全局变量，作用域在整个T类中，可以在这个类的任意地方使用
    // 全局变量可以不进行赋值
    int age = 25;
    
    public void show() {
        // 定义局部变量，只能在当前的作用域中进行使用
        // 局部变量必须要进行赋值
        int n = 10;
        System.out.println(age);  // 在方法中使用全局变量
    }
}
```

注意事项：

- 属性和局部变量是可以重名的，访问时遵循就近原则
- 在同一个作用域中，比如同一个成员方法中，两个局部变量是不能重名的
- 属性（全局变量）生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁；局部变量的生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的销毁而销毁，即在一次方法调用过程中，通过内存空间进行理解

全局变量/属性可以被本类使用，也可以被其他类使用（通过对象调用）

```java
class T {
    // 属性
    int age = 25;
}

class D {
    // 在其他类中调用T类中的属性
    // 先定义一个T类的对象
    public void test() {
        T t = new T();
        System.out.println(t.age);
    }
}
```

局部变量只能在本类中对应的方法中使用

全局变量/属性可以加修饰符；但是局部变量不能加修饰符

***

### 构造器

构造器也叫构造方法，主要作用是完成对新对象的初始化，我们可以通过构造器，在创建对象的时候，直接指定这个对象的具体属性值（即在创建对象时，系统会自动调用该类的构造器，完成对象的初始化）

基本语法：

```java
修饰符 方法名(形参列表) {
    方法体;
}
```

> - 构造器的修饰符可以默认，也可以是`public`、`protected`和`private`
> - 构造器没有返回值，也不能写`void`
> - 构造器的方法名和类的名字必须一样
> - 参数列表和成员方法一样的规则
> - 构造器的调用由系统完成，即在`new`的时候，系统会自动完成构造器中的方法

```java
public class Constructor01 {
	public static void main(String[] args) {
		// 当我们new一个对象时，直接通过构造器指定属性值
        Person p = new Person("jlc", 25);
	}
}

class Person {
    String name;
    int age;
    // 构造器
    public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
    }
}
```

注意事项：

- 一个类可以定义多个不同的构造器，即构造器的重载，如我们可以再给`Person`类定义一个构造器，用来创建对象的时候，只指定姓名，不需要指定年龄，那么后续初始化对象的时候，年龄就是默认值
- 构造器是完成对象的初始化，并不是创建对象
- 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造方法），如`Person() {}`，可以通过反编译`javap Person.class`进行查看
- 一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显示的定义一个，即：`Person() {}`

#### 引入构造器后的对象创建流程

引入构造器后的对象创建流程是一个经典的面试题

![image-20250329134442728](..\images\image-20250329134442728.png)

> 1. 先在方法区中加载类信息
> 2. 在堆中开辟空间
> 3. 对属性进行默认初始化
> 4. 根据是否赋值，进行显式的初始化（如`age = 90;`）
> 5. 通过构造器进行属性初始化，引用类型的属性值在常量池中，通过地址进行指向，基本类型的数据直接在堆空间中修改
> 6. 最后将堆中的地址进行放回，供实例化的对象`p`进行指向（真正的对象在堆中，`p`只是对象的引用，只是一个对象名）

上述流程简而言之：

1. 加载`Person`类信息（`Person.class`），只会加载一次
2. 在堆中分配空间（地址）
3. 完成对象的初始化
   1. 默认初始化 `age = 0  name = null`
   2. 显式初始化 `age = 90`
   3. 构造器的初始化 `age = 20  name = “小倩”`
4. 对象在堆中的地址，返回给`p`（对象名，也可以理解为对象的引用）

***

### `this`关键字

构造器的输入参数名不是非常友好，如果能将`pName`改成`name`就好了，但是由于变量作用域的原因，`name`的值最后是`null`，这时我们就要引入`this`关键字来解决

```java
public class Constructor01 {
	public static void main(String[] args) {
		// 当我们new一个对象时，直接通过构造器指定属性值
        Person p = new Person("jlc", 25);
	}
}

class Person {
    String name;
    int age;
    // 构造器
    public Person(String name, int age) {
        // this.name表示当前对象的name属性   后面的name是局部变量，就近访问，找不到在访问属性
        this.name = name;   
        this.age = age;
    }
}
```

`java`虚拟机给每个对象分配了`this`，代表当前对象，比如，人是一个对象，这个人说我的，就表示`this`

![image-20250329141242726](..\images\image-20250329141242726.png)

在堆中开辟空间后，除了属性，还有一个隐藏的属性`this`，引用的地址是对象的地址，指向的是对象自己

总之，哪个对象调用，`this`就代表哪个对象

注意事项：

- `this`关键字可以用来访问本类的属性、方法和构造器

- `this`用于区分当前类的属性和局部变量

- 访问成员方法的语法：`this,方法名(参数列表);`

  ```java
  class T {
      public void f1() {
          System.out.println("f1方法");
      }
      public void f2() {
          System.out.println("f2方法");
          // 调用本类的f1()方法
          // 方式一：传统方法
          f1();
          // 方式二：使用this关键字
          this.f1();
      }
  }
  ```

- 访问构造器语法：`this(参数列表);`   只能在构造器中使用（即只能在构造器中访问另一个构造器）

  ```java
  class T {
      public T() {
          // 通过this关键字访问另一个构造器
          this("jlc", 25);
          System.out.println("T()构造器");
      }
      public T(String name, int age) {
          System.out.println("T(String name, int age)构造器");
      }
  }
  ```

  > 注意：访问构造器语法：`this(参数列表);`，必须放在第一条语句中

- `this`不能再类定义的外部使用，只能在类定义的方法中使用

  ```java
  class Person {
      String name = "jlc";
      int age = 25;
      public void f() {
          String name = "abc";
          System.out.println(name, age);   // abc, 25
          System.out.println(this.name, this.age);   // jlc, 25
      }
  }
  ```

  > `this.name`表示当前对象的`name`属性   后面的`name`是局部变量，就近访问，找不到在访问属性



## `API`

`Java`系统官方为我们提供了基本的编程接口（系统提供的类和相关方法）

我们可以去`Java API`文档中快速的查找需要的`API`：[Java 8 中文版 - 在线API手册 - 码工具](https://www.matools.com/api/java8)

### `Java`类的组织形式

![image-20250313203233056](..\images\image-20250313203233056.png)

我们查询文档的思路是：按照包去查找类，再去查找具体的方法，如果我们不知道这个类在哪个包的下面，我们可以直接进行搜索，找到这个类

***

### 包的概念

包的原理就是创建不同的文件夹\目录来保存类文件

![image-20250330195742103](..\images\image-20250330195742103.png)

对于相同名称的类，在不同文件夹下是允许的，文件夹就相当于对应一个包

包具有三个主要的作用：

- 区分相同名字的类，放在不同的包下
- 当类很多时，使用包可以很好的管理类
- 包可以访问范围

包的基本语法：

```java
package com.myabc;
```

> - `package`关键字，表示打包
> - `com.myabc`表示包名
>
> 注意事项：
>
> 1. `package`的作用是声明当前类所在的包，需要放在`class`类的最上面，一个类中最多只有一句`package`
> 2. 我们在导入包的时候，`import`命令的位置放在`package`的下面，在类定义前面，可以有多句且没有顺序的要求
>
> ```java
> package com.myabc;
> 
> import java.util.Scanner;
> 
> public class Dog {
>     public static void main(String[] args) {
>         Scanner myScanner = new Scanner(System.in);
>     }
> }
> ```

在不同的包下创建`Dog`类：

在`src`文件夹下建立两个新的文件夹，代表两个不同的包，新建文件夹分别为`com.abc`和`com.efg`

其中`com`表示第一级目录，`abc`和`efg`表示`com`目录下的两个下一级目录

在`abc`文件夹下创建一个`Java Class`类`Dog`，我们只能在`abc`文件夹下创建一个`Dog`类，但是我们可以在`efg`文件夹下创建同名字的类`Dog`

我们后续在其他文件中使用`Dog`类，就需要进行对具体包中的类进行引用，如：

```java
import com.abc.Dog;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
    }
}
```

如果引入不同包下名称相同的类，系统会在第二个类前面加上包名：

```java
import com.abc.Dog;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        com.efg.Dog dog1 = new com.efg.Dog();  // 不会直接引入了，引入会报错
    }
}
```

#### 包的命名

包的命名规则：只能包含数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字和保留字

```java
demo.class.exec1   // 不正确，class是关键字
demo.12a   // 不正确，12a不能以数字开头
demo.ab12.oa   // 正确
```

包的命名规范：一般是小写字母+小圆点，具体而言：`com.公司名.项目名.业务模块名`

如：`com.sina.crm.user`    用户模块

#### 常用的包

一个包下包含很多的类，`Java`中常用的包有：

- `java.lang.*`：`lang`包是基本包，默认引入，不需要额外进行引入
- `java.util.*`：`util`包，系统提供的工具包，工具类，使用`Scanner`
- `java.net.*`：网络包，网络开发
- `java.awt.*`：`Java GUI`界面开发时需要引用的包

#### 包的引入

我们引入一个包的主要目的是要使用该包下面的类，如`import java.util.Scanner;`，引入了`java.util.*`包下面的`Scanner`类

我们也可以将整个包下的所有类都进行引入\导入：`import java.util.*;`  （推荐需要什么再导入什么）



## 面向对象编程

面向对象编程有三大特征：封装、继承和多态

类的五大成员：(1) 属性 (2) 方法 (3) 构造器 (4) 代码块 (5) 内部类

### 访问修饰符

`Java`一共提供了四种访问控制修饰符，用于控制方法和属性（成员变量）的访问权限（范围）：

- `public`：公开级别，对外公开
- `protected`：受保护级别，对子类和同一个包中的类公开
- 默认级别：没有修饰符号，向同一个包类公开
- `private`：私有级别，只有类本身可以访问，不对外公开

![image-20250330204651506](..\images\image-20250330204651506.png)

注意事项：

- 修饰符可以用来修饰类中的属性，成员方法以及类
- 只有默认的和`public`修饰符才能修饰类，其他两个修饰符不能修饰类，并且遵循上述访问权限的特点
- 成员方法的访问规则和属性完全一样

对于类中的四个属性，分别使用不同的访问修饰符进行修饰：

```java
package com.jlctest.modifier;

public class A {
    public int  n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private int n4 = 400;
    
    // 本类的方法是可以访问到上述不同修饰符的属性
    public void m1() {
        System.out.println(n1, n2, n3, n4);
    }
}
```

在同包中创建一个B类：

```java
package com.jlctest.modifier;

public class B {
    A a = new A();    // 同一个包中，不需要对同包下的类进行引入
    // 在同一个包下，可以访问 public、protected和默认的属性或方法，但是不能访问私有的属性或方法
    System.out.println(a.n1, a.n2, a.n3);   // a.n4访问不到
}
```

在不同包中创建一个C类：

```java
package com.jlctest.modifier2;

public class B {
    A a = new A();    // 同一个包中，不需要对同包下的类进行引入
    // 在不同包下，只能访问 public修饰的属性或方法，不能访问protected、默认的和私有的属性或方法
    System.out.println(a.n1);   // a.n2   a.n3  a.n4访问不到
}
```

***

### 封装

封装就是把抽象出的数据（属性）和对数据操作的方法封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作。对电视机的封装操作就是典型的封装，开关等按键被暴露出来了

封装有以下的好处：

- 隐藏了实现细节，只需在调用时传递参数即可
- 可以对数据进行验证（对于一些非常不合理的数据进行验证处理，如`age = 1000;`，显然是不合理的），保证安全合理

#### 封装步骤

1. 将属性进行私有化`private`，在外部不能直接的修改属性

2. 提供一个公共（`public`）的`set`方法，用于属性判断并赋值

   ```java
   public void setXxx(类型 参数名) {  // xxx表示某个属性
       // 加入数据验证的业务逻辑
       属性 = 参数名;
   }
   ```

3. 提供一个公共（`public`）的`get`方法，用于获取属性的值

   ```java
   public XX getXxx() {   // xxx表示某个属性
       // 权限判断
       return xx;
   }
   ```

封装小案例：封装一个`Person`类，不能随便查看人的年龄，工资等隐私，并对设置的年龄进行合理的验证（1-120岁之间），年龄合理就设置，否则使用默认的年龄，工资不能直接查看，`name`的长度在2-6个字符之间，具体封装如下：

```java
package com.jlctest.encap;

public class Encapsulation01 {
    Person person = new Person();
    person.setName("jlc");
    person.setAge("25");
    person.setSalary(20000);
    // 不能通过person.salary进行访问当前对象的薪水，只能通过person.getSalary()进行薪水的访问
    // 读取信息
    System.out.println(person,info());
}

class Person {
    public String name;   // 名字公开
    private int age;     // 年龄私有化
    private double salary;  // 工资私有化
    
    // 给每个属性提供set和get方法，可以使用快捷键alt+insert，选择Getter and Setter
    // 之后根据要求来完善代码
    public void setName(String name) {
        // 对名字长度的校验
        if (name.length() >= 2 && name.length() <= 6) {
            this.name = name;
        }
        else {
            System.out.println("名字长度不合法");
            // 设置默认的名字
            this.name = "null";
        }
    }
    public String getName() {
        return name;
    }
    public void setAge(int age) {
        // 合理范围判断
        if (age >= 1 && age <= 120) {
            this.age = age;
        }
        else {
            System.out.println("年龄要在1-120之间");
            // 不符合范围设置给定的默认值
            this.age = 18;
        }
    }
    public int getAge() {
        return age;
    }
    public void setSalary(double salary) {
        this.salary = salary;
    }
    public double getSalary() {
        // 可以在这里增加对当前对象的权限判断
        return salary;
    }
    
    // 写一个方法，返回属性信息
    public String info() {
        return "信息为： name:" + name + "age:" + age + "salary:" + salary;
    } 
}
```

#### 封装结合构造器

使用构造器会导致封装的过滤校验机制失效，如果我们不希望校验方法失效，我们可以将`set`方法在构造器中进行调用，如：

```java
package com.jlctest.encap;

public class Encapsulation01 {
    Person person = new Person();
    person.setName("jlc");
    person.setAge("25");
    person.setSalary(20000);
    // 不能通过person.salary进行访问当前对象的薪水，只能通过person.getSalary()进行薪水的访问
    // 读取信息
    System.out.println(person,info());
    
    // 通过构造器初始化
    Person person1 = new Person("JLC", 125, 20000);
    System.out.println(person1,info());   // JLC 18 20000
}

class Person {
    public String name;   // 名字公开
    private int age;     // 年龄私有化
    private double salary;  // 工资私有化
    
    // 使用构造器
    public Person(String name, int age, double salery) {
        //// 下面方式会使验证失效
        //this.name = name;
        //this.age = age;
        //this.salary = salary;
        // 如果需要用到验证，需要调用set方法
        this.setName(name);
        this.setAge(age);
        this.setSalary(salary);
    }
    
    // 给每个属性提供set和get方法，可以使用快捷键alt+insert，选择Getter and Setter
    // 之后根据要求来完善代码
    public void setName(String name) {
        // 对名字长度的校验
        if (name.length() >= 2 && name.length() <= 6) {
            this.name = name;
        }
        else {
            System.out.println("名字长度不合法");
            // 设置默认的名字
            this.name = "null";
        }
    }
    public String getName() {
        return name;
    }
    public void setAge(int age) {
        // 合理范围判断
        if (age >= 1 && age <= 120) {
            this.age = age;
        }
        else {
            System.out.println("年龄要在1-120之间");
            // 不符合范围设置给定的默认值
            this.age = 18;
        }
    }
    public int getAge() {
        return age;
    }
    public void setSalary(double salary) {
        this.salary = salary;
    }
    public double getSalary() {
        // 可以在这里增加对当前对象的权限判断
        return salary;
    }
    
    // 写一个方法，返回属性信息
    public String info() {
        return "信息为： name:" + name + "age:" + age + "salary:" + salary;
    } 
}
```

***

### 继承

对于两个类的属性和方法，有很多是相同的，这个时候，我们就需要用到继承的概念，实现代码的复用性，同时代码的扩展性和维护性提高了

继承可以解决代码的复用，让我们的编程更加靠近人类的思维，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过`extends`来声明继承父类即可，继承的示意图如下：

![image-20250331150518850](..\images\image-20250331150518850.png)

> `B`类和`C`类中有很多属性和方法是相同的，我们将`B`类和`C`类中共有的属性写在`A`类中，供`B`类和`C`类进行继承，在`B`类和`C`类中只写该类特有的属性和方法，我们可以在写一个类`D`来继承`B`类，这样`D`类就同时拥有了`B`类和`A`类的所有方法

继承的基本语法：

```java
class 子类 extends 父类 {
    ...
}
```

> - 子类会自动拥有父类定义的属性和方法
> - 父类又叫超类或基类
> - 子类又叫派生类

代码描述：创建一个学生的父类，和小学生子类、大学生子类，父类文件代码：

```java
package com.jlctest.extend;

// 父类
public class Student {
    // 共有的属性
    public String name;
    public int age;
    private double score;
    
    // 共有的方法
    public void setScore(double score) {
        this.score = score;
    }
    public void showInfo() {
        System.out.println("学生名：" + name + "年龄：" + age + "成绩：" + score);
    }
}
```

创建子类进行继承父类和编写子类独特的属性和方法：

```java
package com.jlctest.extend;

// 小学生子类 Pupil继承Student父类
public class Pupil extends Student {
    public void testing() {
        System.out.println("小学生" + name + "正在考试...");
    }
}
```

```java
package com.jlctest.extend;

// 大学生子类 Graduate继承Student父类
public class Graduate extends Student {
    public void testing() {
        System.out.println("大学生" + name + "正在考试...");
    }
}
```

测试文件：

```java
package com.jlctest.extend;

public class Extends01 {
    public static void main(String[] args) {
        com.jlctest.extend.Pupil pupil = new Pupil();
        pupil.name = "abc";
        pupil.age = 12;
        pupil.testing();
        pupil.setScore(60);
        pupil.showInfo();
    }
}
```

注意事项：

- 子类继承了所有的属性和方法，但是私有属性不能在子类中直接访问（但是可以间接访问的），要通过父类提供的公共方法去访问

  代码解释：先创建一个父类`Base`：

  ```java
  package com.jlctest.extend;
  
  public class Base {
      public int n1 = 100;    // 公共属性
      protected int n2 = 200; // 受保护属性
      int n3 = 300;           // 默认属性
      private int n4 = 400;   // 私有属性
      
      // 无参构造器
      public Base() {
          System.out.println("Base...");
      }
      // 公共方法
      public void test100() {
          System.out.println("test100...");
      }
      // 受保护方法
      protected void test200() {
          System.out.println("test200...");
      }
      // 默认方法
      void test300() {
          System.out.println("test300...");
      }
      // 私有方法
      private void test400() {
          System.out.println("test400...");
      }
      
      // 父类提供一个公共的方法去返回私有的属性
      public int getN4() {
          return n4;
      }
      
      // 父类提供一个公共的方法去返回私有的方法
      public void callTest400() {
          test400();
      }
  }
  ```

  创建一个子类`Sub`继承父类`Base`：

  ```java
  package com.jlctest.extend;
  
  public class Sub extends Base {
      // 子类的构造器
      public Sub() {
          System.out.println("Sub...");
      }
      
      public void sayOk() {
          // 非私有的属性和方法可以在子类中直接访问
          System.out.println(n1, n2, n3);   // n4是私有属性，不能直接访问
          // 通过父类提供的公共方法去访问私有的属性
          System.out.println(getN4());
          
          test100();
          test200();
          test300();    // test400()是私有方法，不能直接访问
          // 通过父类提供的公共方法去访问私有的方法
          callTest400();
      }
  }
  ```

- 子类必须调用父类的构造器，完成父类的初始化

  在创建子类的时候，父类的无参构造器也会被调用，会先于子类的无参构造器调用（先完成对父类的初始化）

  在子类中有一个默认的被省略的语句`super();`，完整的子类构造器语句为：

  ```java
  package com.jlctest.extend;
  
  public class Sub extends Base {
      // 子类的构造器
      public Sub() {
          super();   // 默认调用父类的无参构造器
          System.out.println("Sub...");
      }
  }
  ```

- 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用`super`去指定父类的哪个构造器完成对父类的初始化工作，否则编译不会通过

  ```java
  package com.jlctest.extend;
  
  public class Base {
      public int n1 = 100;    // 公共属性
      protected int n2 = 200; // 受保护属性
      int n3 = 300;           // 默认属性
      private int n4 = 400;   // 私有属性
      
      // 有参构造器，覆盖了默认的无参构造器
      public Base(int n1) {
          System.out.println("Base(int n1)...");
      }
  }
  ```

  子类在调用的时候，需要指定父类中具体的构造器：

  ```java
  package com.jlctest.extend;
  
  public class Sub extends Base {
      // 子类的构造器
      public Sub() {
          super(150);    // 指定一个构造器合法的实例，显示的调用一下
          System.out.println("Sub...");
      }
  }
  ```

- 如果希望指定去调用父类的某个构造器，则显式的用`super()`调用一下，如果不写，则默认调用父类的无参构造器

- `super`在使用时，必须放在构造器第一行

- `super()`和`this()`都只能放在构造器第一行，因此这两个方法不能共存在一个构造器中

- `Java`所有的类都是`Object`类的子类，`Object`是所有类的基类

- 父类构造器的调用不限于直接调用上级的父类，可以一直往上追溯到`Object`类（顶级父类），但是注意`Object`的无参构造器是没有任何输出的

- 子类最多只能继承一个父类（指直接继承），即`Java`中是单继承机制的

  如果想要让`A`类继承`B`类和`C`类，我们可以让`A`类先继承`B`类，再让`B`类去继承`C`类

- 不能滥用继承，子类和父类之间必须满足`is-a`（是一个...）的逻辑关系

  `Person is a Music?`   人不是音乐，不合理，不应该是继承关系

练习题：

```java
public class ExtendsExercise01 {
    public static void main(String[] args) {
        B b = new B();   // 执行内容：a    b name   b
    }
}

class A {
    A() {
        System.out.println("a");
    }
    A(String name) {
        System.out.println("a name");
    }
}
class B extends A {
    B() {
        this("abc");    // 执行B(String name){}
        System.out.println("b");
    }
    B(String name) {
        // 默认为super();   // 执行A()
        System.out.println("b name");
    }
}
```

#### 继承的本质

继承的本质可以帮助我们理解，当子类继承父类时，创建子类对象时，内存中发生了什么（结论：当子类对象创建好后，内存中会建立查找关系）

```java
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();    // new一个Son时，内存到底发生了什么，内存的布局是怎么样的
        // 当我们使用实例出的子类去访问属性时，是根据什么规则呢？
        System.out.println(son.name);  // 大头儿子
        System.out.println(son.age);  // 45   子类没有，访问的父类的属性
        System.out.println(son.hobby);  // 旅游   子类父类都没有，继续往上找
    }
}

class GrandPa {
    String name = "大头爷爷";
    String hobby = "旅游";
}
class Father extends GrandPa {
    String name = "大头爸爸";
    int age = 45;
}
class Son extends Father {
    String name = "大头儿子";
}
```

![image-20250401133057334](..\images\image-20250401133057334.png)

> `new`一个`Son`类的时候，首先会加载类信息，在加载`Son`类信息的时候，会先加载顶层的父类信息，也就是`Object`类，之后依次加载`GrandPa`的类信息和`Father`的类信息，等父类的信息加载完后，最后才会加载`Son`的类信息
>
> 加载完类信息之后，会在堆中分配地址空间，首先会给爷爷类分配属性；再会开辟一个空间，为爸爸类分配属性，最后为子类自己开辟空间，分配属性

当我们使用实例出的子类去访问属性时，是根据什么规则呢？我们需要按照查找关系来返回数据，查找规则如下：

1. 首先看子类是否有目前要访问的属性，如果子类有这个属性，并且可以访问，则返回信息
2. 如果子类没有这个属性，就看父类有没有这个属性，如果父类有这个属性，并且可以访问，就返回信息
3. 如果父类没有这个属性，就继续往上找，直到`Object`类

如果父级中的一个属性是私有的，那么子类是不可以进行直接访问的（但是这个私有的属性在内存地址中还是存在的），只是我们需要通过公共的方法进行访问

另外，如果爸爸类中有一个`age`是私有的，爷爷类中也有一个`age`是公共的，那我们子类访问`age`属性会卡在爸爸类中（直接访问报错，即有一个堵住了，不会跳过这个继续往上查找），不会继续往爷爷类去查找（即使爷爷类中的`age`是私有的）

#### `super`关键字

`super`代表父类的引用，用于访问父类的属性、方法和构造器

- `super`可以访问父类的属性（访问方式：`super.属性名;`），但不能访问父类的私有属性
- `super`可以访问父类的方法（访问方式：`super.方法名(参数列表);`），但不能访问父类的私有方法
- `super`可以访问父类的构造器（访问方式：`super(参数列表);`），只能放在构造器的第一句

```java
package com.jlctest.super;

// 父类
public class A {
    // 四个属性
    public int n1 = 100;
    protected int n2 = 200;
    int n3 = 300;
    private n4 = 400;
    
    // 四个方法
    public void test100() {}
    protected void test200() {}
    void test300() {}
    private void test400() {}
}
```

```java
package com.jlctest.super;

// 子类
public class B extends A {
    public void h1() {
        System.out.println(super.n1, super.n2, super.n3);   // super.n4不能访问，报错
    }
    public void ok() {
        super.test100();
        super.test200();
        super.test300();
        // super.test400();不能访问，报错
    }
}
```

`super`关键字可以给编程带来便利：

- 调用父类的构造器的好处：分工明确，父类属性由父类初始化，子类的属性由子类初始化
- 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过`super`（`super`访问属性和方法时，是没有查找本类该属性和方法的过程，直接去父类中进行查找，这个和`this`和直接访问是有区别的）；如果没有重名，使用`super`、`this`和直接访问是一样效果的
- 对于父类中私有的属性和方法，访问会报错：`cannot access`；如果父类中都没有这个属性和方法，会提示属性或方法不存在
- `super`的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用`super`去访问爷爷类的成员，如果多个基类（上级类）中都有同名的成员，使用`super`访问遵循就近原则。当然也需要遵循访问权限的相关规则（如私有属性和方法是不能访问的）

##### `super`和`this`的比较

![image-20250401151555174](..\images\image-20250401151555174.png)

#### 方法重写

方法重写也叫方法覆盖，就是子类有一个方法和父类（这里的父类可以一直追溯到顶级父类）的某个方法的名称、返回类型、形参列表都一样，那么我们就说子类的这个方法覆盖了父类的方法

对于一个`Animal`父类中，有一个方法：

```java
package com.jlctest.override;

public class Animal {
    public void cry() {
        System.out.println("动物叫..");
    }
}
```

对于子类`Dog`中，也有`cry`这个方法：

```java
package com.jlctest.override;

public class Dog extends Animal {
    public void cry() {
        System.out.println("狗叫..");
    }
}
```

> 因为`Dog`是`Animal`的子类，`	Dog`的`cry`方法和`Animal`的`cry`方法的定义形式一样（名称、返回类型和形参列表），这时我们就说`Dog`的`cry`方法重写了`Animal`的`cry`方法

在一个测试文件中进行测试：

```java
package com.jlctest.override;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.cry();   // 狗叫..
    }
}
```

方法重写的注意事项：

- 子类的方法的形参列表，方法名称要和父类方法的形参列表，方法名称和返回类型完全一样，会出现方法的重写

- 在方法名称和形参列表一样的基础上，如果父类方法的返回类型是子类方法返回类型的父类，也会构成方法的重写（如：父类方法返回的类型是`Object`，子类方法返回的类型是`String`）`String`类型的本质就是`Object`，如果子类方法返回的类型是`Object`，父类方法返回的类型是`String`，系统会直接报错

- 对于方法的重写，子类方法不能缩小父类方法的访问权限（可以扩大，但是不能缩小）

  对于访问修饰符的权限，由大到小依次为：`public`>`protected`>默认>`private`

  如果父类的方法是`public`，那么子类的方法必须为`public`，否则报错

  如果父类的方法是`protected`，那么子类的方法可以为`protected`和`public`

- 对于重写后的方法，如果我们想要重新使用子类的方法，我们可以使用`super.父类方法()`的形式调用

方法重写和方法重载的比较：

![image-20250402151355754](..\images\image-20250402151355754.png)

***

### 多态

多态，通俗来讲就说多种状态，是面向对象的第三大特征，多态是建立在封装和继承的基础上的

多态可以提高我们代码的复用性，从而利于维护

#### 方法的多态

重写和重载就体现了方法的多态

```java
package com.jlctest.Ploy;

public class Ploy {
    public static void main(String[] args) {
        B b = new B();
        A a = new A();
        // 方法的重载体现多态：这里我们传入不同的参数，就会调用不同的sum方法，就体现多态
        System.out.println(a.sum(10, 20));   // 30
        System.out.println(a.sum(10, 20, 30));  // 60
        // 方法重写体现多态：
        a.say();   // A say
        b.say();   // B say
    }
}

// 父类
class B {
    public void say() {
        System.out.println("B say");
    }
}

// 子类
class A extends B {
    public int sum(int n1, int n2) {
        return n1 + n2;
    }
    public int sum(int n1, int n2, int n3) {
        return n1 + n2 + n3;
    }
    
    public void say() {
        System.out.println("A say");
    }
}
```

#### 对象的多态

对象多态的前提是两个对象（类）存在继承关系

对象的多态是多态的核心：

- 一个对象的编译类型和运行类型可以不一致（可以使用父类的引用指向子类的对象）
- 编译类型在定义对象时，就确定了，不能改变
- 运行类型是可以变化的
- 编译类型看定义时等号的左边，运行类型看等号的右边

```java
// Dog类是Animal类的子类
// 可以使用父类的引用指向子类的对象
Animal animal = new Dog();

animal = new Cat();   // animal的运行类型变成了Cat，但是编译类型仍然是Animal
```

> 其中`animal`的编译类型是`Animal`，运行类型是`Dog`

```java
// animal的编译类型是Animal，运行类型是Dog
Animal animal = new Dog();
animal,cry(); // 因为运行时，执行到该行时，animal的运行类型是Dog，所以这里的cry方法，就是Dog类中的方法

// 将animal的运行类型改为Cat，但是编译类型还是为Animal
animal = new Cat();
animal.cry();   // 运行类型为Cat，执行的是Cat类中的cry方法
```

> 运行类型可以理解为真实的当前类型

##### 多态的向上转型

- 本质：父类的引用指向了子类的对象

- 语法：`父类类型 引用名 = new 子类类型();`

- 特点：编译类型看左边，运行类型看右边

  可以调用父类中的所有成员（需遵循访问权限）

  不能调用子类中特有成员

  最终运行的效果看子类的具体实现

  ```java
  Animal animal = new Cat();     // 父类的引用指向了子类的对象
  // 实例出的animal的类型完全是由编译器决定的，遵循的是引用类型Animal
  animal.*;     // 可以调用父类中的所有成员方法（属性和方法）（需遵循访问权限，私有的成员不能访问）
  // 但是不能调用子类中特有的成员（即子类有父类没有的成员）
  animal.catchMouse();  // 报错catchMouse()是Cat类特有的方法
  
  // 最终运行的效果看子类的具体实现，调用方法时，按照从子类开始进行查找，子类没有才往父类进行查找
  animal.eat();    // 根据运行类型，调用Cat类中的eat()方法（如果子类中有这个方法的情况下）    
  animal.run();  // 如果子类中没有run()这个方法，才会去父类中进行找
  ```

  > 在编译阶段，能调用哪些成员（属性和方法），是由编译类型决定的
  >
  > 但是在最终运行的时候，还是要看子类实现具体的效果

##### 多态的向下转型

- 语法：`子类类型 引用名 = (子类类型) 父类引用;`（将一个父类的引用强制转换为一个子类的引用，使其可以调用子类中的特有方法）
- 只能强转父类的引用，不能强转父类的对象
- 要求父类的引用必须指向的是当前目标类型的对象
- 当向下转型后，就可以调用子类类型中的所有成员

```java
Animal animal = new Cat();     // 父类的引用指向了子类的对象
animal.catchMouse();  // 报错catchMouse()是Cat类特有的方法（我们使用向下转型来解决）
// 向下转型，强转，将父类的引用重写转换为子类的引用
Cat cat = (Cat) animal;    // 这个时候cat的编译类型和运行类型都是Cat
// 要求父类的引用必须指向的是当前目标类型的对象，也就是说animal原先的指向类型就是Cat类
// 转换完后，就可以调用子类的特有方法
cat.catchMouse();
```

```java
Animal animal = new Cat();     // 父类的引用指向了子类的对象
// 要求父类的引用必须指向的是当前目标类型的对象，也就是说animal原先的指向类型就是Cat类
Cat cat = (Cat) animal;  

Dog dag = (Dog) animal;  // 报错，没有满足父类的引用必须指向的是当前目标类型的对象
```

##### 属性没有重写

属性没有重写，属性的值看其编译类型

```java
package com.jlctest.poly;

public class PloyDetail {
    public static void main(String[] args) {
        Base base = new Sub();   // 向上转型
        System.out.println(base.count);  // 10   看编译类型，编译类型为Base
        
        Sub sub = new Sub();
        System.out.println(base.count);  // 20   看编译类型，编译类型为Sub
    }
}

// 父类
class Base {
    int count = 10;   // 父类的count属性设置为10
}
// 子类
class Sub extends Base {
    int count = 20;   // 子类的count属性设置为20
}
```

##### `instanceOf`比较操作符

`instanceOf`比较操作符，用于判断对象的运行类型是否为`XX`类型或者`XX`类型的子类型

```java
package com.jlctest.poly;

public class PloyDetail {
    public static void main(String[] args) {
        // 运行类型和编译类型都为BB
        BB bb = new BB();
        System.out.println(bb instanceOf BB);   // true
        System.out.println(bb instanceOf AA);   // true
        
        // 运行类型为BB   编译类型为AA
        AA aa = new BB();
        System.out.println(aa instanceOf AA);   // true
        System.out.println(aa instanceOf BB);   // true
        
        Object obj = new Object();
        System.out.println(obj instanceOf AA);   // false
    }
}

// 父类
class AA {}
// 子类
class BB extends AA {}
```

***

#### 动态绑定机制

`Java`的动态绑定机制是非常重要的

1. 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
2. 当调用对象属性时，没有动态绑定机制，哪里声明，哪里调用（在当前的类中查找）

```java
package com.jlctest.dynamicBinding;

public class DynamicBinding {
    public static void main(String[] args) {
        A a = new B();  // 向上转型
        // 调用的对象方法看运行类型
        System.out.println(a.sum());  // 40
        System.out.println(a.sum1());  // 30
        
        // 如果将子类B中的sum方法注释掉
        // 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定，getI()还是从运行类型开始查找
        System.out.println(a.sum());  // 20 + 10 = 30
        // 如果将子类B中的sum1方法注释掉
        // 当调用对象属性时，没有动态绑定机制，哪里声明，哪里调用（在当前的类中查找）
        System.out.println(a.sum1());  // 10 + 10 = 20
    }
}

// 父类
class A {
    pubilc int i = 10;
    public int sum() {
        return getI() + 10;
    }
    public int sum1() {
        return i + 10;
    }
    public int getI() {
        return i;
    }
}
// 子类
class B extends A {
    public int i = 20;
    public int sum() {
        return i + 20;
    }
    public int getI() {
        return i;
    }
    public int sum1() {
        return i + 10;
    }
}
```

#### 多态的应用

##### 多态数组

多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

创建一个`Person`对象，两个`Student`对象和两个`Teacher`对象，统一放在多态数组中，并调用每个对象的`say`方法

![image-20250404194901877](..\images\image-20250404194901877.png)

创建`Person`父类：

```java
package com.jlctest.ploy;

public class Person {
    private String name;
    private int age;
    
    // 定义构造器
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    // 属性的设置和获取方法
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public int getAge() {
        return age;
    }
    
    // 自定义say方法，返回名字和年龄
    public String say() {
        return name + "\t" + age;
    }
}
```

创建`Student`子类：

```java
package com.jlctest.ploy;

public class Student extends Person {
    private double score;
    
    // 定义构造器
    public Person(String name, int age, double score) {
        super(name, age);
        this.score = score;
    }
    // 属性的设置和获取方法
    public void setScore(double score) {
        this.score = score;
    }
    public String getScore() {
        return score;
    }
    
    // 重写父类的say方法，返回名字和年龄还有分数
    public String say() {
        return super.say() + "score" + score;
    }
    
    // 学生类中特有的方法
    public void study() {
        System.out.println("学生" + getName() + "正在听课");
    }
}
```

创建`Teacher`子类：

```java
package com.jlctest.ploy;

public class Teacher extends Person {
    private double salary;
    
    // 定义构造器
    public Person(String name, int age, double salary) {
        super(name, age);
        this.salary = salary;
    }
    // 属性的设置和获取方法
    public void setSalary(double salary) {
        this.salary = salary;
    }
    public String getSalary() {
        return salary;
    }
    
    // 重写父类的say方法，返回名字和年龄还有分数
    public String say() {
        return super.say() + "salary" + salary;
    }
    
    // 老师类中特有的方法
    public void teach() {
        System.out.println("老师" + getName() + "正在授课");
    }
}
```

使用多态数组进行声明和方法的调用：

```java
package com.jlctest.ploy;

public static void main(String[] args) {
    // 创建一个Person对象，两个Student对象和两个Teacher对象，统一放在多态数组中
    // Person[]类型的多态数组，其元素子要是Person类和其子类都可以进行存放
    Person[] persons = new Person[5];
    persons[0] = new Person("jack", 20);
    persons[1] = new Student("mary", 18, 80);
    persons[2] = new Student("frank", 19, 100);
    persons[3] = new Teacher("scoot", 35, 18000);
    persons[4] = new Teacher("king", 55, 22000);
    
    // 循环遍历多态数组，调用say方法
    for (int i = 0; i < persons.length; i++) {
        // 使用了动态绑定机制，编译类型是Person，运行类型会根据实际变化
        System.out.println(person[i].say());  
        
        // 这里的persons[] 元素的编译类型是Person，是没有办法调用老师类或者学生类中的特有方法的
        // persons[i].teach();   // 报错
        // 我们要使用向下转型，将编译类型转成具体的子类，再去调用具体的方法
        if (persons[i] instanceof Student) {   // 先判断运行类型是不是Student类型
            Student student = (Student)persons[i];
            student.study();
            // 上述两条语句可以合二为一：  (Student)persons[i].study();
        } else if(persons[i] instanceof Teacher) {
            Teacher teacher = (Teacher)persons[i];
            teacher.teach();
        } else if(persons[i] instanceof Person) {
            // 不做任何处理
        } else {
            System.out.println("类型有误");
        }
    }
}
```

##### 多态参数

多态参数是指方法定义的形参类型为父类类型，实参类型允许为子类类型

定义员工类`Employee`，包含姓名和月工资`[private]`，以及计算年工资`getAnnual`的方法。普通员工和经理继承了员工，经理类多了奖金`bonus`属性和管理`manage`方法，普通员工类多了`work`方法，普通员工类和经理类要求分别重写`getAnnual`方法：

创建`Employee`父类：

```java
package com.jlctest.ploy;

public class Employee {
    private String name;
    private double salary;
    
    // 定义构造器
    public Person(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }
    // 属性的设置和获取方法
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setSalary(double salary) {
        this.salary = salary;
    }
    public double getSalary() {
        return salary;
    }
    
    // 自定义年工资方法
    public double getAnnual() {
        return 12 * salary;
    }
}
```

创建一个普通员工`Worker`子类：

```java
package com.jlctest.ploy;

public class Worker extends Employee {
    // 定义构造器
    public Person(String name, double salary) {
        super(name, salary);
    }
    // 普通员工类中特有的work方法
    public void work() {
        System.out.println("普通员工" + getName() + "正在工作");
    }
    
    // 重写getAnnual方法
    public double getAnnual() {
        // 因为普通员工没有其他收入，直接调用父类的方法即可
        return super.getAnnual();
    }
}
```

创建一个经理`Manager`子类：

```java
package com.jlctest.ploy;

public class Manager extends Employee {
    private double bonus;
    
    // 定义构造器
    public Person(String name, double salary, double bonus) {
        super(name, salary);
        this.bonus = bonus;
    }
    
    public String getBonus() {
        return bonus;
    }
    public void setBonus(double bonus) {
        this.bonus = bonus;
    }
    
    // 经理类中特有的manage方法
    public void manage() {
        System.out.println("经理" + getName() + "正在管理");
    }
    
    // 重写getAnnual方法
    public double getAnnual() {
        return super.getAnnual() + bonus;
    }
}
```

在测试类中添加一个方法`showEmpAnnual(Employee e)`，实现获取任何员工对象的年工资，并在`main`方法中调用该方法`[e.getAnnual]`

在测试类中添加一个方法`testWork`，如果是普通员工，则调用`work`方法，如果是经理，则调用`manage`方法

```java
package com.jlctest.ploy;

public class PloyParameter {
    public static void main(String[] args) {
        Worker tom = new Worker("tom", 2000);
        Manager milan = new Manager("milan", 5000, 10000);
        PloyParameter ployParameter = new PloyParameter();
        ployParameter.showEmpAnnual(tom);   // 30000
        ployParameter.showEmpAnnual(milan);   // 70000
        
        ployParameter.testWork(tom);  // 普通员工tom正在工作
        ployParameter.testWork(milan);  // 经理milan正在管理
    }
    
    // 获取任何员工对象的年工资的方法
    public void showEmpAnnual(Employee e) {
        System.out.println(e.getAnnual());  // 使用了动态绑定机制
    }
    
    // 添加一个方法testWork，如果是普通员工，则调用work方法，如果是经理，则调用manage方法
    public void testWork(Employee e) {
        if (e instanceof Worker) {
            ((Worker) e).work();    // 向下转型
        } else if (e instanceof Manager) {
            ((Manager) e).manage();
        }
    }
}
```

***

### `Object`根类

`Object`是类层次结构的根类，每个类都使用`Object`类作为超类，所有对象（包括数组）都可以使用`Object`类的方法，`Object`类中常用的方法有：

|     方法     |                             描述                             |
| :----------: | :----------------------------------------------------------: |
|  `clone()`   |                  创建并返回此对象的一个副本                  |
|  `equals()`  |              指示其他某个对象是否与此对象"相等"              |
| `finalize()` | 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法 |
| `getClass()` |                   返回此`Object`的运行时类                   |
| `hashCode()` |                     返回该对象的哈希码值                     |
| `toString()` |                    返回该对象的字符串表示                    |

#### `equals`方法

常见面试题：

`==`（比较运算符）和`equals`的对比：

- `==`既可以判断基本类型，又可以判断引用类型

  - `==`如果判断基本类型，判断的是值是否相等（是判断值相等，而不深入到类型）

    ```java
    int num1 = 10;
    double num2 = 10.0;
    System.out.println(num1 == num2);   // ture
    ```

  - `==`如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象

    ```java
    A a = new A();
    A b = a;
    A c = b;
    System.out.println(a == c); // true
    ```

- `equals`方法是`Object`类中的方法，只能判断引用类型

  默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，比如`Integer`、`String`中都会将`equals`方法进行重写（加入了比较具体的值是否相等）

  ```java
  // Object中的equals方法，默认就是比较对象地址是否相同，即也就是判断两个对象是不是同一个对象
  public boolean equals(Object obj) {
      // 如果是同一个对象，就返回true
      return (this == obj);
  }
  
  // Integer中的equals方法
  public boolean equals(Object obj) {
      if (obj instanceof Integer) {
          return value == ((Integer)obj).intValue();
      }
      return false;
  }
  ```

  ```java
  Integer integer1 = new Integer(1000);
  Integer integer2 = new Integer(1000);
  System.out.println(integer1 == integer2);  // false   开辟了不同的地址空间
  System.out.println(integer1.equals(integer2));  // true   判断具体的值是否相等 
  ```

  如何查看`jdk`原码：

  - 一般来说`IDEA`配置好`JDK`以后，`jdk`的源码也就自动配置好了，如果没有，可以点击菜单`File`-->`Project Structure`-->`SDKs`-->`Sourcepath`，然后点击右侧绿色的加号，选中我们下载的`jdk`子目录下的`javafx-src.zip`文件和`src.zip`文件
  - 在查看某个方法的源码时，将光标放在该方法上，输入`ctrl+b`或者在该方法上点击右键-->`go to`-->`Declaration or Usages`即可跳转到该方法的源码

##### 如何重写`equals`方法

案例：判断两个`Person`对象的内容是否相等，如果两个`Person`对象的各个属性值都一样，则返回`true`，反之，返回`false`

```java
package com.jlctest.object;

public class EqualsExercise {
    public static void main(String[] args) {
        Person person1 = new Person("jack", 10, '男');
        Person person2 = new Person("jack", 10, '男');
        
        System.out.println(person1.equals(person2));  // false   继承的是Object中的equals
        // 有了自定义的equals方法
        System.out.println(person1.equals(person2));  // ture
    }
}

class Person {
    private String name;
    private int age;
    private char gender;
    
    // 创建构造器
    public Person(String name, int age, char gender) {
        this.name = name;
        this,age = age;
        this.gender = gender;
    }
    
    // 重写Object的equals方法
    public boolean equals(Object obj) {
        // 判断如果比较的两个对象是同一个对象，则直接返回true
        if (this == obj) {
            return true;
        }
        // 类型判断，是Person，再进行比较
        if (obj instanceof Person) {
            // 进行向下转型，获取具体的属性
            Person p = (Person)obj;
            // 判断全部属性是否相等
            return this.name.equals(p.name) && this.age==p.age && this.gender==p.gender;
        }
        // 如果不是Person对象，则直接返回false
        return false;
    }
}
```

#### `hashCode`方法

`hashCode`方法用于返回该对象的哈希码值（哈希码值是为了提高哈希表的性能）

该方法主要有以下几个方面：

- 提高具有哈希结构的容器的效率
- 两个引用，如果指向的是同一个对象，则哈希值是一样的
- 两个引用，如果指向的是不同的对象，则哈希值是不一样的
- 哈希值主要根据地址号来计算的，但是不能完全将哈希值等价于地址
- 在后续的集合中，一般会将`hashCode`方法进行重写

```java
package com.jlctest.object;

public class HashCode {
    public static void main(String[] args) {
        AA aa1 = new AA();
        AA aa2 = new AA();
        AA aa3 = aa1;
        // 此时  aa1.hashCode和aa2.hashCode的值是不一样的，但是与aa3.hashCode的值是一样的
    }
}

class AA {}
```

#### `toString`方法

返回该对象的字符串表示，具体而言，就是返回一个以文本方式表示的此对象字符串

默认返回：全类名（包名+类名）+@+哈希值的十六进制

方法的源码：

```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

在子类中往往重写`toString`方法，用于返回对象的属性信息

当直接输出一个对象时，`toString`方法会被默认的调用，如`System.out.print(monster);`等价于`System.out.print(monster.toString());`

#### `finalize`方法

- 当对象被回收时（在堆中的空间被释放出来了），系统自动调用该对象的`finalize`方法，子类可以重写该方法，做一些释放资源的操作
- 什么时候被回收：当某个对象没有任何引用时，则`jvm`就认为这个对象使一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁对象之前，会先调用`finalize`方法
- 垃圾回收机制的调用，是由系统来决定的（即有自己的`GC`算法），也可以通过`System.gc()`主动触发垃圾回收机制

```java
package com.jlctest.object;

public class Finalize {
    public static void main(String[] args) {
        Car bmw = new Car("宝马");
        // 将对象的指向连线断掉，即对象没有任何引用了，这个Car对象就变成了垃圾，被回收
        // 在回收前（销毁前），会调用该对象的finalize方法
        // 这时程序员就可以在finalize方法中写一些自己业务逻辑的方法（如释放资源：数据库连接或者打开文件）
        // 如果程序员不重写finalize，那么就会调用Object类的finalize，即默认调用
        bwm = null;
        System.gc();  // 主动触发垃圾回收
        System.out.println("程序退出了")
    }
}

class Car {
    private String name;
    publuc Car(String name) {
        this.name = name;
    }
    // 重写finalize方法
    @Override
    protected void finalize() throws Throwable {
        System.out.println("我们销毁了汽车" + name);
    }
}
```

> 最后结果显示：程序退出了     我们销毁了汽车宝马

`finalize`方法在实际的开发中使用的比较少，但是在面试中问的比较多

***

### 类变量和类方法

类变量和类方法是面向对象的一个重点，类变量和类方法，又叫静态变量和静态方法，用`static`关键字进行修饰

#### 类变量

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量

定义类变量：

- `访问修饰符 static 数据类型 变量名;`     推荐使用
- `static 访问修饰符 数据类型 变量名;`

```java
class Child {
    private String name;
    // 定义一个类变量为所有的Child类的对象共享
    public static int totalNum = 0;
}
```

类变量的访问：静态变量的访问修饰符的访问权限和范围和普通属性是一样的

- `类名.类变量名;`    推荐使用
- `对象名.类变量名;`

类变量可以通过对象进行访问，也可以通过类名进行访问`Child.totalNum;`

```java
package com.jlctest.static;

public class VisitStatic {
    public static void main(String[] args) {
        // 类变量是随着类的加载而创建的，所以即使没有创建对象实例也可以访问
        System.out.println(A.name);   // jlc
        
        // 也可以通过一个对象实例进行访问
        A a = new A();
        System.out.println(a.name);   // jlc
    }
}

class A {
    // 定义类变量
    public static String name = "jlc";
}
```

类变量的使用细节：

- 当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）
- 加上`static`就称为类变量\静态变量，否则就为实例变量\普通变量\非静态变量
- 类变量是该类的所有对象共享的，而实例变量（普通属性）是对每个对象独享的
- 实例变量不能通过类名.变量名的方式访问
- 类变量是随着类的加载而创建的，所以即使没有创建对象实例也可以访问
- 类变量的生命周期是随着类的加载开始，随着类的消亡而销毁

##### 内存布局

![image-20250405191010103](..\images\image-20250405191010103.png)

> - 类变量`count`是被该类实例化出来的对象共享的（静态变量是被对象共享的）都指向静态变量所在的空间（堆空间）
> - `jdk`的版本如果大于等于8，静态对象是放在堆中的，通过反射机制会加载一个`Class`对象（在方法区中类加载之后，会通过反射机制生成一个`Class`对象实例），在对象实例的最后，会将这个静态数据放入；`jdk`的版本如果小于8，静态对象放在方法区中的，静态变量在加载的时候，有一个类加载，类信息会放在方法区中，就会在方法区中产生一个静态域来存放这个类变量，但是不管静态变量在哪里，都是可以被对象共享的
> - 类变量，在类加载的时候就生成了

#### 类方法

类方法也叫静态方法

基本语法：

- `访问修饰符 static 数据返回类型 方法名() {}`     推荐使用
- `static 访问修饰符 数据返回类型 方法名() {}`

类方法的调用：`类名.类方法名`或者`对象名.类方法名`   调用的前提是满足访问修饰符的访问权限和范围

```java
package com.jlctest.static;

public class StaticMethod {
    public static void main(Stringp[] args) {
        // 创建两个学生对象，交学费
        Stu tom = new Stu("tom");
        tom.payFee(1000);    // 通过对象来调用静态方法，也可以使用类名进行调用
        
        Stu mary = new Stu("mary");
        mary.payFee(2000);    // 通过对象来调用静态方法，也可以使用类名进行调用
        
        // 输出当前收到的总学费，通过类进行调用静态方法
        Stu.showFee();    // 总学费为：3000.0
    }
}

class Stu {
    private String name;  // 普通私有成员
    // 定义一个静态变量，来累积学生的学费
    private static double fee = 0;
    
    public Stu(String name) {
        this.name = name;
    }
    
    // 创建静态方法    静态方法可以访问静态属性/变量
    public static void payFee(double fee) {
        Stu.fee += fee;   // 学费累积
    }
    public static void showFee() {
        System.out.println("总学费为：" + Stu.fee);
    }
}
```

类方法的使用场景：当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率，如工具类中的方法`utils`、`Math`类、`Arrays`类等，如`Math.sqrt()`，其中的`sqrt()`就是一个静态方法，我们可以直接通过类进行调用（如果我们希望不创建实例，也可以调用某个方法，即当作工具来使用，这时将方法做成静态方法是非常合适的）

在程序员实际开发中，往往会将一些通用的方法，设计成静态方法，这样我们就可以不需要创建对象就直接使用

类方法使用的注意事项：

- 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无`this`参数，普通方法隐含着`this`参数

- 类方法可以通过类名调用，也可以通过对象名调用

- 普通方法和对象有关，需要通过对象名调用，不能通过类名调用

- 类方法中不允许使用和对象有关的关键字，比如`this`和`super`，普通方法（成员方法）可以

- 类方法中只能访问静态成员；普通成员方法既可以访问普通成员，也可以访问静态成员（构造器方法也属于普通方法，可以方法普通成员和静态成员）（但是两种方法访问都必须遵守访问权限）

  ```java
  class D {
      private int n1 = 100;   // 普通变量
      private static int n2 = 200;  // 静态变量
      
      public static void hello() {
          System.out.println(n2);  // 合法
          System.out.println(D.n2);  // 合法
          System.out.println(this.n2);  // 不合法，类方法中不允许使用和对象有关的关键字
          System.out.println(n1);  // 不合法，不能访问普通变量（方法）
      }
  }
  ```

***

### `main`方法

`main`方法的语法形式：`public static void main(String[] args) {}`

- `main()`方法是`Java`虚拟机在调用

- `Java`虚拟机需要调用类的`main()`方法，所以该方法的访问权限必须是`public`

- `Java`虚拟机在执行`main()`方法时不必创建对象，所以该方法必须是`static`

- 该方法接收`String`类型的数组参数，该数组中保存执行`Java`命令时传递给所运行的类的参数

- `Java`执行的程序 参数1 参数2 参数3

  ![image-20250408105300053](..\images\image-20250408105300053.png)

  ```java
  public class Hello {
      public static void main(String[] args) {
          // 遍历args接收传入的参数
          for(int i = 0; i < args.length; i++) {
              System.out.println("第" + (i + 1) + "个参数为" + args[i]);
          }
      }
  }
  ```

  编译代码：`javac Hello.java`

  运行代码并传入参数：`java Hello jlc abc qwer`    （如果不传入参数，就什么也不会输出）

  结果显示：

  第1个参数为`jlc`

  第2个参数为`abc`

  第3个参数为`qwer`

  参数在执行程序的时候进行传入，在传入参数后，会将`jlc abc qwer`这三个参数当作一个字符串数组`String[]`传给我们的方法

注意事项：

- 在`main()`方法中，我们可以直接调用`main`方法所在类的静态方法或静态属性，但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态方法

***

### 代码块

代码块又称为初始化块，属于类中的成员（即是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过`{}`包围起来；但是和方法不同，代码块没有方法名，没有返回，没有参数，只有方法体（代码块可以理解为只有方法体的方法），而且不用通过对象或类显示调用，而是在加载类时，或创建对象时隐式调用

基本语法：

```java
修饰符 {
    代码;
};
```

> - 修饰符可选，要写的化，也只能写`static`
> - 代码块分为两类，使用`static`修饰的静态代码块，和没有`static`修饰的普通代码块
> - 代码块中的语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
> - 结尾的`;`可以省略

使用代码块的好处：代码块相当于另一种形式的构造器（对构造器的补充机制），可以做初始化的操作

应用场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性

```java
public class CodeBlock {
    public static void main(String[] args) {
        Movie movie1 = new Movie("movie1");  
    }
}

class Movie {
    private String name;
    private double price;
    
    // 2个构造器，构成了重载
    // 两个构造器中存在相同的内容，这样代码看起来比较冗余，我们可以将相同的语句，放到一个代码块中
    {
        System.out.println("电影屏幕打开...");
        System.out.println("电影开始...");
    };
    // 不管我们调用哪个构造器，创建对象，都会调用代码块中的内容
    public Movie(String name) {
        System.out.println("Movie(String name)构造器被调用");
        this.name = name;
    }
    public Movie(String name, double price) {
        System.out.println("Movie(String name, double price)构造器被调用");
        this.name = name;
        this.price = price;
    }
}
```

> 结果显示：
>
> 电影屏幕打开...
>
> 电影开始...
>
> `Movie(String name)`构造器被调用

代码块的调用的顺序是优先于我们的构造器调用的

代码块使用注意事项：

- `static`代码块也叫静态代码块，作用是对类进行初始化，而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行

- 类什么时候被加载（重要）：

  - 创建对象实例时（`new`）
  - 创建子类对象实例，父类也会被加载，如果子类和父类中都有代码块，父类的代码块会先被执行
  - 使用类的静态成员时（静态属性，静态方法），代码块中的内容会先被执行
  - 使用类的静态成员时（静态属性，静态方法），如果这个子类的父类有代码块，也会被加载执行，而且父类的代码块会先被执行

- 普通代码块，在创建对象实例时，会被隐式的调用，被创建一次，就会被调用一次；如果只是使用类的静态成员时，普通代码块并不会执行

- 创建一个对象时，在一个类调用的顺序是（由先到后）：（重点和难点）

  1. 调用静态代码块和静态属性初始化

     静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按它们定义的顺序调用

     ```java
     public class CodeBlock {
         public static void main(String[] args) {
             A a = new A();  // 输出顺序：（1）getN1被调用... （2）A 静态代码块
         }
     }
     
     class A {
         // 静态属性初始化
         private static int n1 = getN1();
         // 静态代码块
         static {
             System.out.println("A 静态代码块");
         }
         public static int getN1() {
             System.out.println("getN1被调用...");
             return 100;
         }
     }
     ```

  2. 调用普通代码块和普通属性初始化

     普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通变量初始化，则按它们定义的顺序调用

  3. 调用构造器方法

- 构造器的代码最前面是隐含了`super()`和调用普通代码块

  ```java
  class A {
      public A() {
          System.out.println("ok");
      }
      
      // 上述构造器有隐藏的执行要求
      public A() {
          // （1）调用父类的无参构造器
          // 如果父类中也有其本类的普通代码块，在调用父类构造器时，会先进行父类中普通代码块的调用
          super();
          // （2）调用本类普通代码块的隐藏逻辑
          System.out.println("ok");
      }
  }
  ```

- 在创建一个子类对象时（有继承关系），它们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序为（由先到后）：（高频面试题）

  1. 父类的静态代码块和静态属性（优先级一样，按照定义顺序执行）
  2. 子类的静态代码块和静态属性（优先级一样，按照定义顺序执行）
  3. 父类的普通代码块和普通属性初始化（优先级一样，按照定义顺序执行）
  4. 父类的构造方法
  5. 子类的普通代码块和普通属性初始化（优先级一样，按照定义顺序执行）
  6. 子类的构造方法

  1和2，是类加载时必须会执行的；后面4步是与对象相关的内容（入口是对应子类的构造器，遵守构造顺序）

- 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员

***

### `final`关键字

`final`关键字可以修饰类、属性、方法和局部变量

有以下的四个情况会使用到`final`关键字：

- 当不希望类被继承时，可以用`final`修饰（希望这个类是最后的类，不希望被其他类继承扩展）

  ```java
  // 如果我们要求A类不能被其他类继承，使用final关键字修饰即可
  final class A {}
  
  // 这样其他类继承就会直接报错
  class B extends A {}  // 报错
  ```

- 当不希望父类的某个方法被子类覆盖/重写时，可以使用`final`关键字修饰

  ```java
  // 如果我们不希望父类的某个方法被子类覆盖/重写时，使用final关键字修饰即可
  // A作为父类
  class A {
      // 不希望hi()方法被子类覆盖/重写，使用final关键字修饰即可
      public final void hi() {}
  }
  ```

- 当不希望类的某个属性值被修改，可以用`final`关键字修饰

  ```java
  class A {
      // 不希望某个属性值被修改，使用final关键字修饰即可
      public final double TAX_RATE = 0.08;
  }
  ```

- 当不希望某个局部变量被修改，可以使用`final`关键字修饰

  ```java
  class A {
      public void hi() {
          // 不希望某个局部变量被修改，使用final关键字修饰即可
          final double NUM = 0.01;   // 这时NUM也被称为局部常量
          NUM = 0.2; // 报错
      }
  }
  ```

注意事项：

- `final`修饰的属性又叫常量，一般用`XX_XX_XX`来命名

- `final`修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在下面几个位置：

  - 定义时：如：`public final double TAX_RATE = 0.08;`

  - 在构造器中

    ```java
    class A {
        // 在构造器中赋初值
        public final double TAX_RATE;
        
        public A() {
            TAX_RATE = 0.08;
        }
    }
    ```

  - 在代码块中

    ```java
    class A {
        // 在代码块中赋初值
        public final double TAX_RATE;
        
        {
            TAX_RATE = 0.08;
        }
    }
    ```

- 如果`final`修饰的属性是静态的，则初始化的位置只能是在定义时和在静态代码块中，不能在构造器中赋值

  ```java
  class A {
      public static final double TAX_RATE1 = 0.02;
      
      public static final double TAX_RATE2;
      static {
          TAX_RATE2 = 0.08;
      }
  }
  ```

- `final`类不能继承，但是可以实例化出具体的对象

- 如果类不是`final`类，但是含有`final`方法，则该方法虽然不能重写，但是可以被继承下来供子类进行使用

- 一般来说，如果一个类已经是`final`类了，就没有必要再将方法修饰成`final`方法了（因为这个类已经是不能被继承了，就没有子类会去重写这个方法了）

- `final`不能修饰构造方法（即构造器）

- `final`和`static`往往搭配使用（两者的前后顺序可以改变），效率更高，底层编译器做了优化处理，不会导致类加载

  ```java
  class B {
      public static int num = 1000;
      public static int num2 = 2000;
      static {
          System.out.println("B类的静态代码块被执行");
      }
  }
  
  // 在主函数调用B类中的属性时，会加载类，先执行代码块中的内容
  System.out.println(B.num);   // B类的静态代码块被执行   1000
  
  // 当final和static一起使用时，不会加载类，不会执行代码块中的内容
  System.out.println(B.num2);  // 2000
  ```

- 对于类中的方法，其形参是可以用`final`修饰的，但是这样的形参是不能修改的

  ```java
  public int add(final int x) {
      // x的值不能修改
  }
  ```

- 对于包装类（`Integer`、`Double`、`Float`、`Boolean`等都是通过`final`修饰的），`String`也是`final`类，这些类都是不能被继承的

***

### 抽象类

当父类中的某些方法需要声明时，但是又不确定如何具体的实现，可以将其声明为抽象方法，那么这个类为抽象类

```java
abstract class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    // 这里实现了eat方法，但是实际上没有什么意义，后续在子类中都是要重写的（父类方法不确定性的问题）
    // 即将该方法设置为抽象方法
    //public void eat() {
    //    System.out.println("这是一个吃的方法，但是不知道具体吃什么");
    //}
    public abstract void eat();
}
```

抽象方法就是没有实现的方法，具体而言，就是没有方法体，这个具体的方法会让子类进行实现（一般来说，抽象类会被继承，由其子类来实现抽象方法）

将方法设置为抽象方法后，必须要将该类设置为抽象类，否则会报错

注意事项：

- 用`abstract`关键字来修饰一个类时，这个类就是一个抽象类
- 抽象类是不能被实例化的
- 抽象类不一定要包含`abstract`方法，也就是说，抽象类可以没有`abstract`方法
- 一旦类包含了`abstract`方法，则这个类必须声明为`abstract`类
- 抽象类可以有任意成员（因为抽象类的本质还是类），比如：非抽象方法、构造器、静态属性等
- 用`abstract`关键字来修饰一个方法时，这个方法就是一个抽象方法，该方法是没有方法体的，即没有`{}`
- `abstract`只能修饰类和方法，不能修饰属性和其他的内容
- 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法（对父类的抽象方法增加一个方法体`{}`，就表示实现了父类的方法），除非它自己也声明为抽象类
- 抽象类的价值更多的作用是在于设计，是设计者设计好后，让子类继承并实现抽象类
- 抽象方法不能使用`private`、`final`和`static`来修饰，因为这些关键字都是和重写相违背的

***

### 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来

基本语法：

```java
// 声明接口
interface 接口名 {
    // 可以写属性
    public int n1 = 10;
    
    // 可以写抽象方法，注意：在接口中，写抽象方法时，可以省略abstract关键字
    public void hi();
    
    // jdk8.0后，接口可以使用静态方法
    public static void cry() {
        System.out.println("cry");
    }
    
    // jdk8.0后，接口可以使用默认方法，但是要使用default关键字进行修饰
    default public void ok() {
        System.out.println("ok");
    }
}

// 类去使用接口
class 类名 implements 接口 {
    自己属性;
    自己方法;
    必须实现的接口的抽象方法;   // 如果一个类implements接口，需要将该接口的所有抽象方法都实现
}
```

> - 在`jdk7.0`前，接口里的所有方法都没有方法体，即都是抽象方法
> - `jdk8.0`后，接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现，但是默认方法要使用`default`关键字进行修饰

注意事项：

- 接口不能被实例化

- 接口中所有的方法都是`public`方法（`public`修饰符可以忽略），接口中抽象方法，可以不用`abstract`修饰

- 一个普通类实现接口，就必须将该接口的所有方法都实现（重写），可以使用`alt+enter`快捷键来快速实现

- 抽象类实现接口，可以不用实现接口的方法

- 一个类同时可以实现多个接口，但是也要完成这些接口中的所有抽象方法

- 接口中的属性，只能是`final`的，而且是`public static final`修饰符，比如：

  `int a = 1;`实际上为`public static final int a = 1;`（必须初始化）

  - 因为接口中的属性都是静态的，所以接口中属性的访问形式：接口名.属性名
  - 因为接口中的属性是`final`，所以后续我们不可以在外界修改接口中的属性值

- 接口不能继承其它的类，但是可以继承多个别的接口：`interface A extends B,C {}`

- 声明接口的修饰符只能是`public`和默认，这点和类的修饰符一样

```java
interface A {
    int a = 23;   // 等价于 public static final int a = 23;
}

class B implements A {}

// 在main方法中
B b = new B();
System.out.println(b.a);  // 23   对象实例去访问公共属性
System.out.println(A.a);  // 23   接口去访问内部的属性
System.out.println(B.a);  // 23   B类实现了A接口，可以使用A接口中的属性
```

#### 接口的使用场景

我们在具体什么时候需要使用接口，通常有以下的几个场景：

- 以制造飞机为例：对于各种种类的飞机，专家只需要把飞机需要的功能/规格定下来即可，具体的部分让别人实现即可
- 对于一个项目经理来说，管理三个程序员，要开发一个软件，为了控制和管理软件，项目经理可以定义一些接口，然后由程序员具体实现，这样可以更好的管理使用和统一命名规范

#### 实现接口和继承类

实现接口和继承类的区别：`Java`提供的实现接口机制，可以理解为对单继承机制的补充

- 继承的价值主要在于：解决代码的复用性和可维护性
- 接口的价值主要在于：设计好各种规范（方法），让其它类去实现这些方法，即更加灵活
- 接口比继承更加灵活，继承是满足`is-a`（是什么）的关系，而接口只需满足`like-a`（像什么）的关系
- 接口在一定程度上实现代码的解耦

```java
package com.jlctest.interface;

public class ExtendsVsInterface {
    public static void main(String[] args) {
        LittleMonkey wukong = new LittleMonkey("climbing");
        wukong.climbing();   // wukong猴子会爬树
        wukong.swimming();   // wukong通过学习，猴子会游泳
        wukong.flying();     // wukong通过学习，猴子会飞翔
    }
}

// 鱼类接口
interface Fishable {
    void swimming();
}

// 小鸟接口
interface Birdable {
    void flying();
}

// 猴子类
class Monkey {
    private String name;
    public Monkey(String name) {
        this.name = name;
    }
    public void climbing() {
        System.out.println(name + "猴子会爬树");
    }
    public String getName() {
        return name;
    }
}

// 小猴子类去继承猴子类
class LittleMonkey extends Monkey implements Fishable, Birdable {
    public LittleMonkey(String name) {
        this.name = name;
    }
    
    @Override
    public void swimming() {
        System.out.println(getName() + "通过学习，猴子会游泳");
    }
    
    @Override
    public void flying() {
        System.out.println(getName() + "通过学习，猴子会飞翔");
    }
}
```

> 对于继承，只要是继承了这个父类，其子类就可以自动的使用父类中的能力（公共方法）；同时继承是单继承的，只能继承一个父类，不同同时继承多个父类
>
> 通过实现接口，可以无形的将子类的功能进行加强（如果子类需要拓展功能，可以通过实现接口的方式扩展），`Java`提供的实现接口机制，可以理解为对单继承机制的补充

综合小练习：

```java
interface A {
    int x = 0;    // 等价于public static final int x = 0;
}

class B {
    int x = 1;   // 普通属性
}

class C extends B implements A {
    public void pX() {
        // System.out.println(x);  // 错误，原因不明确x到底是接口中的还是类中的
        // 访问接口中的x就使用A.x   访问父类的x就使用super.x
        System.out.println(A.x);
        System.out.println(super.x);
    }
}
```

#### 接口的多态特性

##### 多态参数

接口可以体现多态参数

```java
package com.jlctest.interface;

public class Computer {
    // 形参是接口类型 UsbInterface
    public void work(UsbInterface usbInterface) {
        // 通过接口，来调用方法
        usbInterface.start();
    }
}
```

在测试文件中使用`work`方法：

```java
package com.jlctest.interface;

public class interfaceTest {
    public static void main(String[] args) {
        // 创建手机对象，Phone类实现了UsbInterface接口
        Phone phone = new Phone();
        // 创建计算机对象
        Computer computer = new Computer();
        
        // 将手机接入到计算机中，通过多条参数，UsbInterface接口的对象实例是可以传递给work方法的
        computer.work(phone);    // 只要是实现了UsbInterface接口的对象实例，都可以进行传递
    }
}
```

接口引用可以指向实现了接口的类的对象

```java
package com.jlctest.interface;

public class InterfacePolyParameter {
    public static void main(String[] args) {
        // 接口的多态体现（与继承体现的多态类似）
        // 接口类型的变量 if01 可以指向 实现了IF接口类的对象实例
        IF if01 = new Monster();
        if01 = new Car();
    }
}

// 声明接口
interface IF {}
// 声明两个类去使用接口
class Monster implements IF {}
class Car implements IF {}
```

##### 多态数组

多态数组指的是接口类型的数组，可以存放实现了这个接口的类的实例

```java
package com.jlctest.interface;

public class InterfacePolyArr {
    public static void main(String[] args) {
        // 多态数组 -> 接口类型数组
        // Usb多态数组，存放Phone和Camera对象
        Use[] usbs = new Usb[2];   // 声明多态数组空间
        usbs[0] = new Phone();
        usbs[1] = new Camera();
        
        // 遍历Usb多态数组，如果是Phone对象，除了调用Usb接口定义的方法体外，还要调用特有的call方法
        for(int i = 0; i < usbs.length; i++) {
            usbs[i].work();  // 体现了动态绑定机制
            // 通过类型的向下转型，进行运行类型的判断，判断运行类型是否为Phone
            if(usbs[i] instanceof Phone) {
                ((Phone) usbs[i]).call();
            }
        }
    }
}

// 声明接口
interface Usb {
    void work();
}
// 声明两个类去使用接口
class Phone implements Usb {
    @Override
    public void work() {
        System.out.println("手机工作中...");
    }
    
    public void call() {
        System.out.println("手机可以打电话...");
    }
}
class Camera implements Usb {
    @Override
    public void work() {
        System.out.println("相机工作中...");
    }
}
```

##### 多态传递

```java
package com.jlctest.interface;

public class InterfacePolyPass {
    public static void main(String[] args) {
        // 接口类型的变量 ig 可以指向 实现了该接口类的对象实例
        IG ig = new Teacher();   
        // 但是 IH ih = new Teacher();会报错，Teacher类没有实现IH接口  interface IG {}
        // 但是如果让IG接口去继承IH接口，进行多态传递  interface IG extends IH{}
        IH ih = new Teacher();  // 不报错
    }
}

// 声明接口
interface IH {}
// interface IG {}
interface IG extends IH{}

// 声明类去使用接口
class Teacher implements IG {}
```

具体来说：如果`IG`继承了`IH`接口，而`Teacher`类实现了`IG`接口，那么，实际上就相当于`Teacher`类也实现了`IH`接口

***

### 内部类

内部类是指，一个类的内部又完整的嵌套了另一个类结构。被嵌套的类被称为内部类（`inner class`），嵌套其他类的类称为外部类（`outer class`）

基本语法：

```java
class Outer {  // 外部类
    class Inner {  // 内部类
        ...
    }
}

class Other {  // 外部其他类
    ...
}
```

内部类是类的第五大成员，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，内部类是重点也是难点，底层源码使用了大量的内部类

```java
class Outer {  // 外部类
    // 属性
    private int n1 = 100;  
    // 方法
    public void m1() {   
        System.out.println("m1()");
    }
    // 构造器
    public Outer(int n1) {
        this.n1 = n1;
    }
    // 代码块
    {
        System.out.println("代码块");
    }
    // 内部类
    class Inner {  
        ...
    }
}
```

内部类有四种，内部类的分类有两种：

- 定义在外部类局部位置上（如方法体内）：
  - 局部内部类（有类名）
  - 匿名内部类（没有类名，是一个重点）
- 定义在外部类的成员位置上（属性和方法位置上）：
  - 成员内部类（没有`static`修饰）
  - 静态内部类（使用`static`修饰）

#### 局部内部类

局部内部类是定义在外部类的局部位置，通常在方法中，并且有类名

基本语法：

```java
class Outer {  // 外部类
    // 属性
    private int n1 = 100;
    // 方法
    public void m1() {   
        // 定义局部内部类
        class Inner {
            // 可以直接访问外部类的所有成员，包含私有的（私有属性只能在本类进行访问）
            public void f1() {
                // 局部内部类访问外部类的成员方式是直接访问
                System.out.println(n1);    // 100
            }
        }
        // 同一作用域中，在外部类方法中，访问局部内部类的成员
        // 先创建局部内部类对象，再通过对象进行访问
        Inner inner = new Inner();
        inner.f1();
    }
}
```

注意事项：

- 局部内部类，其本质还是一个类，类的要素都有

- 局部内部类可以直接访问外部类的所有成员，包含私有的

- 不能给局部内部类添加访问修饰符，因为它的地位就是一个局部变量，局部变量是不能使用修饰符的，但是可以使用`final`修饰，因为局部变量也可以使用`final`

- 局部内部类的作用域：仅仅在定义它的方法体或代码块中

- 局部内部类访问外部类的成员方式：直接访问（局部内部类-->访问-->外部类的成员）

- 外部类访问局部内部类的成员方式：先创建对象再访问，同时必须要在作用域内

- 外部其他类是不能访问局部内部类的（因为局部内部类的地位是一个局部变量）

- 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问

  ```java
  class Outer {
      private int n1 = 100;
      public void m1() {   
          // 定义局部内部类
          class Inner {
              private int n1 = 200;
              public void f1() {
                  System.out.println(n1);    // 200   重名时，就近访问
                  // 如果一定要访问外部类，可以使用外部类名.this.成员的方式
                  // Outer.this本质为外部类的一个实例对象，即外界主函数中哪个对象调用了m1()方法，Outer.this就指向哪个对象
                  System.out.println(Outer.this.n1);  // 100
              }
          }
      }
  }
  ```

#### 匿名内部类

匿名内部类在底层的框架和项目的开发中使用的非常多

匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名

基本语法：

```java
new 类或接口(参数列表) {
    类体;
};
```

##### 基于接口的匿名内部类

```java
public class AnonymousInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.method();
    }
}

class Outer {  // 外部类
    private int n1 = 10;
    public void method() {
        // 传统方式是写一个类，实现该接口，再创建这个对象，并指向这个接口
        // 如果需求是这个类只使用一次，那么定义的Tiger其他外部类就会浪费
        IA tiger = new Tiger();
        tiger.cry();    // 老虎叫...
        
        // 针对上述的情况，我们可以使用接口的匿名内部类进行简化，将外界的Tiger其他外部类去掉
        // tiger的编译类型是IA   运行类型是匿名内部类，底层为class XXX implements IA { ... }
        // 匿名内部类在底层中系统会分配一个类名的，XXX在底层为Outer$1 （外部类+$+数字）
        // jdk底层在创建匿名内部类Outer$1，立即就创建了Outer$1的实例，并且将地址返回给tiger
        // 匿名内部类使用一次，就不能再使用了，不是tiger对象，tiger对象可以一直使用
        IA tiger = new IA() {
            @Override
            public void cry() {
                System.out.println("老虎叫...")：
            }
        };
        tiger.cry();    // 老虎叫...
    }
}

interface IA {   // 接口
    public void cry();
}

class Tiger implements IA {
    @Override
    public void cry() {
        System.out.println("老虎叫...")：
    }
}
```

##### 基于类的匿名内部类

```java
public class AnonymousInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.method();
    }
}

class Outer {  // 外部类
    private int n1 = 10;
    public void method() {
        // 创建一个Father的实例  编译类型和运行类似都是Father
        Father father = new Father("jack");
        
        // 基于类的匿名内部类
        // father的编译类型是Father  运行类型是匿名内部类（外部类+$+数字）
        // 运行类型是匿名内部类，底层为class XXX extends Father { ... }  有个继承的关系
        // 使用匿名内部类，同时也会返回匿名内部类的对象，将对象地址返回给father
        // 这里的参数列表，会传递给Father类写好的构造器
        Father father = new Father("jack") {
            @Override
            public void test() {
                System.out.println("匿名内部类重写了test方法");
                // 可以直接访问外部类的所有成员，包含私有的
                System.out.println(n1);   // 10
            }
        }
        fatehe.test();   // 匿名内部类重写了test方法
        
        // 基于抽象类的匿名内部类
        Animal animal = new Animal() {
            // 抽象类中下面内容是必须要写的
            @Override
            void eat() {
                System.out.println("小狗吃骨头");
            }
        }
        animal.eat();   // 小狗吃骨头
    }
}

class Father {
    // 构造器
    public Father(String name) {}
    public void test() {}
}

abstract class Animal {  // 抽象类
    abstract void eat();
}
```

注意事项：

- 匿名内部类的本质也是一个类，是一个内部类（即定义在外部类的局部位置，比如方法中），且是没有类名的，同时匿名内部类还是一个对象

- 匿名内部类既是一个类的定义，同时它本身也是一个对象，从语法上看，它既有定义类的特征，也有创建对象的特征

  ```java
  // 可以直接调用匿名内部类的方法    本质上就是对象.方法   匿名内部类本身也是返回对象
  new Father("jack") {
      @Override
      public void test() {
          System.out.println("匿名内部类重写了test方法");
      }
  }.test();    // 匿名内部类重写了test方法
  ```

- 匿名内部类可以直接访问外部类的所有成员，包含私有的

- 匿名内部类不能添加访问修饰符，因为它的地位就是一个局部变量

- 匿名内部类的作用域：仅仅在定义它的方法或代码块中

- 外部其他类不能访问匿名内部类（因为匿名内部类的地位是一个局部变量）

- 如果外部类和匿名内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问

##### 匿名内部类的最佳实践

当做实参直接传递，简洁高效

```java
public class AnonymousInnerClass {
    public static void main(String[] args) {
        // 使用匿名内部类当做实参直接传递，简洁高效
        f1(new IL() {
            @Override
            public void show() {
                System.out.println("这是一幅名画");
            }
        });
    }
    
    // 定义静态方法，形参是接口类型
    public static void f1(IL il) {
        il.show();
    }
}

interface IL {   // 接口
    void show();
}
```

如果不使用匿名内部类，我们就需要写出这个类去实现这个接口，通过硬编码的方式去实现

在匿名内部类中修改内容，只是影响这一个实参传入，如果使用硬编码的方式，修改了类中的内容，就会修改所有基于这个类实例出的对象

#### 成员内部类

成员内部类是定义在外部类的成员位置，并且没有`static`修饰

```java
class Outer {   // 外部类
    private int n1 = 10;
    
    // 定义成员内部类
    class Inner {
        public void say() {
            // 成员内部类中可以直接访问外部类中的所有成员
            System.out.println(n1);   // 10
        }
    }
    
    // 访问成员内部类中的方法，通过成员内部类实例化出一个对象，再使用这个对象进行调用
    public void t1() {
        Inner inner = new Inner();
        inner.say();
    }
}
```

注意事项：

- 成员内部类可以直接访问外部类的所有成员，包括私有的

- 成员内部类可以添加任意访问修饰符（`public`、`protected`、默认、`private`），因为成员内部类的地位就是一个成员

- 成员内部类的作用域和外部类的其他成员一样，为整个类体（成员内部类的类名可以在整个外部类中使用）

- 外界类去访问成员内部类中的属性和方法，需要创建对象再调用

- 外部其他类也可以访问成员内部类，有两种常见的方式：

  ```java
  public class AnonymousInnerClass {
      public static void main(String[] args) {
          Outer outer = new Outer();
          
          // 第一种方式
          // 相当于将new Inner()当作outer对象的一个成员
          Outer.Inner inner01 = outer.new Inner();
          inner01.say();
          
          // 第二种方式
          // 在外部类中，编写一个方法，可以返回Inner对象
          Outer.Inner inner02 = outer.getInnerInstance();
          inner02.say();
      }
  }
  
  class Outer {   // 外部类
      private int n1 = 10;
      // 定义成员内部类
      class Inner {
          public void say() {
              // 成员内部类中可以直接访问外部类中的所有成员
              System.out.println(n1);   // 10
          }
      }
      
      // 为外界返回一个Inner对象实例，供方法二调用
      public Inner getInnerInstance() {
          return new Inner();
      }
  }
  ```

- 如果外部类和成员内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问

#### 静态内部类

静态内部类是定义在外部类的成员位置，并且有`static`修饰

```java
public class AnonymousInnerClass {
    public static void main(String[] args) {
        Outer outer = new Outer();
        // 外部其他类访问静态内部类
        // 第一种方式
        // 静态内部类是可以通过类名直接访问的（前提是满足访问权限，私有的是不能访问的）
        Outer.Inner inner01 = new Outer.Inner();
        inner01.say();
        // 第二种方式
        // 在外部类中，编写一个方法，可以返回Inner对象实例
        Outer.Inner inner02 = outer.getInnerInstance();
        inner02.say();
        // 通过静态方法返回   静态方法是可以直接通过类去调用的
        Outer.Inner inner03 = Outer.getInner();
        inner03.say();
    }
}

class Outer {   // 外部类
    private int n1 = 10;
    private static String name = "jlc";
    // 定义静态内部类
    static class Inner {
        public void say() {
            // 静态内部类可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
            System.out.println(n1);   // 报错
            System.out.println(name);  // jlc
        }
    }
    
    // 静态内部类的作用域：同其他的成员，为整个类体
    public void m1() {
        Inner inner = new Inner();
        inner.say();
    }
    
    // 为外界返回一个Inner对象实例，供方法二调用，通过非静态的方法
    public Inner getInnerInstance() {
        return new Inner();
    }
    // 也可以通过静态的方法，返回Inner对象实例
    public static Inner getInner() {
        return new Inner();
    }
}
```

注意事项：

- 静态内部类可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
- 可以添加任意访问修饰符（`public`、`protected`、默认、`private`），因为静态内部类的地位就是一个成员
- 静态内部类的作用域：同其他的成员，为整个类体
- 外部类访问静态内部类的成员，需要先创建对象，在调用访问
- 如果外部类和静态内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（`外部类名.this.成员`）去访问



## 枚举和注解

对于特有的季节对象，季节的值只有四个（春夏秋冬），这些值一般都是只读，且不需要修改的

枚举是一组常量的集合，属于一种特殊的类，里面只包含一组有限的特点对象

### 自定义枚举类

- 不需要提供`setXxx`方法，因为枚举对象值通常为只读，不能在外界增加或者减小，并不提供修改
- 自定义枚举类的构造器是私有化的
- 对枚举对象/属性使用`final+static`共同修饰，实现底层优化
- 枚举对象名通常使用全部大写，即常量命名的规范
- 枚举对象根据需要，也可以有多个属性

```java
public class Enumeration {
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN);    // 直接使用类
    }
}

// 自定义枚举类
class Season {
    private String name;
    private String desc;
    
    // 在Season内部，直接创建所有的固定对象
    public static final Season SPRING = new Season("春天", "温暖");
    public static final Season SUMMER = new Season("夏天", "炎热");
    public static final Season AUTUMN = new Season("秋天", "凉爽");
    public static final Season WINTER = new Season("冬天", "寒冷");
    
    // 构造器私有化，在外界就不可以new一个对象了，在类的内部还是可以使用的
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
    // 只留下get相关的方法，去掉set相关的方法，防止属性被修改
    public String getName() {
        return name;
    }
    public String getDesc() {
        return desc;
    }
    
    // 打印对象的信息
    @Override
    public String toString() {
        return "Season{" + "name='" + name + '\'' +
                ", desc='" + desc + '\'' + '}';
    }
}
```

***

### 关键字实现枚举类

使用`enum`关键字实现枚举类

```java
public class Enumeration {
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN);    // 直接使用类
    }
}

// 使用关键字实现枚举类，使用enum关键字替代class
enum Season {
    // 在Season内部，直接创建所有的固定对象，通过常量名(实参列表)  进行简化  实参列表和构造器关联
    // 使用枚举的时候，要求将定义的常量对象写在类的最前面，否则会报错
    SPRING("春天", "温暖"), SUMMER("夏天", "炎热"), AUTUMN("秋天", "凉爽"), WINTER("冬天", "寒冷");     // 多个常量对象，中间使用逗号间隔
    
    private String name;
    private String desc;
    
    // 构造器私有化，在外界就不可以new一个对象了，在类的内部还是可以使用的
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
    // 只留下get相关的方法，去掉set相关的方法，防止属性被修改
    public String getName() {
        return name;
    }
    public String getDesc() {
        return desc;
    }
    
    // 打印对象的信息
    @Override
    public String toString() {
        return "Season{" + "name='" + name + '\'' +
                ", desc='" + desc + '\'' + '}';
    }
}
```

注意事项：

- 当我们使用`enum`关键字开发一个枚举类时，默认会继承`Enum`类，而且是一个`final`类
- 传统的`public static final Season SPRING = new Season("春天", "温暖"); `对象创建简化为`SPRING("春天", "温暖");`，这里需要知道，其调用哪个构造器
- 如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略
- 当有多个枚举对象时，使用逗号间隔，最后一个用分号结尾
- 枚举对象必须放在枚举类的首行

#### 枚举常用的方法

使用`enum`关键字时，会隐式的继承`Enum`类，我们可以使用`Enum`类的相关方法，常用的方法有：

|   方法名    |                             描述                             |
| :---------: | :----------------------------------------------------------: |
|  `valueOf`  | 传递枚举类型的`Class`对象和枚举常量名称给静态方法`valusOf`，会得到与参数匹配的枚举常量 |
| `toString`  | 得到当前枚举常量的名称。可以通过重写这个方法，来使得到的结果更易读 |
|  `equals`   | 在枚举类型中可以直接使用`==`来比较两个枚举类常量是否相等。`Enum`提供的这个`equals()`方法，也是可以直接使用`==`实现的。它的存在是为了在`Set`、`List`、`Map`中使用。注意，`equals()`是不可变的 |
| `hashCode`  | `Enum`实现了`hashCode()`来和`equals()`保持一致，它也是不可变的 |
|   `name`    |     得到当前枚举常量的名称，但是更建议使用`toString`方法     |
|  `ordinal`  |                    得到当前枚举常量的次序                    |
| `compareTo` | 枚举类型实现了`Comparaable`接口，这样可以比较两个枚举常量的大小/编号（按照声明的顺序排列） |
|   `clone`   | 枚举类型不能被`Clone`，为了防止子类实现克隆方法，`Enum`实现了一个仅抛出`CloneNotSupportedException`异常的不变`Clone()` |

各种方法的使用演示：

```java
    public static void main(String[] args) {
        Season autumn = Season.AUTUMN;
        // 演示name方法
        System.out.println(autumn.name());    // AUTUMN   输出枚举对象的名称
        
        // 演示ordinal方法
        System.out.println(autumn.ordinal());    // 2   输出枚举对象的次序/编号，从0开始编号
        
        // values方法，返回Season数组，包含定义的所有枚举对象，可以从反编译找到values方法
        Season[] values = Season.values();
        for(Season season: values) {  // 增强for循环，依次从values数组中取出数据，赋值给season
            System.out.println(season);   // 输出四个枚举对象
        }
        
        // 演示valueOf方法：将字符串转换成枚举对象，要求字符串必须为已有的常量，否则报错
        // 执行流程：1.根据给定的字符串到Season的枚举类对象中去查找
        // 2.如果找到了，就返回，如果没有找到，就报错
        Season autumn1 = Season.valueOf("AUTUMN");
        System.out.println(autumn1);   // 这里的autumn1和之前的autumn指向的是同一个对象
        
        // 演示compareTo方法
        // 将前后两个对象的枚举编号进行比较
        // 结果返回前面的编号减去后面的编号  Season.AUTUMN的编号 - Season.SUMMER的编号
        System.out.println(Season.AUTUMN.compareTo(Season.SUMMER));   // 1
    }
}

// 使用关键字实现枚举类，使用enum关键字替代class
enum Season {
    SPRING("春天", "温暖"), SUMMER("夏天", "炎热"), AUTUMN("秋天", "凉爽"), WINTER("冬天", "寒冷");
    
    private String name;
    private String desc;
    
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
    
    public String getName() {
        return name;
    }
    public String getDesc() {
        return desc;
    }
    
    // 打印对象的信息，直接输出对象，就会通过这个重写方法输出如下的自定义信息
    @Override
    public String toString() {
        return "Season{" + "name='" + name + '\'' +
                ", desc='" + desc + '\'' + '}';
    }
}
```

#### `enum`实现接口

使用`enum`关键字后，就不能再继承其他类了，因为`enum`会隐式的继承`Enum`类，而`Java`是但继承机制的

枚举类和普通类一样，可以实现接口：`enum 类名 implements 接口1, 接口2 {}`

```java
interface IPlaying {
    public void playing();
}

enum Music implements IPlaying {
    CLASSICMUISC;
    @Override
    public void playing() {
        System.out.println("播放音乐");
    }
}

// 主函数调用
Music.CLASSICMUISC.playing();   // 播放音乐
```





## 设计模式

设计模式是在大量的实践中总结和理论化之后的代码结构、编程风格、以及解决问题的思考方式。设计模式就像经典的棋谱，不同的棋局，我们使用不同的棋谱，免去我们自己再思考和摸索

***

### 单例模式

单例（单个实例）设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（在软件运行的时候，我们要保证某一个类只能有一个实例化对象）

单例模式有两种方式：饿汉式和懒汉式

- 两者最主要的区别在于创建对象的时机不同，饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建对象
- 饿汉式不存在线程安全问题，而懒汉式存在线程安全问题
- 饿汉式存在浪费资源的可能，因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了

#### 饿汉式

饿汉式的单例模式，只要类一加载，就会在其内部创建对象（饿汉式方式可能创建了对象但是没有使用）

饿汉式单例设计模式具体步骤如下：

1. 构造器私有化，防止在类的外部直接通过`new`方法实例化对象
2. 类的内部创建对象（该对象是静态的）
3. 向外暴露一个静态的公共方法，`getInstance()`

```java
package com.jlctest.single;

public class SingleTon {
    public static void main(String[] args) {
        // 通过公共的静态方法可以获取对象（且只能是一个）
        GirlFriend instance = GirlFriend.getInstance();
        // GirlFriend.getInstance()重复执行，还是返回在类中创建的那个对象
    }
}

// 有一个类，GirlFriend   使用饿汉式的单例设计模式  软件运行过程中只能实例化一个对象
class GirlFriend {
    private String name;
    
    // 2.在类的内部创建对象，设置为静态属性，我们后续的静态方法可以访问到
    // 同时静态的方法，只会在类创建的时候初始化一次，后续不会重复初始化
    private static GirlFriend gf = new GirlFriend("小红");
    
    // 1.将构造器私有化
    private GirlFriend(String name) {
        this.name = name;
    }
    
    // 3.提供一个公共的static方法，返回gf对象
    public static GirlFriend getInstance() {
        return gf;
    }
}
```

#### 懒汉式

与饿汉式的单例模式不同，懒汉式的单例模式，只有在调用暴露的静态公共方法时，才会在类的内部创建实例（防止了饿汉式的情况：可能出现创建了对象但是没有使用），在后面再次调用时，会返回上次创建的对象（因为是静态属性），从而保证单例

懒汉式单例设计模式具体步骤如下：

1. 构造器私有化，防止在类的外部直接通过`new`方法实例化对象
2. 类的内部创建对象（该对象是静态的）
3. 向外暴露一个静态的公共方法，`getInstance()`

```java
package com.jlctest.single;

public class SingleTon {
    public static void main(String[] args) {
        // 通过公共的静态方法可以获取对象（且只能是一个）
        GirlFriend instance = GirlFriend.getInstance();
        // GirlFriend.getInstance()重复执行，还是返回在类中创建的那个对象
    }
}

// 有一个类，GirlFriend   使用懒汉式的单例设计模式  软件运行过程中只能实例化一个对象
class GirlFriend {
    private String name;
    
    // 2.在类的内部创建对象，设置为静态属性，我们后续的静态方法可以访问到
    // 同时静态的方法，只会在类创建的时候初始化一次，后续不会重复初始化
    private static GirlFriend gf;
    
    // 1.将构造器私有化
    private GirlFriend(String name) {
        this.name = name;
    }
    
    // 3.提供一个公共的static方法，返回gf对象
    public static GirlFriend getInstance() {
        // 如果对象还没有创建，就创建一个对象
        if(gf == null) {
            gf = new GirlFriend("小红");
        }
        return gf;
    }
}
```

***

### 模板模式

#### 抽象模板模式

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但是子类总体上会保留抽象类的行为方式

模板设计模式能解决的问题：

- 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现
- 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，这就是一种模板模式

设计一个抽象类（`Template`），完成如下功能：

1. 编写方法`calculateTime()`，用于计算某段代码的消耗时间
2. 编写抽象方法`job()`
3. 编写一个子类`Sub`，继承抽象类`Template`，并实现`job()`方法
4. 编写一个测试类，看看是否好用

```java
package com.jlctest.abstract;

// 抽象父类
abstract class Template {
    public abstract void job();  // 抽象方法
    
    // 统计耗时时间，具体的实现方法，调用了job()抽象方法
    public void calculateTime() {
        // 统计当前时间距离 1970-1-1 0:0:0的时间差，单位为ms
        long start = System.currentTimeMillis();
        job();   // 体现了动态绑定机制
        long end = System.currentTimeMillis();
        System.out.println("耗时：" + (end - start));
    }
}
```

子类去继承父类，实现父类中的抽象方法：

```java
package com.jlctest.abstract;

public class AA extends Template {
    // 实现了父类中的抽象方法
    @Override
    public void job() {
        long num = 0;
        for(long i = 1; i <= 800000; i++) {
            num += i;
        }
    }
}
```

在测试文件中执行：

```java
package com.jlctest.abstract;

public class Test {
    public static void main(String[] args) {
        AA a = new AA();
        a.calculateTime();
    }
}
```

