# `Java`

## 基本概念

`Java` 是一种广泛使用的高级编程语言，由 `Sun Microsystems`公司（现为` Oracle `甲骨文公司所有）于 1995 年正式发布（第一个版本）由`James Gosling`编写。它以跨平台性、面向对象和健壮性著称，是当今企业级应用、移动开发和大数据领域的核心技术之一，`Java`使用最多的版本是8和11

***

### `Java`的重要特点

- `Java`语言是面向对象的（`oop`）

- `Java`语言是健壮性的，`Java`的强类型机制、异常处理、垃圾的自动收集等是健壮性的重要保证

- `Java`语言是跨平台性的：编译后的`.class`文件可以在跨平台上进行运行，不需要重新进行编译（由于底层中有`Java`虚拟机机制（`JVM`）的存在）

  ![image-20250311171735772](..\images\image-20250311171735772.png)

- `Java`语言是解释型性的

  解释性语言有：`JavaScript`、`PHP`、`Java`

  编译性语言有：`c`、`c++`

  解释性语言，编译后的代码不能直接被机器执行，需要解释器来执行；编译性语言，编译后的代码可以直接被机器执行（编译后的代码已经是二进制的了）

***

### 环境安装

#### 代码编辑器安装

一开始在学习的时候，推荐使用`Sublime Text`代码编辑器进行敲代码，后续大规模开发的时候，推荐使用`IDEA`代码编辑器进行代码的编写，该编辑器有较好的代码提示，能帮助我们快速的编写代码

##### `Sublime Text`

###### 常见的问题

1. 汉化`Sublime Text`
   - 打开`Sublime Text`代码编辑器
   - 使用快捷键`shift+ctrl+p`
   - 输入`Package Control: Install Package`
   - 在搜索框中输入`Chinese`，选择下拉框中的`ChineseLocalizations`
   - 下载完重新打开编辑器，即可汉化
2. `Sublime`里面找不到`GBK`编码格式 
   - 打开`Sublime Text`代码编辑器
   - 使用快捷键`shift+ctrl+p`
   - 输入`Package Control: Install Package`
   - 在搜索框输入`converToUTF8`，选择并安装
   - 后续在文件->`Set File Encoding to`中就可以选择`gbk`进行编码了

##### `IntelliJ IDEA`

[下载官网](https://www.jetbrains.com/)

- 从官网下载安装包，推荐使用专业版

- 右键，以管理员身份运行

- 指定安装目录，选择64位，其他都不选，点击下一步

- 打开安装好的代码编辑器，新建一个项目，选择一个`Java`项目，默认会加载电脑中安装的`JDK`环境，如果没有加载上，我们手动添加即可，选择到本地安装的`JDK`的顶级安装目录即可

- 创建具体项目的名称，并指定具体目录的位置

- 在项目文件中的`src`文件中创建开发文件：单机`src`文件夹右键-->`new`-->`Java Class`-->输入具体项目的文件名

- 编写好代码后，直接通过代码左边的绿色小箭头，或者右键，选择`run`即可编译运行，在终端得到结果

  在`idea`中，当我们`run`一个文件时，会先编译成`.class`，再运行

  具体的文件结构逻辑：编译运行后，会在项目根目录文件夹中生成`out`文件夹，文件夹下有`production`文件，里面就有编译后的类文件

###### 基本设置

- 设置字体大小：菜单`file`-->`settings`-->`Appearance`-->选中`use custom font`-->设置合适字体大小
- 字符编码设置：菜单`file`-->`settings`-->`Editor`-->`File Encoding`-->在`Global Encoding`设置`UTF-8`（设置全局编码，默认是`UTF-8`），也可以在`Project Encoding`设置项目编码

###### `IDEA`快捷键自定义配置

快捷键自定义配置：菜单`file`-->`settings`-->`Keymap`-->选择具体的规则进行快捷键的修改

- 删除当前行：建议设置为`ctrl+d`

- 复制当前行：建议设置为`ctrl+alt+向下光标`

- 补全代码：`alt+/`

- 添加或取消注释：`ctrl+/`

- 导入该行需要的类：配置`auto import`

  ![image-20250329165813284](..\images\image-20250329165813284.png)

  然后使用`alt+enter`即可

- 快速格式化代码：`ctrl+alt+l`

- 快速运行程序：建议设置为`alt+r`

- 生成构造器的快捷键：`alt+insert`

- 查看一个类的层级关系：`ctrl+h`

- 定位到具体的方法：`ctrl+b`  将光标放在一个方法上，输入快捷键，可以定位到对应的方法

- 自动分配变量名：在变量后面加`.var`回车即可

###### 模板快捷键

模块快捷键可以帮助我们加快代码的编写速度，只需要输入定义的快捷键内容，就可以得到对于的代码模板

我们可以在`file`-->`settings`-->`editor`-->`Live templates`-->查看有哪些模板快捷键/自定义模板快捷键

系统提供的常用模板快捷键有：

- `main`模板快捷键对应的内容：

  ```java
  public static void main(String[] args) {
      
  }
  ```

- `sout`模板快捷键对应的内容：

  ```java
  System.out.println("hello,world");
  ```

- `fori`模板快捷键对应的内容：

  ```java
  for (int i = 0; i < ; i++) {
      
  }
  ```

对于自定义的模板快捷键，我们点击右上角的加号，输入快捷键的名字和内容，同时设置应用的范围，我们一般要应用给`Java`使用

#### `JDK`的安装

`JDK`是`Java`开发工具包，`JDK`=`JRE`+`Java`的开发工具（`java`、`javac`、`javadoc`、`javap`等）

`JRE`是`Java`的运行环境，包括了`Java`虚拟机和`Java`程序所需的核心类库等，如果想要运行一个开发好的（编译好的）`Java`程序，计算机中只需安装`JRE`即可

安装后的文件系统结构：

- `bin`目录：包含了所有的`Java`开发工具

  安装后，需要配置环境变量，将`bin`目录的路径添加到环境变量中

- `jre`目录：`jdk`中安装的`jre`目录

- `src.zip`：是`JDK`的源码包，里面有其源代码

***

### 运行机制

程序：计算机执行某些操作或解决某个问题而编写的一系列**有序指令的集合**

`Java`的运行机制和过程：`Java`程序可以运行在跨平台的系统上，其根本原因是由于`JVM`（`Java`的虚拟计算机，具有指令集并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器），每个操作系统都可以去下载其对应的`JVM`，从而去运行`Java`程序，`JVM`是包含在`JDK`中的

`Java`虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行：

- 编译：将`Java`源文件通过编译器将其编译成`JVM`可以识别的字节码文件

  编译指令：`javac 编写的Java文件`

  如果程序没有错误，就可以编译成功，会在源文件目录中出现一个字节码文件，也就是可执行的`Java`程序

- 运行：通过运行工具`java.exe`对字节码文件进行执行，本质就是将`.class`文件装载到`jvm`机执行

- 运行指令：`java 编译后的Java文件`

![image-20250311211020786](..\images\image-20250311211020786.png)

对修改后的源文件，需要进行重新编译，生成新的`.class`文件，再执行，**才能生效**

***

### 第一个`Java`程序

```java
// 第一个java程序
// 编写一个类
public class Hello {
	// 编写一个类方法
	public static void main(String[] args) {
		System.out.println("helloWorld!");    // 一个结束语句要以分号结尾
	}
}
```

> 声明`Hello`是一个公有的类
>
> `public static void main(String[] args)`表示定义一个主方法，是一个程序执行的入口
>
> `static`表示定义一个静态的方法
>
> `System.out.printIn()`：内置的输入方法，将内容输出到屏幕上
>
> 在编译的时候，如果文件内有中文，包括注释，我们需要将编码方式改为`gbk`的形式，这样才能正常编译

使用命令行终端，在当前代码的目录下输入`javac Hello.java`进行编译，成功编译后，会出现`Hello.class`的编译结果文件，使用命令`java Hello`即可运行，得到运行结果

![image-20250311210554522](..\images\image-20250311210554522.png)

***

### 注释

注释是用于说明解释程序的文字提示，提高了代码的可读性，编写程序需要养成注释的好习惯，推荐先将自己的思想通过注释整理出来，再用代码去实现

- 单行注释

  ```java
  // 单行注释
  ```

  > 单行注释快捷键：选中区域+`ctrl`+`/ `取消注释同样是这个快捷键

- 多行注释

  ```java
  /* 多行
     注释 */
  ```

  > 多行注释中不能嵌套多行注释
  >
  > 多行注释快捷键：选中区域+`Ctrl`+`shift`+/ 取消注释是选中区域+Ctrl+shift+
  > 选中区域+Ctrl+shift+\

- 文档注释

  文档注释的内容可以被`JDK`提供的工具`javadoc`所解析，生成一套以网页文件形式体现的该程序的说明文档，文档注释一般写在类中（想要对类提供相关的注释，我们一般使用文档注释），只放在类、接口、成员变量、方法之前（因为Javadoc只处理这些地方的文档注释，而忽略其他地方的文档注释）

  文档注释要按照`javadoc`工具提供的标签进行，以`/**`开始， 以`*/`结束：

  ```java
  /**
   * @author  jlc
   * @version 1.0
   */
  ```

  > 将文档标签生成网页文件的命令：`javadoc -d 存放生成文档标签的文件夹目录地址 -xx -yy 要编译的文件`
  >
  > 对应的`xx`和`yy`，分别是文档注释中使用了的标签：`author`和`version`
  >
  > 文档注释在协作化项目开发过程中使用的是非常多的
  >
  > 文档注释快捷键：`alt`+`shift`+`j`

  文档注释常见的`javadoc`标签有：

  |      标签       |                             描述                             |
  | :-------------: | :----------------------------------------------------------: |
  |    `@author`    |                           作者标识                           |
  |  `@deprecated`  | 标识当前`API`已经过期，仅为了保证兼容性依然存在，以此告之开发者不应再用这个`API` |
  |  `{@docRoot}`   |                   指明当前文档根目录的路径                   |
  |  `@exception`   |                     标志一个类抛出的异常                     |
  | `{@inheritDoc}` |                     从直接父类继承的注释                     |
  |    `{@link}`    |               链接到某个特定的成员对应的文档中               |
  | `{@linkplain}`  |     插入一个到另一个主题的链接，但是该链接显示纯文本字体     |
  |    `@param`     |     方法的入参名及描述信息，如入参有特别要求，可在此注释     |
  |    `@return`    |                      对函数返回值的注释                      |
  |     `@see`      |            引用,查看相关内容，如类、方法、变量等             |
  |    `@serial`    |                      说明一个序列化属性                      |
  |  `@serialData`  |  说明通过`writeObject( )` 和` writeExternal( )`方法写的数据  |
  | `@serialField`  |               说明一个`ObjectStreamField`组件                |
  |    `@since`     |          描述文本,API在什么程序的什么版本后开发支持          |
  |    `@throws`    |                 构造函数或方法所会抛出的异常                 |
  |   `{@value}`    |             显示常量的值，该常量必须是static属性             |
  |   `@version`    |                            版本号                            |

***

### 标识符命名规则和规范

`Java`对各种变量、方法和类等命名时使用的字符序列称为标识符（凡是可以自己起名字的地方都叫标识符）

标识符命名规则（必须遵守的）：

- 由26个英文字母大小写，0-9.`_`或`$`组成

- 不可以以数字开头

- 不可以使用关键字和保留字，但是可以包括关键字和保留字

  `Java`中的关键字：被`Java`语言赋予了特殊的含义，用于专门用途的字符串（单词）

  ![image-20250317214437350](..\images\image-20250317214437350.png)

  ![image-20250317214623428](..\images\image-20250317214623428.png)

  `Java`中的保留字：现有的`Java`版本没有使用，但以后的版本可能会作为关键字使用

  ![image-20250317214751465](..\images\image-20250317214751465.png)

- 严格区分大小写，长度无限制

- 标识符不能包含空格

标识符命名规范（规范可以显得代码更加专业）：

- 包名：多单词组成时所有字母都小写：`aaa.bbb.ccc`
- 类名、接口名：多单词组成时，所有单词的首字母大写：`XxxYyy`（大驼峰形式）
- 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：`xxxYyy`（小驼峰形式，简称驼峰法）
- 常量名：所有字母都大写，多单词时每个单词用下划线连接：`XXX_YYY`

***

### 开发规范

在`Java`开发过程中，我们需要遵守一些开发细节，这样才能减少一些不必要的错误：

1. `Java`应用程序的执行入口是`main()`方法，有固定的书写格式：

   `public static void main(String[] args) {...}`

2. `Java`严格区分大小写

3. `Java`方法由一条语句构成，每个语句以`;`结束

4. 大括号是成对出现的，建议先写`{}`，再写代码

5. 一个源文件中最多只能有一个`public`类，其他类的个数不限，但是，只要有一个类，不管是不是`public`类，在编译后，都会生成一个`.class`文件，即有几个类，就生成几个`.class`文件

6. 如果源文件包含一个`public`类，则文件名必须按照该类进行命名

7. 可以将`main`方法写在非`public`类中，然后指定运行编译后的非`public`类，这样入口方法就是非`public`的`main`方法，也就是说会运行这个类中的入口方法

8. 我们需要确保文件名和主类名保持一致，否则会编译出错

开发规范：

- 对于类、方法的注释，要以`javadoc`的方式来进行编写
- 对于非`javadoc`的注释，往往是给代码的维护者看的，着重告诉读者为什么这么写，如何修改，要注意什么问题等
- 运算符和等号左右各加一个空格
- 源文件使用`utf-8`编码
- 行宽不要超过80个字符

***

### `windows`系统下的`DOS`指令

`DOS`：磁盘操作系统，可以使用指令的方式对文件系统进行操作，常见的指令有：

- `dir`：查看当前目录中有什么

- `tree`：查看指定的目录下所有的子级目录

- `cd`：切换到其他目录    `cd .. `：返回上一级    `cd \`：切换到根目录

  切换到`C`盘：`cd /D c:`

- `md`：新建文件夹（目录）

- `rd`：删除文件夹（目录）

- `cls`：清除终端屏幕中的内容，清屏

- `exit`：退出命令行终端

- `type`：创建文件    `type nul > 文件名`

- `echo`：输入内容到文件中

  `echo hello > hello.txt`   在`hello.txt`文件中就插入了`hello`内容，先创建在写入

- `copy`：复制文件

- `move`：剪切文件

- `del`：删除文件

相对路径：从当前目录开始定位，形成的一个路径

绝对路径：从根目录（顶级目录）开始定位，形成的路径



## 转义字符

`Java`中常见的转义字符有：

- `\t`：一个制表位，实现左对齐的功能

- `\n`：换行符

- `\\`：一个`\`      如果要在控制台中输出两个`\`，需要使用两个斜杠进行转义：`\\\\`

- `\"`：一个`"`

- `\'`：一个`‘`

- `\r`：一个回车

  回车是将光标放到最前面，如`System.out.println("jlc\r1")`，打印的结果就是：`1lc`

  光标回到最前面，在打印1，将第一个字符覆盖掉了



## 进制

对于一个整数，有四种表示方式：

- 二进制：0，1     满2进1    以`0b`或者`0B`开头
- 十进制：0 - 9     满10进1
- 八进制：0 - 7     满8进1    以数字`0`开头
- 十六进制：0 - 9以及A(10) - F(15)  （A-F不区分大小写） 满16进1    以`0x`或者`0X`开头

***

### 进制的转换

进制的转换是程序员的一个基本功

#### 其他进制转十进制

- 二进制转十进制

  从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，再求和

  0b1011 = 1 * 2^0 + 1 * 2^1 + 0 * 2^2 + 1 * 2^3 = 11

- 八进制转十进制

  从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，再求和

  0234 = 4 * 8^0 + 3 * 8^1 + 2 * 8^2 = 156

- 十六进制转十进制

  从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，再求和

  0x23A = 10 * 16^0 + 3 * 16^1 + 2 * 16^2 = 570

#### 十进制转其他进制

- 十进制转二进制

  将该数不断除以2，直到商为0为止，然后将每步得到的余数倒过来，就得到对应的二进制

  34 = 0B100010

  ![image-20250318161833331](..\images\image-20250318161833331.png)

  由于一个字节是有八位的，所以最后的结果位34 = 0B00100010

- 十进制转八进制

  将该数不断除以8，直到商为0为止，然后将每步得到的余数倒过来，就得到对应的八进制

  131 = 0203

  ![image-20250318162118043](..\images\image-20250318162118043.png)

- 十进制转十六进制

  将该数不断除以16，直到商为0为止，然后将每步得到的余数倒过来，就得到对应的十六进制

  237 = 0XED

  ![image-20250318162316565](..\images\image-20250318162316565.png)

#### 其他进制转二进制

- 八进制转二进制

  将八进制的每一位，转成对应的一个3位二进制即可

  0237 = 0b010011111

  由于一个字节是有八位的，所以最后的结果位0237 = 0b10011111

- 十六进制转二进制

  将十六进制的每一位，转成对应的一个4位二进制即可

  0x23B = 0b001000111011

#### 二进制转其他进制

- 二进制转八进制

  从低位开始，将二进制数每三位一组，转成对应的八进制即可

  0b11010101 = 0325

- 二进制转十六进制

  从低位开始，将二进制数每四位一组，转成对应的十六进制即可

  0b11010101 = 0xd5



## 变量

程序中需要变量，我们可以通过不同类型的变量来代表不同的数据，变量是程序的基本组成单位

变量相当于内存中一个数据存储空间的表示，通过变量名，我们可以访问到这个变量的具体值（总之，变量可以代表一个变化的值）

变量有三个基本的要素：类型、名称和值，如`int a = 1;`

- 变量需要先声明，再使用，可以简写声明和赋值在同一行
- 变量的值可以在同一类型中进行不断的变化，即可以重复的进行同一类型的赋值
- 变量是在内存中的一个存储区域，不同类型的变量，占用的空间大小是不同的，如`int`占4个字节，`double`占8个字节
- 变量名在同一个作用域不能重名

***

### 数据类型

`Java`是强类型语言，每一种数据都要明确数据类型

在实际的使用中，有很多的数据类型，对于不同用途的数据，我们声明不同数据类型的变量

#### 基本数据类型

##### 数值型

- 整数类型，用来存放整数：

  - `byte[1]`：`byte`类型（字节），占1个字节，范围-128~127
  - `short[2]`：`short`类型（短整型），占2个字节，范围-32768~32767
  - `int[4]`：`int`类型（整型），占4个字节，范围-2147483648~2147483647
  - `long[8]`：`long`类型（长整型），占8个字节，范围-2^63~2^63-1

  > `bit`是计算机中的最小存储单位，1`byte` =8`bit`，字节`byte`是计算机中的基本存储单位
  >
  > `byte b = 10;`通常情况下，10在`Java`中默认是一个`int`类型，但是当把具体的数赋值给`byte`（`short`类型同理）时，系统会先判断当前值是否在`byte`范围内，如果是，就可以正常的赋值，但是以下的方式是不正确的：
  >
  > ```java
  > int n = 1;
  > byte b = n;   // 编译报错，变量赋值，需要先判断类型
  > ```
  >
  > n在内存中先声明了4个字节大小的存储空间中，但是b声明的存储空间只有1个字节
  >
  > 总之，具体数赋值，先判断范围；变量赋值，先判断类型
  >
  > `Java`的整型常量（具体值）默认为`int`型，声明`long`型常量需后面加上`l`或`L`，如`long n = 1L;`

- 浮点型，用来存放小数：

  - `float[4]`：单精度浮点类型，占4个字节，范围-3.403E38~3.403E38
  - `double[8]`：双精度浮点类型，占8个字节，范围-1.798E308~1.798E308

  > 浮点数在计算机中的存放形式：浮点数=符号位+指数位+尾数位
  >
  > 其中，尾数部分可能丢失，造成精度的损失（小数都是近似值）
  >
  > `Java`的浮点型常量（具体值）默认为`double`型，声明`float`型常量，需后面加`f`或者`F`，如`float n = 1.1F;`（`float n = 1.1;`会报错，不能将`double`类型赋值给`float`类型的变量），大的字节范围不能往小的字节范围内放，但是小的字节范围可以往大的字节范围内放，如`double n = 1.1f;`是正确的，编译不会报错
  >
  > 通常情况下，我们应该使用`double`类型，因为它的精度比`float`型更精确（精度低，会导致过长的小数点后的内容丢失）
  >
  > 浮点型常量有两种表示形式：
  >
  > - 十进制数形式：如：5.12     512.0f    .512（前面的0可以省略，但是必须有小数点）
  > - 科学计数法形式：如：5.12e2（5.12*10的2次方，返回的是512.0，因为是浮点数类型）    5.12E-2
  >
  > 浮点数的使用陷阱：
  >
  > ![image-20250313201321542](..\images\image-20250313201321542.png)
  >
  > 计算机在接收8.1的时候，不能确定8.1小数位的1后面是否还有其他的位数，它可能认为是8.10000001，所以，在计算结果的时候，也是以精度的方式进行返回的
  >
  > 所以说，当我们对小数的运行结果进行相等判断的时候，要格外的注意，应该通过两个数的差值的绝对值，在某个精度范围内进行判断

##### 字符型

- 字符类型：`char[2]`，存放单个字符`'a'`，该类型占两个字节，可以存放一个汉字

> 字符常量是用单引号`''`括起来的单个字符，不能使用双引号，如果使用双引号，就是字符串类型了
>
> 如`char c = "9";`编译器就会报错，字符串类型不能赋值给字符类型的变量
>
> `String`字符串类型，不是基本数据类型，实际上它是一个类，多个字符，我们使用字符串来存放
>
> 在`Java`中，`char`的本质是一个整数，在输出的时候，是`unicode`码对应的字符，字符类型也可以直接存放一个数字：`char c = 97;`，但是输出的是`a`，97在计算机中的`ASSCII`码中对应的是`a`，对于任意的汉字字符，也有具体对应的`unicode`码，如果我们想要将对应的字符转换为对应的`unicode`码，我们将这个字符通过`int`类型进行转化即可得到对应的`unicode`码
>
> `Java`中允许使用转义字符`\`，来将其后面跟着的字符转变为特殊字符型常量，如`char c = '\n';`
>
> `char`类型是可以进行运算的，该类型相当于一个整数，任何字符都要对应的`unicode`码
>
> 字符串的比较，使用到了`equals`的字符串方法：`"jlc".equals(name);`   判断`name`字符串类型的值是不是`“jlc”`，如果是，返回`true`，否则返回`false`

字符类型的本质讨论：字符型数据存储到计算机中，需要将字符对应的码值（整数）找出来，如`'a'`字符：

存储：`'a'`  --->  码值  --->   二进制    --->   存储

读取：二进制   --->   97   --->   `'a'`   --->   显示

##### 布尔型

- `boolean[1]`：布尔类型，占1个字节，只允许取`true`和 `false`

  `boolean`类型适用于逻辑运算

  在`Java`语言中，不能使用0或非0的整数来代替`false`和`true`，这一点和`C`语言是不同的

##### 自动类型转换

当`Java`程序在进行赋值或者运算时，精度小的类型可以自动转换为精度大的数据类型，这个就是自动类型的转换

![image-20250315160649836](..\images\image-20250315160649836.png)

箭头的流向表示低精度向高精度进行转换

在理论上，`int a = 'c';`该语句的语法是错误的，不能将`char`字符类型赋值给`int`数值类型，但是有了自动类型转换，精度低的`char`类型，可以自动的转化为`int`类型，所有`int a = 'c';`该语句在编译的过程中不会报错

低精度的类型，可以连跨级别的向高精度的类型进行自动转换

自动类型转换细节：

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量（精度）最大的那种数据类型，然后再进行计算

2. 当我们把容量（精度）大的数据类型赋值给容量（精度）小的数据类型时，就会报错，反之则会进行自动类型的转换

3. （`byte`、`short`）和`char`之间不会互相自动转换

   ```java
   byte b = 10;
   char c = b;   // 报错，byte类型不会自动转换为char类型
   ```

4. `byte`、`short`和`char`它们三者可以计算，在计算时（不管是单独类型的计算还是混合类型的计算）首先转换为`int`类型

   ```java
   byte b = 1;
   short s1 = 1;
   short s2 = b + s1;   // 报错，运算后，转化成了int类型，不能赋值给精度小的short类型
   
   byte b2 = 1;
   byte b3 = b + b2;   // 报错，byte类型在运算后会转化为int类型
   ```

5. `boolean`类型不参与转换

6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

##### 强制类型转化

强制类型转化是自动类型转换的逆过程，将容量（精度）大的数据类型转换为容量（精度）小的数据类型，使用时需要加上强制转换符`()`，但是，强制类型转换可能会造成精度的降低或溢出，需要格外注意

```java
int i = (int)1.9;    // 强制将double类型转换为int类型，精度损失了，结果输出为1，掉了小数位
```

强制类型转换细节：

1. 强制符号只针对于最近的操作数有效，往往会使用小括号提升优先级

   ```java
   int x = (int)10 * 3.5 + 6 * 1.5;    // 编译不通过，不能将double类型赋值给int类型
   
   int x = (int)(10 * 3.5 + 6 * 1.5);  // 结果为44
   ```

#### 引用数据类型

- 类（`class`）
- 接口（`interface`）
- 数组（`[]`）

#### 基本数据类型和`String`类型的转换

- 基本数据类型转`String`类型，语法：将基本类型的值+`""`即可：

  ```java
  int n = 100;
  float f = 1.1F;
  double d = 4.5;
  bollean b = true;
  // 基本数据类型转String字符串
  String s1 = n + "";
  String s2 = f + "";
  String s3 = d + "";
  String s4 = b + "";
  ```

- `String`类型转基本数据类型，语法：通过基本类型的包装类调用`parseXX`方法：

  ```java
  String s = "123";
  // String字符串转换为基本数据类型
  int n = Integer.parseInt(s);  // 123
  double d = Double.parseDouble(s);  // 123.0
  float f = Float.parseFloat(s);   // 123.0
  Long l = Long.parseLong(s);   // 123
  byte b = Byte.parseByte(s);   // 123
  short s = Short.parseShort(s);  // 123
  boolean b = Boolean.parseBoolean("true");   // true
  ```

  > 使用基本数据类型对应包装类的相应方法进行转换，将字符串类型转换为基本数据类型

  对于将字符串转换成字符`char`类型，是将字符串的第一个字符取下来：

  ```java
  String s = "123";
  s.charAt(0);   // '1'
  ```

  注意：将字符串类型转换成基本的数据类型时，要确保字符串类型能够转成有效的数据，如，不能将字母转换成整数，如果格式不正确，系统会抛出异常

***

### 加号的使用

在程序中，加号有不同的用途：

- 当左右两边都是数值型时，则做加法运算
- 当左右两边有一方为字符串，则做拼接运算

***

### 编码

字符和码值的对应关系是通过字符编码决定的（是规定好的）常见的字符编码表有：

- `ASCII`：一个字节表示，一共表示了128个字符，实际上一个字节可以表示256个字符，但是`ASCII`字符集只使用了128个字符，这个编码是为英文国家创建的，英文只有26个字母，加上一些符号，128个字符足够使用了
- `Unicode`：`ASCII`表的一个扩展（`Unicode`码是兼容`ASCII`码的，同样的`'a'`都是用97来表示），固定大小的编码，使用两个字节来表示字符，字母和汉字统一都是占用两个字节，比较浪费空间
- `utf-8`：大小可变的编码，可以使用1至6个字节来表示一个符号，根据不同的符号而变化字节长度，字母使用一个字节，汉字使用三个字节，在互联网中使用最广的一种`Unicode` 的实现形式
- `gbk`：可以表示汉字，而且范围广，字母使用一个字节，汉字使用两个字节（编码的汉字种类较`utf-8`少，`utf-8`汉字是使用三个字节的，涉及到的汉字种类范围广）
- `big5`：可以表示繁体中文

不同的编码，对文件的大小是有影响的，有的编码汉字是用两个字节表示的，有的编码汉字是用三个字节表示的，会对保存的文件大小造成影响



## 运算符

运算符是一种特殊的符号，用于表示数据的运算、赋值和比较等

### 算数运算符

算数运算符是对数值类型的变量进行运算的，常见的算数运算符有：

![image-20250316101219733](..\images\image-20250316101219733.png)

```java
System.out.println(10 / 4);   // 结果显示2   10和4都是整数，结果也要是整数，会把小数部分去掉
System.out.println(10.0 / 4);  // 结果为2.5
double d = 10 / 4;   // 结果为2.0

System.out.println(10 % 3);   // 结果显示1
System.out.println(-10 % 3);   // 结果显示-1
System.out.println(10 % -3);   // 结果显示1
System.out.println(-10 % -3);   // 结果显示-1
```

> 在`Java`中，`a % b`取模的本质是`a - a / b * b`

```java
// 如果独立使用++，前自增和后自增是一样的
int i = 10;
i++;   // 等价于 i = i + 1
++i;   // 等价于 i = i + 1
System.out.println(i);  // 结果显示12

// 如果自增作为表达式使用，前++：先自增后赋值；后++：先赋值后自增
int i = 8;
int k = ++i;   // k为9，i为9
int j = 8;
int h = j++;   // h为8，j为9
```

***

### 关系运算符

关系运算符也叫比较运算符，运算结果都是`boolean`类型，也就是要么是`true`，要么是`false`

关系运算符经常用在`if`结构的条件中或循环结构的条件中，常见的关系运算符有：

![image-20250316110533527](..\images\image-20250316110533527.png)

关系运算符组成的表达式，我们称为关系表达式

***

### 逻辑运算符

逻辑运算符是用于连接多个条件（多个关系表达式），最终的结果也是一个布尔类型

逻辑运算符有两种形式：

![image-20250316111346482](..\images\image-20250316111346482.png)

逻辑运算符规则：

- 逻辑与：`a & b`，当`a`和`b`同时为真时，结果为真，否则为假

- 逻辑或：`a | b`，当`a`和`b`有一个为真时，结果为真，否则为假

- 逻辑非：`!a`，取反运算，当`a`为真时，结果为假

- 短路与：`a && b`，当`a`和`b`同时为真时，结果为真，否则为假，如果`a`为假，则`b`语句将不会执行判断

  ```java
  int a = 4;
  int b = 9;
  if (a < 1 && ++b < 50) {
      System.out.println('ok');    // 不执行
  }
  System.out.println(a, b);   // 结果显示4,9
  ```

  但是对于逻辑与来说，如果`a`为假，`b`语句还会进行判断：

  ```java
  int a = 4;
  int b = 9;
  if (a < 1 & ++b < 50) {
      System.out.println('ok');    // 不执行
  }
  System.out.println(a, b);   // 结果显示4,10
  ```

- 短路或：`a || b`，当`a`和`b`有一个为真时，结果为真，否则为假，如果`a`为真，则`b`语句将不会执行判断

  但是对于逻辑或来说，如果`a`为真，`b`语句还会进行判断

- 逻辑异或：`a ^ b`，当`a`和`b`不同时，结果为真，否则为假

> - 在开发中，基本上都是使用短路与为主，因为前一个为假，后面的就不在判断执行了，效率高
> - 在开发中，基本上都是使用短路或为主，因为前一个为真，后面的就不在判断执行了，效率高

***

### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量

- 基本赋值运算符  `=`
- 复合赋值运算符  `+=`、`-=`、`*=`、`/=`、`%=`

注意事项：

- 赋值运算符的运算顺序是从右往左

- 赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值

- 复合赋值运算符会进行类型的强制转换

  ```java
  byte b = 2;
  b += 3;   // 等价于 b = (byte)(b + 3);    b + 3的类型是int，如果没有进行类型转换是编译不了的
  ```

***

### 三元运算符

基本语法：`条件表达式 ? 表达式1 : 表达式2;`

如果条件表达式为`true`，运算后的结果是表达式1；如果条件表达式为`false`，运算后的结果是表达式2

如果执行了表达式1，那么表达式2是不会执行的，反之同理

注意事项：

- 表达式1和表达式2要为可以赋给接收变量的类型（或可以进行自动转换）

  ```java
  int a = 3;
  int b = 4;
  int c = a > b ? 1.1 : 3.4;     // 报错，编译不通过，double类型不能赋值给int类型
  double d = a > b ? a ; b;  // 不会报错，可以进行自动的类型转换，int类型可以自动转化到double类型
  ```

***

### 位运算符

计算机内部处理信息都是采用二进制数来表示

原码、反码和补码的概念：

对于有符号的数而言，有以下的八个规则（要背下来）：

1. 二进制的最高位是符号位：0表示正数；1表示负数
2. 正数的原码、反码和补码都一样
3. 负数的反码=它的原码符号位不变，其他位取反
4. 负数的补码=它的反码+1；   负数的反码=负数的补码-1
5. 0的反码、补码都是0
6. `Java`没有无符号数，也就是说`Java`中的数都是有符号的
7. 在计算机运算的时候，都是以补码的方式进行运算的（补码可以解决正数和负数）
8. 当我们看运算结果的时候，要看他的原码

常见的位运算符有：位运算符的使用，先将两边的值先全部转成二进制，再得到这个二进制的补码，最后参与运算，运算后的结果先转回二进制的原码，再转回十进制

- `~`按位取反：0变1，1变0

  ~-2的运算过程：

  ![image-20250318205143135](..\images\image-20250318205143135.png)

  ~2的运算过程：

  ![image-20250318205419910](..\images\image-20250318205419910.png)

- `&`按位与：两位全为1，结果为1，否则为0

  2 & 3的运算过程：由于是`int`类型，占4个字节

  ![image-20250318204848579](..\images\image-20250318204848579.png)

- `|`按位或：两位有一个为1，结果为1，否则为0

- `^`按位异或：两位一个为0一个为1，结果为1，否则为0

- `>>`算数右移：低位溢出，符号位不变，并用符号位补溢出的高位

  `1 >> 2;`结果为0，表示将十进制的1先转为二进制，再向右位移两位，本质就是`1/2/2`

- `<<`算数左移：符号位不变，低位补0

  ``1 << 2;`结果为4，表示将十进制的1先转为二进制，再向左位移两位，本质是`1*2*2`

- `>>>`无符号右移：低位溢出，高位补0

***

### 运算符的优先级

运算符有不同的优先级，下图中的运算符优先级从高到低依次为：

![image-20250317203153087](..\images\image-20250317203153087.png)

只有单目运算符、赋值运算符是从右往左的，其他运算符都是从左到右的

优先级由高到低大致优先级分类为括号、单目运算符、算数运算符、位移运算符、比较运算符、逻辑运算符、三元运算符、赋值运算符



## 键盘输入语句

在编程中，需要接收用户输入的数据，我们可以使用键盘输入语句来进行获取

使用键盘输入语句需要使用一个扫描器对象（`Scanner`）

```java
import java.util.Scanner;    // 将包java.util下的Scanner类进行导入
pubilc class Input {
    public static void main(String[] args) {
        // 创建Scanner对象
        Scanner myScanner = new Scanner(System,in);
        // 接收用户的输入，使用相关的方法
        System.out.println("请输入名字");
        String name = myScanner.next();   // 程序执行到这句话时，会等待用户进行输入
        
        System.out.println("请输入年龄");
        int age = myScanner.nextInt();
        
        System.out.println("请输入成绩");
        double score = myScanner.nextDouble();
    }
}
```



## 控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，控制结构主要有三大流程控制语句

### 顺序控制

程序从上到下逐行执行，中间没有任何判断和跳转，顺序控制是程序默认的控制语句

***

### 分支控制

#### `if else`分支

分支控制是让程序有选择（根据判断进行选择）的执行，分支控制有三种形式：

- 单分支

  基本语法：

  ```java
  if(条件表达式) {
      执行代码块;
  }
  ```

  > 当条件表达式为`true`时，就会执行`{}`的代码，如果`{}`中只有一条语句，可以不使用`{}`进行包裹

- 双分支

  基本语法：

  ```java
  if(条件表达式) {
      执行代码块1;
  }
  else {
      执行代码块2;
  }
  ```

  > 当条件表达式为`true`时，执行代码块1，否则执行代码块2

- 多分支

  基本语法：

  ```java
  if(条件表达式1) {
      执行代码块1;
  }
  else if(条件表达式2) {
      执行代码块2;
  }
  ...
  else {
      执行代码块n;
  }
  ```

  > 当对应的表达式为`true`时，执行对应的代码块，如果条件表达式都不成立，则执行代码块n
  >
  > 多分支可以没有`else`，如果所有的条件表达式都不成立，则一个执行入口都没有

嵌套分支：在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支，但是建议分支不要超过3层，因为可读性不好

基本语法：

```java
if(条件表达式1) {
    if(条件表达式2) {
        执行代码块2;
    }
    else {
        执行代码块3;
    }
}
```

#### `switch`分支

基本语法：

```java
switch(表达式) {
    case 常量1:
        语句块1;
        break;
    case 常量2:
        语句块2;
        break;
    default:
        default语句块;
        break;
}
```

> 如果表达式的结果和`case`常量1匹配，就执行语句块1，如果没有匹配，就继续和`case`常量2进行匹配，以此类推，如果一个都没有匹配上，执行`default`语句块
>
> `break`表示退出`switch`语句
>
> 如果执行完一个`case`语句块后，没有执行`break`语句，那么不会退出`switch`语句，会继续进行后面`case`的语句块，不需要进行匹配，会直接穿透执行，同时，如果前面没有`break`的话还会执行`default`的语句块
>
> 对于`default`匹配项，有没有`break`是无所谓的，执行了`default`语句块都会退出`switch`语句

注意细节：

- 表达式的数据类型，应该和`case`后面的常量类型一致，或者是可以自动转换成可以相互比较的类型（如输入的是字符，而常量是`int`）

- `switch`（表达式）中表达式的返回值必须是

  ```java
  double c = 1.1;
  switch(c) {   // 报错double类型不能使用
      case 1.1:
          ...
  }
  ```

- `case`句子中的值必须是常量（具体的值），或者是计算表达式（得到的也是常量），不能是变量

- `default`句子是可选的，当没有匹配的`case`时，执行`default`

- `break`语句用来执行完一个`case`分支后使程序跳出`seitch`语句块，如果没有写`break`，程序会顺序执行到`switch`结尾

#### `if`和`switch`使用的选择

- 如果判断的具体数值不多，而且符合（`byte`、`short`、`int`、`char`、`enum`、`String`）这六种类型，建议使用`switch`语句
- 其他情况，对区间判断，对结果为`boolean`类型判断，使用`if`语句，`if`语句的使用范围更广

***

### 循环控制

循环控制就是让代码可以循环的执行

#### `for`循环

基本语法：

```java
for(循环变量初始化;循环条件;循环变量迭代) {
    循环操作(语句);
}
```

> 如果循环条件为`true`，就会执行一次循环操作

注意事项：

- 循环条件是返回一个布尔值的表达式

- `for(;循环条件;)`中的初始化和变量迭代可以其它地方，但是两边的分号不能省略

  ```java
  int i = 1;
  for(;i <= 10;) {
      循环操作(语句);
      i++;
  }
  ```

- 循环的初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

  ```java
  int count = 3;
  for(int i = 0, j = 0; i < count; i++, j += 2) {
      System.out.println(i, j);     // 0,0   1,2   2,4
  }
  ```

  编程思想：化繁为简（将复杂的需求先拆分一个个简单的需求，逐步完成），先死后活（先考虑固定的值，再转成可以灵活变化的值）

#### `while`循环

基本语法：

```java
循环变量初始化;
while(循环条件) {
    循环体(语句);
    循环变量迭代;
}
```

注意事项：

- 循环条件是返回一个布尔值的表达式
- `while`循环是先判断，再执行语句

#### `do..while`循环

基本语法：

```java
循环变量初始化;
do {
    循环体(语句);
    循环变量迭代;
}while(循环条件);
```

注意事项：

- `do..while`循环是先执行，再判断，也就是说至少会执行一次

#### 多重循环控制

将一个循环放在另一个循环体内，就形成了嵌套循环，一般建议使用两层即可，最多不要超过三层，否则代码可读性大大降低

实际上，嵌套循环就是把内层循环当外层循环的循环体，当只有内存循环的循环条件为`false`时，才会完全跳出内层循环，才可以结束外层的当次循环，开始外层的下一次循环

设置外层循环次数为`m`次，内层循环为`n`次，则内层循环体一共执行`m*n`次

```java
// 打印空心金字塔
public class HollowPyramids {
	public static void main(String[] args) {
		int totalLevel = 5;
		for(int i = 1; i <= totalLevel; i++) {
			for(int k = 1; k <= totalLevel - i; k++) {
				System.out.print(" ");
			}
			for(int j = 1; j <= 2 * i - 1; j++) {
				if (j == 1 || j == 2 * i - 1 || i == totalLevel) {
					System.out.print("*");
				}
				else {
					System.out.print(" ");
				}
			}
			System.out.println(" ");
		}
	}
}
```

> `System.out.print("*");`表示输出后不换行
>
> `System.out.println("*");`表示输出后换行

#### `break`关键字

在循环语句的流程控制中，我们可以使用`break`语句来终止某个语句块的执行

基本语法：

```java
{
    ...
    break;
}
```

> 执行到`break`时跳出整个循环，用于提前终止循环
>
> ```java
> for(int i = 0; i < 10; i++) {
>     if(i == 3) {
>         break;
>     }
>     System.out.print(i);
> }
> // 结果输出  012
> ```

`break`语句出现在多层嵌套语句块中时，可以通过标签指明要终止的是哪一层语句块

```java
label1: {   ......
label2:		{   ......
label3:			{   ......
    				break label2;
                 	......
				}    
			}    
        }
```

> `break`语句可以指定退出到哪层
>
> `label1`是标签，名称由程序员指定，`break`后指定到哪个`label`，就退出到哪里
>
> 如果没有指定`break`，则默认退出最近的循环体
>
> 在实际开发中，尽量不要使用标签，会导致可读性变差

#### `continue`关键字

`continue`语句用于结束本次循环，继续执行下一次循环

基本语法：

```java
{
    ...   
    continue;
    // 执行了continue语句，本次循环后面的内容就不执行了
}
```

如果`continue`语句出现在多层嵌套的循环语句体中，可以通过标签指明要跳出哪一层循环

#### `return`关键字

`return`通常与方法函数一起使用，表示跳出所在的方法，如果`return`写在`main`方法中，会退出主程序



## 数组

数组可以存放多个同一类型的数据，数组也是一种数据类型，是引用类型

数组就是一组数据

数组的定义：

```java
double[] newArray = {1.2, 2, 3.5};
```

> `double[] newArray `等价于`double newArray[] `
>
> `double[]`表示声明`double`类型的数组，数组中的数据都应该是`double`类型
>
> `newArray`表示定义的数组名
>
> `{1.2, 2, 3.5}`表示数组的值（数组的元素），我们可以通过元素的下标来进行数组中具体元素的访问`[i]`
>
> 下标是从0开始编号的，表示数组中的第一个元素

数组可以通过`for`循环进行遍历，从而读取数组中的每个元素：

```java
double[] newArray = {1.2, 2, 3.5};
for (int i = 0; i < newArray.length; i++) {
    System.out.println(newArray[i]);
}
```

注意事项：

- 数组是多个相同类型数据的组合，实现对这些数据的统一管理

- 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但不能混用

  如果满足自动类型转换的，那么可以混合使用

- 数组创建后，如果没有赋值，有默认值，不同的类型默认值不一样：`int 0`、`short 0`、`byte 0`、`long 0`、`float 0.0`、`double 0.0`、`char \u0000`、`boolean false`、`String null`

- 使用数组的步骤：1.声明数组并开辟空间；2.给数组各个元素赋值；3.使用数组

- 数组的下标是从0开始的

- 数组下标必须在指定范围内使用，下标的最大值是数组的长度减一，否则会报错：下标越界异常

- 数组属于引用类型，数组的数据类型是对象`object`

***

### 动态初始化

动态初始化方式一：`数据类型 数组名[] = new 数据类型[大小];`

如：`int a[] = new int[5];`   创建了一个数组，名字为`a`，存放5个`int`类型的数据，变量`a[0]`就指向了数组中的第一个元素

动态初始化方式二：

- 先声明数组：`数据类型 数组名[];`      如：`int a[];`   内存中有了数组`a`变量，但是是空值，没有返回空间
- 再创建数组：`数组名 = new 数据类型[大小];`     如：`a = new int[10];`    内存中开辟了空间

***

### 静态初始化

直接在声明的时候给定具体的值：`数据类型 数组名[] = {元素值, 元素值, ...};`

***

### 数组赋值机制

对于基本数据类型赋值，这个值就是具体的数据，且互相不影响，这种赋值方式为值拷贝，但是对于数组进行赋值，数组在默认情况下是引用传递，赋的值是地址，赋值方式为地址拷贝或者引用拷贝

```java
int arr1[] = {1, 2, 3};
int arr2[] = arr1;     
arr2[0] = 10; // arr1数组的第一个值也变成了10，数组arr2的变化会影响arr1的变化，两个数组共有一共内存地址
```

从内存地址的角度进行分析：

![image-20250322211151308](..\images\image-20250322211151308.png)

> 在`jvm`中，内存由三个部分组成：栈、堆和方法区
>
> 对于值传递\值拷贝：会在栈中开辟一块空间（基本类型的存储都是在栈中开辟空间的），如果将`n1`赋值给`n2`，会将值拷贝一份，放到一个新开辟的内存空间，后续`n2`的值发生改变，不会对`n1`的值造成任何影响
>
> 对于引用传递\地址拷贝：数组会在栈中开辟一块空间，用于存放地址，地址的具体内容在堆中存放，通过地址可以访问到堆中的数据，如果数组进行赋值，会将地址进行拷贝，但是指向的还是同一个区域，所有对`arr2`数组的内容进行修改，会影响`arr1`的内容

***

### 数组的拷贝

经过数组的赋值机制，我们知道，我们对数组的赋值只是地址拷贝，两个数组公用一个内存地址

如果我们就想要得到一个完整的数组，我们需要进行数组的拷贝，这样两个数组的数据空间是独立的

```java
int arr1[] = {10, 20, 30};
// 为arr2开辟一个新的数据空间，大小和arr1数组一样
int arr2[] = new int[arr1.length];
for(int i = 0; i < arr1.length; i++) {
    arr2[i] = arr1[i];
}
```

***

### 数组的反转

将数组中的元素值进行反转，第一个元素变成最后一个

常见方法：

```java
int arr[] = {11, 22, 33, 44, 55, 66};
int length = arr.length;
int temp = 0;
for(int i = 0; i < length / 2; i++) {
    temp = arr[length - 1 - i];  // 使用临时变量进行保存
    arr[arr.length - 1 - i] = arr[i];
    arr[i] = temp;
}
```

逆序遍历：创建一个相等大小的新数组，逆序遍历，顺序拷贝，最后将原数组进行指向（原数组就会被垃圾回收）

```java
int arr[] = {11, 22, 33, 44, 55, 66};
int arr2[] = new int[arr.length];
for(int i = arr.length - 1; i >= 0; i--) {
    arr2[arr2.length - i] = arr[i]; 
}
arr = arr2;
```

***

### 数组的扩容

数组的扩容也叫数组的添加，可以实现动态的给数组添加元素，实现对数组的扩容

我们需要定义一个新的数组，其数组的大小是原先数组大小加一，将原数组的数组值依次进行拷贝，最后一个数组值存放新的内容，最后将原数组进行指向这个新的数组：

```java
int arr[] = {1, 2, 3};
int arr2[] = new int[arr.length + 1];
for(int i = 0; i < arr.length; i++) {
    arr2[i] = arr[i];
}
arr2[arr2.lengh - 1] = 4;
arr = arr2;
```

数组的缩减和数组的扩容思路类似

***

### 排序

排序是将多个数据，依指定的顺序进行排序的过程

排序的分类：

- 内部排序：将需要处理的所有数据都加载到内部存储器中进行排序，包括：交换式排序法、选择式排序法和插入式排序法
- 外部排序法：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序，包括：合并排序法和直接合并排序法

#### 冒泡排序法

通过对待排序序列从前向后（从下标小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就像水底下的气泡一样逐渐向上冒

![image-20250324203453472](..\images\image-20250324203453472.png)

> 有多少个元素，就进行了几轮的排序（可以看成是外层循环），每一轮排序会确定一个数的位置（如第一轮排序确定最大数，第二轮排序确定第二大的数）
>
> 当进行比较时，如果发现前面的数大于后面的数，就交换两个数的位置
>
> 每一轮的比较在逐渐减小（因为每一轮比较的数据量在减小）

代码实现：

```java
int arr[] = {24, 69, 80, 57, 13};
int temp = 0;
for (int i = 0; i < arr.length - 1; i++) {
    for (int j = 0; j <  arr.length - 1 - i; j++) {
        if(arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }
    System.out.println("\n==第" + (i + 1) + "轮排序==");
    for(int j = 0; j < arr.length; j++) {
        System.out.print(arr[j] + "\t");
    }
}
```

***

### 查找

在`java`中，常见的查找方式有两种：

1. 顺序查找：先和第一个元素进行比较，如果不匹配，再和下一个元素进行比较，如果找到了，就将结果返回即可
2. 二分查找：对一个排列从小到大的有序数组进行查找，先查找中间这个数，如果匹配就返回，如果不匹配，就和中间这个数进行判断大小，如果要查找的数组比中间这个数大，就往右边（后面）查找，依次二分类推

***

### 二维数组

对于一维数组中的每一个元素，如果这个元素还是一个数组，我们将这个数组称为二维数组

动态初始化：`类型[][] 数组名 = new 类型[大小][大小];`    如：`int a[][] = new int[2][3];`

> 第一个大小表示包含几个一维数组；第二个大小表示一维数组中包含几个元素

定义二维数组（静态初始化）：`数据类型 数组名[][] = {一维数组, 一维数组};`    其中`[][]`可以写在数据类型的后面，二维数组的每一个元素都是一个一维数组，二维数组中只能放一维数组，不能放其他基本类型的数据

输出二维数组：

```java
int arr[][] = {{1, 2}, {2, 3}};
for(int i = 0; i < arr.length; i++) {   // 统计多少个一维数组
    // 遍历二维数组的每个元素
    // arr[i]表示二维数组的第i个元素
    // arr[i].length表示得到对应的一维数组的长度
    for(int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j]);
    } 
    System.out.println();  // 换行
}
```

> 对于二维数组，如果要访问第(i+1)个元素的第(j+1)个值，我们应该这样访问：`arr[i][j]`

二维数组在内存中的存在形式：（重要）

![image-20250325100957997](..\images\image-20250325100957997.png)

> 二维数组在栈中，通过一个地址指向堆中的一个空间，该空间中存放的还是地址，用于被一维数组进行指向，一维数组通过地址指向堆中的另一个空间，这个空间中存放具体的值

二维数组动态初始化--列数不确定方式：在`Java`中允许二维数组中的一维数组的长度可以不相同

创建如下方式的二维数组：（一共有三个一维数组，每个一维数组的长度不一致）

![image-20250325101414605](..\images\image-20250325101414605.png)

```java
int[][] arr = new int [3][];  // 创建了二维数组，一共有3个一维数组，但是列数不确定
for(int i = 0; i < arr.length; i++) {   // 遍历arr每个一维数组
    // 给每个一维数组开辟空间，如果没有给一维数组new，那么arr[i]就是null
    arr[i] = new int[i + 1];
    
    // 遍历一维数组，并给一维数组的每个元素赋值
    for(int j = 0; j < arr[i].length; j++) {
        arr[i][j] = i + 1;   // 赋值
    }
}
```

输出10行的杨辉三角：

```java
int arr[][] = new int[10][];
for(int i = 0; i < arr.length; i++) {
    arr[i] = new int[i + 1];
    for(int j = 0; j < arr[i].length; j++) {
        if(j == 0 || j == arr[i].length - 1) {
            arr[i][j] = 1;
        }
        else {
            arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
        }
    }
}
```

注意事项：

- 对于二维数组的声明方式，有以下几种合法的方法：`int[][] arr`、`int[] arr[]`和`int arr[][]`
- 二维数组的本质是由多个一维数组构成的，它的各个一维数组的长度可以相同，也可以不相同



## 类与对象

单独使用定义变量的方式和数组的方式进行大量数据的管理，效率低下

在面向对象中，我们使用对象来体现各种各样的事物，对象中有两个关键的内容：属性（内在的特征，与自身关联，如年龄，名字等）和行为（行为方法。如修改名称等），将属性提取出来，就形成了一个类（类是一个数据类型）

类与对象的关系示意图：

![image-20250327104828374](..\images\image-20250327104828374.png)

> 将猫类的所有属性提取出来，形成一个猫类的数据类型（自己定义的数据类型，`int`是`Java`系统提供的数据类型），这个数据类型有以下常用的属性：`name`、`age`等，当然所有的猫都有行为，如：跑、叫和吃等
>
> 对于一个猫类，我们可以使用这个类定义许多的猫，这些猫就是对象（简而言之，我们可以通过猫类来创建猫对象，即创建一只具体的猫）

```java
// 定义一个猫类（自定义的数据类型）
class Cat {
    String name;
    int age;
    String color;
}

// 使用OOP面向对象解决
// 实例化一只猫对象
Cat cat1 = new Cat();
// 为对象添加属性
cat1.name = "小白";
cat1.age = 3;
cat1.color = "白色";
```

综上所述：类就是一个数据类型，对象就是一个具体的实例，从类到对象有几种说法：

- 创建了一个对象
- 实例化一个对象
- 把类实例化

***

### 对象的内存布局

`Java`内存的结构分析：

- 栈：一般存放基本数据类型（局部变量）
- 堆：存放对象（自定义类，数组等）
- 方法区：常量池（常量、比如字符串），类的加载信息（自定义的类信息只会加载一次）

对象在内存中的存在形式（重要）：

![image-20250327111603422](..\images\image-20250327111603422.png)

> 字符串是一个引用类型，在堆中存放的是地址，实际上将数据放在方法区中的常量池中，基础数据类型的值会直接存放到堆中
>
> 在执行实例化对象的时候，会将类的信息（属性信息和方法信息）加载到方法区中
>
> `Java`创建对象流程的简单分析：
>
> 1. 先加载`Cat`类信息（属性和方法信息，只会加载一次）
> 2. 在堆中分配空间，进行默认初始化（和数组初始化类似）
> 3. 把地址赋值给`cat`（创建的对象名），对象名就指向这个对象
> 4. 进行指定初始化，如`cat.age = 12;`

将实例化的对象赋值给另一个对象名，`Person p2 = p1;`   把`p1`赋值给了`p2`，或者说让`p2`指向`p1`，是引用类型，实现的是地址拷贝，指向的都是同一个堆中的对象，其内存分配过程如下：

![image-20250327131535351](..\images\image-20250327131535351.png)

小练习：

![image-20250327132602592](..\images\image-20250327132602592.png)

***

### 属性的概念

属性也叫成员变量，或者叫`field`字段，属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象、数组）

```java
public class Object {
    // main方法
    public static void main(String[] args) {
        // 实例化一个对象
        // cat1是对象名，new Cat()是真正的对象，在堆中创建了对象空间，将地址与对象名的指向地址联系起来
        Cat cat1 = new Cat();
        // 访问属性
        cat1.name;
    }
}

// 定义一个猫类（自定义的数据类型）
class Cat {
    // 定义属性/成员变量
    String name;
    int age;
    String color;
    String[] master;  // 属性可以是引用数据类型
}
```

注意事项：

- 属性的定义语法同变量的定义，但是多了一个访问修饰符的概念：`访问修饰符 属性类型 属性名;`

  访问修饰符是用于控制属性的范围，有四种访问修饰符：`public`、`proctected`、`默认情况`、`private`

- 属性的定义类型可以为任意类型，包含基本类型或引用类型

- 属性如果不赋值，有默认值，规则和数组一致

***

### 方法的概念

成员方法的定义：

```java
访问修饰符 返回的数据类型 方法名(形参列表..) {
    方法体语句;
    return 返回值;
}
```

> - 访问修饰符：控制方法的使用范围，常用的方法修饰符有四个
>
> - 形参列表：表示成员方法的输入
>
>   - 一个方法可以有0个参数，也可以有多个参数，中间使用逗号隔开
>   - 参数类型可以为任意类型，包含基本类型或引用类型，同一列表的参数类型可以是不同的类型
>   - 调用参数的方法时，一定对应着参数列表传入相同类型或兼容类型（可以进行自动转换）的参数
>   - 方法定义时的参数称为形式参数，简称行参；方法调用时传入的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数、顺序必须一致
>
> - 返回的数据类型：表示成员方法输出，`void`表示没有返回值，返回的类型可以为任意类型，包含基本类型和引用类型，但是接收返回值时，需要声明与返回值同类型的变量去接收
>
>   一个方法最多只有一个返回值，如果需要多个返回值，我们可以返回数组
>
>   ```java
>   // 返回两个数的和差
>   class Num {
>       public int[] getSumAndSub(int n1, int n2) {
>           int res[] = new int[2];
>           res[0] = n1 + n2;
>           res[1] = n1 - n2;
>           return res;
>       }
>   }
>   ```
>
> - 方法主体：表示为了实现某一功能代码块，可以为输入、输出、运算、分支、循环、方法调用，但是在方法主体中不能再定义方法，即：方法不能嵌套定义
>
> - `return`语句不是必须的，如果方法要求有返回数据类型，则方法体中最后的执行语句必须为`return`值，而且要求返回值类型必须和`return`的值类型一致或者兼容（可以自动转换的）
>
>   ```java
>   // 类型一样，编译通过
>   public double f1() {
>       return 1.1;
>   }
>         
>   // 兼容（可以自动转换），编译通过
>   public double f1() {
>       int n = 1;
>       return n;
>   }
>         
>   // 类型不一致，且不能自动转换，编译不通过
>   public int f1() {
>       return 1.1;
>   }
>   ```
>
>   如果方法是`void`，则方法中可以没有`return`语句，或者只写`return;`，但是不能返回具体的内容

成员方法简称为方法，用于声明一些具体的行为

```java
public class Object {
    // main方法
    public static void main(String[] args) {
        // 实例化一个对象
        Person person1 = new Person();
        // 调用方法
        person1.speak();
        person1.cal(6);
        int data = person1.getSum(3, 6);  // 将方法返回的值赋给data
    }
}

// 定义一个猫类（自定义的数据类型）
class Person {
    // 定义属性/成员变量
    String name;
    int age;
    // 定义方法/成员方法
    // public表示方法是公开的；void表示方法没有返回值；speak表示方法名
    public void speak() {
        System.out.println("我是一个好人");
    }
    // (int n)表示形参列表，表示当前有一个形参n，可以接收调用者的输入
    public void cal(int n) {
        int res = 0;
        for(int i; i <= n; i++) {
            res += i;
        }
        System.out.println("计算结果=" + res);
    }
    // 方法有返回值的形式
    // int表示方法执行后，返回一个int值
    public int getSum(int num1, int num2) {
        int res = num1 + num2;
        return res;
    }
}
```

方法调用机制的原理图：（重要）

![image-20250327135857719](..\images\image-20250327135857719.png)

首先会在栈中创建一个栈空间（`main`栈空间），当执行了方法时，会在开辟一个独立的栈空间（栈和栈之间不会相互影响），进行形参的赋值，执行完方法后，会将结果进行返回，当返回之后，这个临时开辟的独立栈空间就会被释放

成员方法的好处：减少代码冗余，提高了代码的复用性；同时可以将实现的细节封装起来，然后供其他用户来调用

方法调用细节：

- 同一个类中的方法调用：直接调用即可

  ```java
  class A {
      public void print(int n) {
          System.out.println("print()方法被调用 n=" + n);
      }
      
      public void sayOk() {
          // 调用同一个类中的print()方法
          print(10);
      }
  }
  ```

- 跨类中的方法A类调用B类的方法：需要通过对象名调用，跨类的方法调用共和方法访问修饰符相关

  ```java
  class A {
      public void print(int n) {
          System.out.println("print()方法被调用 n=" + n);
      }
  }
  
  class B {
      public void sayOk() {
          // 创建一个A类的对象
          A a = new A();
          // 调用a对象的方法
          a.print(10);
      }
  }
  ```

#### 方法的传参机制

方法的传参机制在编程中是非常重要的：

- 对于基本数据类型的传参机制，传递的是值（值拷贝），形参的任何改变不影响实参

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          int a = 10;
          int b = 20;
          // 实例化AA对象
          AA obj = new AA();
          obj.swap(a, b);
          System.out.prinln(a, b);    // 10 20
  	}
  }
  
  class AA {
      public void swap(int a, int b) {
          System.out.prinln(a, b);   // 10 20
          int temp = a;
          a = b;
          b = temp;
          System.out.prinln(a, b);   // 20 10
      }
  }
  ```

  通过内存来进行辅助理解：

  调用`obj.swap(a, b);`方法，传递的是10和20，`swap()`方法中接收的是10和20，两个栈是独立的空间，其基本数据类型的变量是不冲突的

- 对于引用数据类型的传参机制，传递的是地址（传递的也是值，但这个值是地址），形参的改变会影响实参

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          int[] arr = {1, 2, 3};
          BB obj = new BB();
          obj.test(arr);    // 200 2 3
          
          // 遍历数组
          for(int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + "\t");
          }
          System.out.println();    // 200 2 3
  	}
  }
  
  class BB {
      public void test(int arr) {
          arr[0] = 200;   // 修改了传递进来的数组元素
          // 遍历数组
          for(int i = 0; i < arr.length; i++) {
              System.out.print(arr[i] + "\t");
          }
          System.out.println();
      }
  }
  ```

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          Person p = new Person();
          p.name = "jlc";
          p.age = 25;
          BB b = new BB();
          b.test(p);
          System.out.println(p.age);   // 100
  	}
  }
  
  class Person {
      String name;
      int age;
  }
  
  class BB {
      public void test(Person p) {
          p.age = 100;
      }
  }
  ```

  小变化：

  ```java
  public class MethodParameter {
  	public static void main(String[] args) {
          Person p = new Person();
          p.name = "jlc";
          p.age = 25;
          BB b = new BB();
          b.test(p);
          System.out.println(p.age);   // 10
  	}
  }
  
  class Person {
      String name;
      int age;
  }
  
  class BB {
      public void test(Person p) {
          p = null;
      }
  }
  ```

  `BB`类中的将传入的`p`对象设置为`null`，是切断了当前方法栈空间中的`P`指向的堆中的对象，但是不会影响原先`main`栈空间中`p`的指向，`p`还是指向堆中的对象，因此，其值还是25

  ![image-20250327211100538](..\images\image-20250327211100538.png)

#### 方法的递归调用

递归调用就是方法调用自己，每次调用时传入不同的变量，递归有助于解决复杂的问题，同时让代码更简洁

递归调用的本质仍然是方法的调用

递归使用规则：

- 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
- 一般传递的是基本类型数据，所以方法的局部变量是独立的，不会相互影响
- 如果方法中使用的是引用类型的变量，如数组，就会共享该引用类型的数据
- 递归必须向退出递归的条件逼近，否则就是无限递归
- 当一个方法执行完毕，或者遇到`return`，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕了，开辟的空间也会清除掉

![image-20250328131533079](..\images\image-20250328131533079.png)

每一次调用方法的递归，都会在栈空间中开辟一块方法空间，当方法执行完后，方法空间会消失，同时会返回到上一个调用空间，在哪里调用就返回给哪里，依次递归的返回，最后返回到`main`方法中，执行完后退出

##### 阶乘

```java
// 递归调用---阶乘
public int factorial(int n) {
    if(n == 1) {
        return 1;
    }
    else {
        return factorial(n - 1) * n;
    }
}
```

![image-20250328133518263](..\images\image-20250328133518263.png)

##### 斐波那契

斐波那契是指，一个数为前面两个数的和

```java
// 递归调用---斐波那契
public int fibonacci(int n) {
    if(n == 1 || n == 2) {
        return 1;
    }
    else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}
```

#### 方法的重载

在`Java`中允许同一个类中有多个同名方法的存在，但要求形参列表不一致，方法重载有利于减轻了起名和记名的麻烦，如系统定义的`System.out.println()`方法，方法名都是`println()`，但是可以输出数值，字符串等，是由于使用了方法的重载，设置了同名的方法，但是传递的形参列表不一致

```java
class MyCalculator {
    // 计算两个整数的和
    public int calculate(int n1, int n2) {
        return n1 + n2;
    }
    // 计算一个整数，一个浮点数的和
    public double calculate(int n1, double n2) {
        return n1 + n2;
    }
}
```

方法重载的注意事项：

- 方法名必须相同
- 形参列表必须不同（形参类型或个数或顺序，至少有一个是不同的，参数名无要求）
- 返回类型无要求（返回类型不是构成方法重载的条件）

#### 可变参数

`Java`允许将同一个类中多个同名同功能但参数个数不同的方法，重载成一个方法，但是这样要不断的重复编写，对于这个问题，我们可以通过可变参数进行简化

可变参数的基本语法：

```java
访问修饰符 返回类型 方法名(数据类型... 形参名) {}

// 对传入的所有参数进行求和
// int...表示接收的是可变参数，类型为int类型，可以接收多个int类型的参数（0-n个）
public int sum(int... nums) {
    int res = 0;
    // 使用可变参数的时候，我们可以将其当作数值进行使用，即传入的nums可以当作数组
    for(int i = 0; i < nums.length; i++) {
        res += nums[i];
    }
    return res;
}
```

注意事项：

- 可变参数的实参可以为0个或者任意多个

- 可变参数的实参可以为数组

  ```java
  public class VarParameterDetail {
  	public static void main(String[] args) {
          int[] arr = {1, 2, 3};
          T t = new T();
          t.f1(arr);
  	}
  }
  
  class T {
      public void f1(int... nums) {
          System.out.println(nums.length);
      }
  }
  ```

- 可变参数的本质就是数组

- 可变参数可以和普通类型的参数一起放在形参列表中，但必须保证可变参数在最后

- 一个形参列表中只能出现一个可变参数

***

### 克隆对象

克隆对象，要求新对象和原来对象是两个独立的对象，只是他们的属性和属性值完全相同

```java
public class MethodParameter {
	public static void main(String[] args) {
        Person p = new Person();
        p.name = "jlc";
        p.age = 25;
        MyTools myTools = new MyTools();
        Person p2 = myTools.copyPerson(p);
        // p和p2都是Person对象，但是是两个独立的对象，其属性和属性值相同
	}
}

class Person {
    String name;
    int age;
}

class MyTools {
    public Person copyPerson(Person p) {
        // 创建一个新对象
        Person p2 = new Person();
        p2.name = p.name;   // 将原来对象的名字赋值给p2.name
        p2.age = p.age;
        return p2;
    }
}
```

***

### 作用域

在面向对象编程中，变量的作用域是非常重要的知识点

在`Java`中，主要的变量就是属性（成员变量）和局部变量（在成员方法或者代码块中定义的变量）

- 全局变量：也就是属性，作用域为整个类体，全局变量可以不赋值，直接使用，因为有默认值
- 局部变量：除了属性之外的其他变量，作用域定义在它的代码块中，局部变量必须赋值后才能使用，因为它没有默认值

```java
class T {
    // 定义全局变量，作用域在整个T类中，可以在这个类的任意地方使用
    // 全局变量可以不进行赋值
    int age = 25;
    
    public void show() {
        // 定义局部变量，只能在当前的作用域中进行使用
        // 局部变量必须要进行赋值
        int n = 10;
        System.out.println(age);  // 在方法中使用全局变量
    }
}
```

注意事项：

- 属性和局部变量是可以重名的，访问时遵循就近原则
- 在同一个作用域中，比如同一个成员方法中，两个局部变量是不能重名的
- 属性（全局变量）生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁；局部变量的生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的销毁而销毁，即在一次方法调用过程中，通过内存空间进行理解

全局变量/属性可以被本类使用，也可以被其他类使用（通过对象调用）

```java
class T {
    // 属性
    int age = 25;
}

class D {
    // 在其他类中调用T类中的属性
    // 先定义一个T类的对象
    public void test() {
        T t = new T();
        System.out.println(t.age);
    }
}
```

局部变量只能在本类中对应的方法中使用

全局变量/属性可以加修饰符；但是局部变量不能加修饰符

***

### 构造器

构造器也叫构造方法，主要作用是完成对新对象的初始化，我们可以通过构造器，在创建对象的时候，直接指定这个对象的具体属性值（即在创建对象时，系统会自动调用该类的构造器，完成对象的初始化）

基本语法：

```java
修饰符 方法名(形参列表) {
    方法体;
}
```

> - 构造器的修饰符可以默认，也可以是`public`、`protected`和`private`
> - 构造器没有返回值，也不能写`void`
> - 构造器的方法名和类的名字必须一样
> - 参数列表和成员方法一样的规则
> - 构造器的调用由系统完成，即在`new`的时候，系统会自动完成构造器中的方法

```java
public class Constructor01 {
	public static void main(String[] args) {
		// 当我们new一个对象时，直接通过构造器指定属性值
        Person p = new Person("jlc", 25);
	}
}

class Person {
    String name;
    int age;
    // 构造器
    public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
    }
}
```

注意事项：

- 一个类可以定义多个不同的构造器，即构造器的重载，如我们可以再给`Person`类定义一个构造器，用来创建对象的时候，只指定姓名，不需要指定年龄，那么后续初始化对象的时候，年龄就是默认值
- 构造器是完成对象的初始化，并不是创建对象
- 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造方法），如`Person() {}`，可以通过反编译`javap Person.class`进行查看
- 一旦定义了自己的构造器，默认的构造器就被覆盖了，就不能再使用默认的无参构造器，除非显示的定义一个，即：`Person() {}`

#### 引入构造器后的对象创建流程

引入构造器后的对象创建流程是一个经典的面试题

![image-20250329134442728](..\images\image-20250329134442728.png)

> 1. 先在方法区中加载类信息
> 2. 在堆中开辟空间
> 3. 对属性进行默认初始化
> 4. 根据是否赋值，进行显式的初始化（如`age = 90;`）
> 5. 通过构造器进行属性初始化，引用类型的属性值在常量池中，通过地址进行指向，基本类型的数据直接在堆空间中修改
> 6. 最后将堆中的地址进行放回，供实例化的对象`p`进行指向（真正的对象在堆中，`p`只是对象的引用，只是一个对象名）

上述流程简而言之：

1. 加载`Person`类信息（`Person.class`），只会加载一次
2. 在堆中分配空间（地址）
3. 完成对象的初始化
   1. 默认初始化 `age = 0  name = null`
   2. 显式初始化 `age = 90`
   3. 构造器的初始化 `age = 20  name = “小倩”`
4. 对象在堆中的地址，返回给`p`（对象名，也可以理解为对象的引用）

***

### `this`关键字

构造器的输入参数名不是非常友好，如果能将`pName`改成`name`就好了，但是由于变量作用域的原因，`name`的值最后是`null`，这时我们就要引入`this`关键字来解决

```java
public class Constructor01 {
	public static void main(String[] args) {
		// 当我们new一个对象时，直接通过构造器指定属性值
        Person p = new Person("jlc", 25);
	}
}

class Person {
    String name;
    int age;
    // 构造器
    public Person(String name, int age) {
        // this.name表示当前对象的name属性   后面的name是局部变量，就近访问，找不到在访问属性
        this.name = name;   
        this.age = age;
    }
}
```

`java`虚拟机给每个对象分配了`this`，代表当前对象，比如，人是一个对象，这个人说我的，就表示`this`

![image-20250329141242726](..\images\image-20250329141242726.png)

在堆中开辟空间后，除了属性，还有一个隐藏的属性`this`，引用的地址是对象的地址，指向的是对象自己

总之，哪个对象调用，`this`就代表哪个对象

注意事项：

- `this`关键字可以用来访问本类的属性、方法和构造器

- `this`用于区分当前类的属性和局部变量

- 访问成员方法的语法：`this,方法名(参数列表);`

  ```java
  class T {
      public void f1() {
          System.out.println("f1方法");
      }
      public void f2() {
          System.out.println("f2方法");
          // 调用本类的f1()方法
          // 方式一：传统方法
          f1();
          // 方式二：使用this关键字
          this.f1();
      }
  }
  ```

- 访问构造器语法：`this(参数列表);`   只能在构造器中使用（即只能在构造器中访问另一个构造器）

  ```java
  class T {
      public T() {
          // 通过this关键字访问另一个构造器
          this("jlc", 25);
          System.out.println("T()构造器");
      }
      public T(String name, int age) {
          System.out.println("T(String name, int age)构造器");
      }
  }
  ```

  > 注意：访问构造器语法：`this(参数列表);`，必须放在第一条语句中

- `this`不能再类定义的外部使用，只能在类定义的方法中使用

  ```java
  class Person {
      String name = "jlc";
      int age = 25;
      public void f() {
          String name = "abc";
          System.out.println(name, age);   // abc, 25
          System.out.println(this.name, this.age);   // jlc, 25
      }
  }
  ```

  > `this.name`表示当前对象的`name`属性   后面的`name`是局部变量，就近访问，找不到在访问属性



## 面向对象编程





## `API`

`Java`系统官方为我们提供了基本的编程接口（系统提供的类和相关方法）

我们可以去`Java API`文档中快速的查找需要的`API`：[Java 8 中文版 - 在线API手册 - 码工具](https://www.matools.com/api/java8)

### `Java`类的组织形式

![image-20250313203233056](..\images\image-20250313203233056.png)

我们查询文档的思路是：按照包去查找类，再去查找具体的方法，如果我们不知道这个类在哪个包的下面，我们可以直接进行搜索，找到这个类
