# `Python`

## 环境配置

### `python`环境的配置

#### 常规方法配置`python`环境

在[`python`官网](https://www.python.org)下载最新的`python`运行环境，把`python`的安装路径添加到系统环境变量`path`中：在`cmd`命令行中输入`python`就可以看到`python`的版本信息

#### 通过`conda`搭建`python`环境

`conda` 是一个配置隔离 `python` 环境工具

`miniconda` 是一个单纯的 `conda`工具，仅自带极少的`python`必要的包，可以按照自己的需求构建，推荐使用`miniconda`来搭建`python`的虚拟化环境

##### 在`windows`操作系统下搭建`conda`

1. 下载安装[`miniconda3`](https://docs.conda.io/projects/miniconda/en/latest/)
2. 在系统变量中的`path`下添加环境变量
3. 在`cmd`输入初始化操作：`conda init cmd.exe`
4. 配置清华镜像源：
   1. 创建`.condarc`文件：`conda config --set show_channel_urls yes`
   2. 在C盘用户目录下找到`.condarc`文件，对其添加腾讯（国内）镜像源，具体的镜像源网址为：`https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/`
5. 在`cmd`中清除缓存：`conda clean -i`
6. 创建虚拟环境：`conda create -n 虚拟环境的名称 python=3.9`
7. 查看系统中有哪些环境：`conda info -e`
8. 激活`ui-platform`环境：`conda activate 虚拟环境的名称`    出现*表示当前运行的环境

`conda`其他的相关操作：

- 切换环境：`conda activate 环境名`


- 退出当前环境：`conda deactivate`


- 在环境中安装模块：`conda install 模块名`


- 删除环境：`conda remove -n 环境名 --all`


##### 在`ubuntu`操作系统下搭建`conda`

1. 下载安装[`miniconda3`](https://docs.conda.io/projects/miniconda/en/latest/miniconda-other-installer-links.html)，也可以下载离线的安装包，进行离线安装
2. 更改安装包权限：`chmod 775 Miniconda3-py311_23.5.2-0-Linux-x86_64.sh`
3. 安装：`sh Miniconda3-py311_23.5.2-0-Linux-x86_64.sh`   安装过程要手动输入`yes`来同意服务条款，继续按回车，同时也要输入`yes`同意将`Anaconda`的环境变量导入`PATH`中
4. 重新进入终端，发现终端默认进入`miniconda`的`base`环境中：

安装完`miniconda3`后，需要对`conda`进行镜像配置

1. 初始化：`conda init`
2. 启动环境变量：`source ~/.bashrc` 
3. 打开文件`gedit ~/.condarc`    添加清华镜像源
4. 清除缓存：`conda clean -i`
5. 创建所需的虚拟化`python`开发环境：`conda create -n 虚拟环境的名称 python=3.9`

其他操作：

- 退出`miniconda`的`base`环境中：`conda deactivate`


- 基础环境默认激活：`conda config --set auto_activate_base True`


- 基础环境默认不激活：`conda config --set auto_activate_base False`


以上便在路径` miniconda3/envs/ `下生成一个虚拟环境名称的文件夹，其中包含`python3.9`环境 ，包括以后下载的第三方库，形成了一个独立的开发环境。

##### `conda`的`requirements.txt`配置文件

`python`中通过`requirements.txt` 记录所有依赖包（包括第三方库）及其精确的版本号，以便进行新环境的部署，有助于以后布置别台电脑，可以避免`bug`，从而导入跟现在一样的环境

###### 导出`requirements.txt`配置文件

`pip freeze > requirements.txt`

`conda list -e > requirements.txt`  （通过`conda`导出`requirements.txt`）

如果在开发的时候升级了依赖包，记得更新此文件

###### 通过`requirements.txt`配置文件进行环境配置

在其他环境部署项目之前先通过如下命令安装依赖包

`pip install -r requirements.txt`

`pip install --no-index --find-links=d:\packages -r requirements.txt`

> `find-links`指定的是包文件的存放地址，`-r`指定的是`txt`文件的位置

在搭建新环境时可以通过`pip `批量安装`requirements.txt`文件中包含的组件依赖

`pip install -r requirements.txt`

`conda install --yes --file requirements.txt`  （通过`conda`搭建环境）



## 基础知识

`python`是一种动态语言，支持交互式编程、面向对象编程和函数式编程，是一种面向对象的解释型计算机程序设计语言，能够把其他语言制作的各种模块结合在一起

计算机只能识别机器语言，不能识别我们的`python`代码，我们需要`python`的解释器来将`python`语言翻译成机器语言，如`python3.8.9`版本，这个就是解释器

在`cmd`中可以直接执行`python`的`.py`文件，但是要确保在该文件的路径下，通过命令`python xxx.py`执行

可以在打开文件的资源管理器上部的路径中直接输入`cmd`，`cmd`打开的窗口路径就在该文件的路径下

### 注释

注释可以提高代码的可读性，提高代码开发效率

`python`中单行注释用#（可以用`ctrl+/`快捷键添加注释）号，#号右边就是注释的内容

`python`中多行注释使用三个单引号'''内容'''或者三双引号“”“内容“”“

***

### 模块的导入和` import`的使用

以`math`为例：`math`用于数学运算

#### 全部导入

- `import math`
- `from math import *`        导入标准库`math`中所有对象

#### 部分导入

只导入模块中的指定对象（较快的访问速度）

- `form math import sin`
- 给导入的对象起个别名：`form math import sin as f`

#### `import math`具体使用

数据运算（`math`）使用时要导入数据运算方法，引用时要加上`math.`

|        名称        |                    描述                    |
| :----------------: | :----------------------------------------: |
|     `math.pi`      |                  `π`的值                   |
|      `math.e`      |              自然常数`e`的值               |
|    `math.sin()`    |                 `sin`函数                  |
|    `math.gcd()`    |                 最大公约数                 |
|  `math.pow(x,y)`   |              返回`x`的`y`次方              |
|   `math.sqrt(x)`   |              返回`x`的平方根               |
|   `math.fabs(x)`   |              返回`x`的绝对值               |
| `math.divmod(x,y)` |           返回`x`和`y`的商和余数           |
|   `math.logn(x)`   | 返回以`n`为底的对数，如果省略则表示以e为底 |

#### `import random`具体使用

要先引入一个函数库：`import random`

|           名称            |                描述                |
| :-----------------------: | :--------------------------------: |
|    `random.choice(t)`     | 在`t`这个列表里面随机找出一个元素  |
|     `random.random()`     |     在0-1里面找出随机的浮点数      |
|  `random.randint(1,100)`  | 在1-100里面找出随机的整数，[1,100] |
| `random.randrange(1,100)` |    返回[1,100)区间中随机的整数     |
|    `random.shuffle(t)`    |      将序列的所有元素随机排序      |

`random.shuffle(t)` 具体使用：

```py
import random
t = [1,5,3,4,6,2];
random.shuffle(t)
print(t)   # 得到:[1,3,4,6,2,5]
```

#### `import datetime`具体使用

要先引入一个函数库：`import datetime`

|          名称           |                        描述                        |
| :---------------------: | :------------------------------------------------: |
|     `datetime.date`     |                     表示日期类                     |
|   `datetime.datetime`   |                   表示日期时间类                   |
| `datetime.date.today()` |     用于获取当前的日期，返回格式为`YYYY-mm-dd`     |
| `datetime.timedelta()`  | 表示两个时间之间的时间差，两个`date`或者`datetime` |

对象相减时可以返回一个`timedelta`对象。`days=n`用于实现加n天或者减n天的操作

`strftime()`函数接收时间元组，并返回可读字符串表示的时间，格式由参数`format`决定

在计算机中有两个时间的概念：

- 硬时间：主板的晶振
- 软时间：操作系统的时间

***

### 语法基础

#### 变量和命名规则

变量就是一个盒子（容器），里面可以装任何东西，变量不仅仅是数字，还可以是其他任何数据类型，变量是一段有名字的存储空间，可以通过定义变量来申请并命名这样的存储空间，并通过变量的名字来使用这段空间，变量是临时存放数据的场所，先定义变量，然后在使用变量

`python`在变量赋值时，不需要指定数据类型，给这个变量赋什么类型的值，这个变量就是什么数据类型，这个是`pytohn`相比其他语法的不同之处。

变量定义规则：变量名 = 数据（值）  变量可以重复赋值，使其值发生变化，在程序执行中可以改变

变量必须以字母（`a-z，A-Z`）或者下划线(_)开头，其他字符可以是字母，数字或下划线，变量区分大小写，`python`不能用关键字命名，相关关键字如下：

`Python`预先定义了一部分有特定含义的单词，用于语言自身使用。不可以把关键字作为自定义名称来使用，否则会引起异常。

 变量命名需要有以下的命名规范：见名知意，尽量用有语义的单词进行命名

书写可以用小驼峰命名法（`userName`）;大驼峰命名法（`UserName`）;下划线命名法（`user_name`）

#### 基本数据类型

基本数据类型：整形，浮点型，复数，布尔类型

`python`中提供了`type()`函数方便我们查看相关变量的数据类型

##### 整形

整形（`int`）数字没有范围（这点与C语言不同），可正可负，为十进制

​	若想要表示其他进制则加一个前导符：

- ​	二进制：前导符`0b`或`0B`   `0b10`    为十进制2         `bin(a)`将十进制a转化为二进制
- ​	八进制：前导符`0o`或`0O`   `0o10`    为十进制8         `oct(a)`将十进制a转化为八进制
- ​	十六进制：前导符`0x`或`0X`   `0x10`    为十进制16   `hex(a)`将十进制a转化为十六进制

##### 浮点型

浮点数（`float`）小数  取值范围和精度是有限制的，可以是小数表示，可以是科学计数法表示：小数：1.23    -9.01；科学计数法：`1.23e9  1.2e-5 ` e后面必须是整形且不能带空格
浮点数运算存在不确定尾数，可能会有误差，如：0.1+0.2=0.300000000000004
可以用`round()`函数解决：`round(0.1+0.2,2)`   最后的2表示保留两位小数

> 补充：`round(x,n)`返回浮点数x的四舍五入值，n代表舍入到小数点后的位数
> 如`round(3.67,1)` 得到3.7

##### 复数

复数（`complex`）有实部和虚部两部分组成，虚部用j表示
可以用`complex()`函数完成：  `a=complex(1,2) ` 1表示实部，2表示虚部，或者直接输入`a=1+2j`

##### 布尔型

布尔值：`True False `  逻辑运算结果为布尔值，注意大小写要区分
条件判断时，下面的几种情况会被认为是`False`：

- 为0的数字，包括0,0.0；
- 空字符串' '，""；表示空值的`None`；空集合，包括空元祖(),空序列[],空字典{}；

其他的值都为True

#### 运算符及其优先级

##### 算数运算符

| 符号 |                             描述                             |
| :--: | :----------------------------------------------------------: |
|  +   |                             加法                             |
|  -   |                             减法                             |
|  *   |                             乘法                             |
|  **  |                             指数                             |
|  /   |               浮点数除法（100/5     =  20.0）                |
|  //  | 整数数除法（整除数轴上向左取整)(100//5=20)（3//2=1)(-3//2=-2） |
|  %   |                   模（求余）  （9%4  =1）                    |

##### 赋值运算符

| 符号 |                      描述                      |
| :--: | :--------------------------------------------: |
|  =   |      幅值运算符，将右边的值赋给左边的变量      |
|  +=  | 加法幅值运算符   `a += 5`   等价于 `a = a + 5` |
|  -=  |                 减法幅值运算符                 |
|  *=  |                 乘法幅值运算符                 |
|  /=  |                 除法幅值运算符                 |
|  %=  |                 取模幅值运算符                 |
| **=  |                  幂幅值运算符                  |
| //=  |                 取整幅值运算符                 |

a,b = 10,5    同时进行按顺序幅值

##### 比较运算符

| 符号 |   描述   |
| :--: | :------: |
|  ==  |   等于   |
|  !=  |  不等于  |
|  >   |   大于   |
|  <   |   小于   |
|  >=  | 大于等于 |
|  <=  | 小于等于 |

比较运算符返回`bool`类型的数据                 1<3<5等价于`1<3and3<5`	

在`python`中是可以使用1<x<3这种形式的

##### 逻辑运算符

|  符号   |               描述               |
| :-----: | :------------------------------: |
| x and y | 只要一个为False，那么结果为False |
| x or y  |  只要一个为True，那么结果为True  |
|  not x  |         结果与逻辑量相反         |

短路原则：
在与运算发现第一个为False时，就不会计算后面的表达式了，直接出结果，否则返回后面的值
如`a=10,b=20`     `a and b`  返回20
在或运算发现第一个为True时，就不会计算后面的表达式了，直接出结果，否则返回后面的值
如`a=10,b=20`     `a or b`  返回10
所有的非0值，我们作为真的逻辑量，只有0表示假逻辑量

##### 优先级

高到低：正负—幂—乘，除，取模—加减—比较—逻辑否—逻辑与—逻辑或
只有幂的结合性是从右往左的：`2**3**2=2**9=512`	

#### 标准输入输出

##### 标准输入函数`input()`

输入函数：`input()`:可以从键盘中读入一个字符串。

`input()`输入的是字符串，后面要数值计算的话要先类型转化为整形

无论输入是数字还是字符串，`input()`函数都返回字符串，即`age`的数据类型为`string`类型
​如果想使用数字进行计算，则要对字符串进行强制类型转换，否则会引起异常。
​如果需要其他类型的数值，则需要强制类型转换，如想要读入一个整数：`a = int(input())`
​如果想要输入多个值在同一行实现：`a,b = input().split()`
​加入提示语：如，`n= int(input("请输入一个整型值N:"))`

##### 标准输出函数`print()  `

输出函数：`print()`:  输出整形值，如`print(a)`   `print(a,b)`
`print()`函数会默认作为换行符结束，改成`print(i,end='')` 就可以以行输出，''中间表示距离。

语法格式：

`print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)`

> - `value, ...`：表示输出的对象，可以输出多个对象，需要用逗号分隔。
> - `sep`：分隔符，默认以空格分隔。
> - `end`：结束换行符。用来设定以什么结尾，默认值为换行符“\n”。\n 表示换行符
> - `file`：打印的目的对象，默认为标准输出（可以改为其他类似文件的对象）
> - `flush`：是否立即输出到file指定的流对象中。

`print() ` 表示换行，自带换行的效果

##### 格式化输出

###### 格式化占位符：`%—formatting`输出       

%是占位符，后面跟着的是要打印变量的类型

| 格式符号 |                     描述                     |
| :------: | :------------------------------------------: |
|  `%c `   |            格式化字符及其ASCII码             |
|   `%s`   |                 格式化字符串                 |
|  `%d `   |               格式化十进制整数               |
|   `%u`   |               格式化无符号整数               |
|   `%o`   |               格式化八进制整数               |
|   `%x`   |              格式化十六进制整数              |
|   `%f`   | 格式化浮点数，可以指定小数精度，默认保留六位 |
|   `%e`   |          格式化浮点数，用科学计数法          |
|  `%8d`   |                    右对齐                    |
|  `%-8d`  |                    左对齐                    |
|  `%.2f`  |               结果保留两位小数               |
| `%8.3f`  |             设定宽度保留三位小数             |

例如：

- `print("%fasdf %ewfs"%(a,b))`   一个萝卜一个坑，要一一对应起来
- `print("%fasdf wfs"%(a,)) `  后面没有b，逗号也要保留

print实参拆包：把列表拆成元素。

	I=[2,7,5]
	print(I)
	#得到：[2,7,5]
	print(*I)
	#得到：2 7 5

###### 格式化format输出

通过{}和：来替代print中格式化占位符的%
format函数：基本格式：`str.format(变量)`
列如：保留两位小数输出：`print("{0:.2f}{1:.2f}".format(x,y))`
0.1表示format函数中第一和第二个参数     `.2f`表示小数保留两位

###### 格式化字符串常量f-string输出

例如：`S=3`
`print(f"序列和为{S:.3f}")`

###### 格式描述符

| 符号 |             描述             |
| :--: | :--------------------------: |
|  <   | 左对齐（字符串默认对齐方式） |
|  >   |  右对齐（数值默认对齐方式）  |
|  ^   |           居中对齐           |
|  #   |       切换数字显示方式       |

同理，格式化占位符都适用，应用时放在：后面。：前面直接调用变量值
例如：`print(f'宽度设置，低补位0:{a:<08d}')`

***

### 流程控制

流程：就是计算机执行代码的顺序

流程控制：对计算机代码执行的顺序进行有效的控制，只有流程控制才能实现在开发当中的业务逻辑

流程控制有顺序结构，选择结构和循环结构

#### 顺序结构

顺序结构：是代码自上而下的执行结构，是`python`默认的流程

赋值语句：基本形式：“变量=值”，同时`python`支持多变量的赋值：`a=b=c=5`

序列赋值：
情况一：左侧的变量个数等于右侧的序列个数
	`xy`同时赋值：`x,y=4,8`  是按照次序进行赋值的
	`x,y="ab"`  得到结果x='a'  y='b'
	`a,b` 值的交换   `a,b=b,a`

情况二：左侧的变量个数小于于右侧的序列个数
​	`i,*j=[1,2,3]`  不加*会报错    结果为`i=1   j=[2,3]`

#### 选择结构

选择结构：根据某一步的判断，有选择的去执行相应的逻辑的一种结构

分支语句：`if`语句：

基本格式：`if` 逻辑表达式:
​                 	       语句块1
​            		`elif` 逻辑表达式:
​                 	       语句块2
​             	   `else`:
​                  	      语句块3
​最后的else是`elif`里面的else     级联的if语句
​当逻辑表达式为真时，就会执行语句块1，否则就会执行语句块2

多分支有多个选择，`else`是选配，根据实际情况来选择

0 0.0 “”[] () {}都表示假

#### 循环结构

循环结构：在满足一定的条件下，一直重复的去执行某段代码的逻辑

##### `while`循环

```python
while Ture:
    ...
```

语法特点：

1.循环必须有一个初始值 

2.必须有条件表达式 

3.循环体内计数变量必须自增或自减，防止进入死循环

使用条件：循环次数不确定，是依靠循环条件来结束

使用目的：为了将相似或将相同的代码操作变得更加简洁，使代码可以重复利用

不会停下来的循环，我们需要离开该循环，要通过`break`来实现，写程序时先写`while`里面的，当需要无线循环时加上`while`

##### `for`循环

基本格式：  `for variable`(变量) `in `可迭代的集合对象:
​	                         语句块
​变量`variable`的值会在列表范围内，列表有多少值，语句块就会重复多少次
`for`循环可以遍历字符串，列表等等​

语法特点：遍历操作，依次的取集合容器（数据源）中的每个值

如遍历列表：      

```pyt
for i in [1,2,3,4]:
	 print(i)
```

上面输出是列输出，如果想要同一行输出：`print(i,end='     ')`

列表的形成函数：`range`函数
基本格式：`range(start,stop,step)`

> 计数从start开始，默认从0开始；到stop结束，但是不包括stop
> step表示步长，默认为1
> 如：`list(range(0,5))`   结果为[0,1,2,3,4]
> for 循环后面可以跟 else  条件自然结束
> for后面的条件不满足时，执行else
> 如果循环正常结束else后面会执行，如果有break，else后面就不会执行

- `range()`函数：
- `range(n) `得到0......n-1的整数
- `range(m,n)` 得到m......n-1的整数  
- `range(m,n,x)`     x为步长，最后一个数不大于等于n

循环结构中的两个重要的关键字：   这两个关键字只能用在循环中

`break`: 退出循环，代表中断结束

`continue`: 跳过本次循环，继续下一次循环（当`continue`的条件满足的时候，本次循环剩下的语句将不在执行，本次循环结束）

```python
#打印1-100中的奇数
for item in range(1,100):
    if item % 2 == 0:
        continue   #如果是偶数，continue后面的语句就不会执行了，进行下一次的循环
    print(item)
```

在实际的应用中，`while`循环和`for`循环的主要应用方向可能有所区别，`while`适用于对未知的循环次数；`while`适用于对已知的循环次数，本质就是对可迭代对象遍历

`for---else`:语法：用户登录三次出错，则显示账号被锁定

```python
account = 'jlc'
pwd = '123'
for i in range(3):
    zh = input("请输入账号：")
    pd = input("请输入密码：")
    if account == zh and pwd == pd:
        print("登录成功！")
        break   #程序中只要没有执行break，else就会被执行；如果执行了break，else就不会执行
else:
    print("你的账号已经被锁定！")     
```

***

### 高级数据类型

在`python`中，序列就是一组按照顺序排列的值，序列也可以称作为数据集合

在`python`中有三种内置的序列类型：字符串，列表和元组

序列的特点：可以支持索引和切片的操作，第一个正索引为0，指向的是左端；第一个正索引为负数时，指向的是右端；切片是指截取字符串中的一段内容，切片的基本语法：[起始下标：结束下标：步长]

#### 字符串 `String`

字符串与列表都可以看成容器，有顺序的容器称为序列，列表和字符串都称为为序列，序列可以做加法，也可以和一个整数相乘。相加和相乘不会改变容器的本身，会创造一个新的容器存放。字符串本身不能被修改，只能将改动的字符放入另外一个字符串中。

##### 字符串类型

字符串：字符串是以引号括起来的任意文本，引号可以是单引号('')  双引号("")  三引号('''  ''')，三引号可以表示多行文本，如果字符串本身包含了单引号，我们可以用双引号将其括起来，反之如果本身包含了双引号我们可以用单引号将其括起来，如果既有单引号又有双引号，我们就用三引号括起来

##### 常见的转义字符

`\'`  (单引号)  ` \b` (退格) ` \r `(回车) ` \n `(换行)  

##### 字符串运算符

1.`+`连接字符串    `'hello'+'world'='helloworld'`

2.`*`复制字符串   ` 'ab'*3='ababab'`

3.`in `成员运算符，如果字符串中包含字符，返回True，`"M" in a    a是字符串`
`r'safsaga\\fdb' `将所有字符串按照原始意思来使用，将转义字符变为原始意思

##### 字符串索引与切片

字符串是一个有序序列，可以正向递增也可以反向递减
	索引：在[]中给出序号
	切片：在[]中给出切片序号范围
如 字符串`s="abcdefgh"`
`s[0]='a' `   `s[-1]='h' `  ` s[1:5]='bcde'`   5是取不到的，左闭右开

`s1='123' `   `s1[1]=2` 方括号里面是数是元素的编号，列表也一样。
​第一个元素是第零号   最后一个是-1号

切片：`string_name[start_index : end_index : step]`

`start_index `去掉表示从头开始，不需要写0；`end_index `去掉表示取到字符串的最后一个字符

从左到右索引默认从0开始，最大范围是字符串长度少1；从右到左索引默认从-1开始，最大范围是字符串开头。

修改元素：
`t1[0]=4`     但是字符串是不可以修改的类型，仅对于列表适用

##### 序列函数

`s1='123'`
`len(s1)=3`  表示字符串长度
`len()`对于字符串和列表都适用。
`min()`得到序列里面最小的元素。对于字符串和列表都适用。
`max()`得到序列里面最大的元素。对于字符串和列表都适用。

id(s1)  表示字符串s1的内存地址

##### 字符串的相关函数

字符串相关函数的调用一般是通过，字符串.函数   进行使用的，字符串常用的函数如下所示：

|             函数             |                             描述                             |                           相关案例                           |
| :--------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|          `count()`           |                     统计某字符出现的次数                     |        `s.count('aaa')`  返回s字符串里面aaa元素的个数        |
|        `capitalize()`        |                   将字符串的首字母变成大写                   | `s = "What is Your Name?"`                                `s.capitalize()`     结果为：   'What is your name?' |
|          `title()`           |                    将每个单词的首字母大写                    |       `s.title()`      结果为：  'What Is Your Name?'        |
|         `swapcase()`         |                      将字母的大小写互换                      |      `s.swapcase()`     结果为：   'wHAT IS yOUR nAME?'      |
|          `lower()`           |                     将字符串全部变成小写                     | `s=s1.lower()`    将s1里面字符串所以的字符变成小写写到s里面。但是s1不会修改，因为所有的字符串都不能被修改。 |
|          `upper()`           |                     将字符串全部变成大写                     |     `s.upper() `         返回大写字符串，将小写变成大写      |
|          `strip()`           | 将字符串两边的空格(空白字符包括空格、制表符(\t)、换行(\n)、回车(\r）等)去除，中间的不管 | `s=' Hello World  '                                                        `                             `s.strip()`          结果为：'Hello World' |
|          `rstrip()`          |           将右边的空格和空白字符去掉，中间的不去掉           |        `s.rstrip() `         结果为：'   Hello World'        |
|          `lstrip()`          |           将左边的空格和空白字符去掉，中间的不去掉           |        `s.rstrip()    `      结果为：'Hello World   '        |
|           `find()`           |                   查找某字符是否在字符串中                   | `s.find('aaa')`    返回aaa在s字符串第一次出现的位置，找不到返回-1,若有多个a，就给出从左边给出的第一个位置。             `s1.find('a',3)`   3表示从字符串a中的第4个字符开始找。 |
|          `rfind()`           |              查找某字符在字符串中最后出现的位置              | `s.rfind('aaa') `   返回aaa在s字符串最后一次出现的位置，如果不存在则返回-1 |
|    `index()`和`rindex()`     |                     查找某字符的出现位置                     | 两种方法用来返回一个字符串在另一个字符串中首次和最后一次出现的位置，如果不存在则抛出异常(报错)； |
| `startswith()`和`endswith()` |                是否以某个字符/字符串开头/结尾                | 输出是一个bool类型的数据；`s = 'Beautiful is better than ugly.'`        `s.startswith('Be') `            检测整个字符串，返回True |
|          `strip()`           |                        删除指定字符串                        | `"aaaassddf".strip("a")`                删除指定字符'a'    结果'ssddf' |
|         `replace()`          |                    取代字符串中的某个部分                    | `s.replace(' ','-')`  将s里面的空格替换成减号。前面的是被替换的，后面的是替换物。字符串修改都不会对原先的字符串进行改变，都会产生新的字符串。 |
|          `split()`           |                          切割字符串                          | `split() `方法分别用来以指定字符为分隔符，把当前字符串从左往右分隔成多个字符串，并返回包含分隔结果的列表； |

字符串的常用判断方法：

`isalnum()`、`isalpha()`、`isdigit()`、`isnumeric()`、`isspace()`、`isupper()`、`islower()`，用来测试字符串是否为数字或字母、是否为字母、是否为数字字符、是否为空白字符、是否为大写字母以及是否为小写字母。

##### 字符串与数字之间的转化

使用全局函数`str()`
`str(123) `  得到一个字符串'123'
%字符串的格式化运算符。
`'I am %d years old and weight %.2f kg.' %(18,60.334)`
得到'I am 18 years old and weight 60.33 kg.'
`%10d`    表示数字前面有10个空格。

#### 列表 List

列表用[]标识，数据项之间用逗号来分隔，数据项支持字符、数字、字符串甚至可以包含列表。

`List`是一种有序的集合，可以随时添加和删除其中的元素，支持增删改查，列表中的数据项是可以变换的，但其内存中的地址不会改变

列表支持索引和切片来进行对数据的操作

使用列表
每个列表对象里的元素的数据类型可以相同，也可以不同。用[]括起来，用，进行分割。
`list()`函数，将字符串展开成列表，包括中间的空格。
`t1=[1,2,3]`    创造了一个列表[1,2,3]
`t2=t1`         t2也指向了这个列表
`t2[0]=0`       t2变成了`[0,2,3]`, t1也变成了`[0,2,3]`，列表变量是列表的管理者，不是所有者。t2=t1表示让t2去管理t1管理的列表。
要想产生一个新的列表，用切片：`t2=t1[:]` t2就指向新的列表。
这样就将t2和t1分开了。在t2上任何修改与t1都没有关系。
`del t[2]`  将列表t的2号元素删除。
列表遍历：`for i in t1`   i变量依次取列表t1中的每个元素

##### 列表的相关函数

`cmp(list1,list2) `  比较两个列表的元素

`len(list)`   列表元素的个数

`list(seq)`    将元组转换为列表

###### 元素的增加

|    函数    |          描述          |                           相关案例                           |
| :--------: | :--------------------: | :----------------------------------------------------------: |
| `append()` |   在列表后面追加元素   | `t1.append(5)`   往列表最后面加入元素5，`t1.append([4,5])`   得到[1,2,3,[4,5]] |
| `extend()` |   拓展，批量添加元素   | `t1.extend([7,8,9])`  将列表[7,8,9]加到t1列表后面，`t1.extend([4,5])`   得到[1,2,3,4,5] |
| `insert()` | 指定索引值前面加上元素 | `t1.insert(1,9)`   在t1列表原来索引值为1号前面加上元素9，当insert的下标超过数字标号，就会将9添加到列表最后 |

###### 元素的修改

去列表中要修改的元素的下标，直接进行新值的赋值修改

`list[n] = N   `    n表示要修改的元素的下标，N表示修改的内容，N可以是不同的数据类型

###### 元素的删除

|    函数    |                描述                |                             案例                             |
| :--------: | :--------------------------------: | :----------------------------------------------------------: |
|   `del`    |              删除元素              | `del t[2]`  将列表t的索引值为2的元素删除；`del t[0:2]`  删除索引值为0和1的元素；`del t`  删除整个列表，如此后仍使用t时，则出现`“NameError”`的异常 |
| `remove()` |    删除列表中首次出现的） 元素     | `t1.remove(2)`       删除值为2的元素                                                 `list1 = ["北京市", "上海市", "天津市","重庆市", "天津市"]`     `list1.remove('天津市')`	  删除第一次出现的元素'天津市'，删除后list1的元素值为：`['北京市', '上海市', '重庆市', '天津市']` |
|  `pop()`   | 根据索引值删除并返回对应位置的元素 | `t1.pop()`       弹出某个元素 ()里面是序列号，弹出之后这个元素不在列表里面了，这和`t1[3]`不同 |

###### 元素的分隔

`partition()` 用来以指定字符串为分隔符将原字符串分隔为3部分，即分隔符前的字符串、分隔符字符串、分隔符后的字符串，如果指定的分隔符不在原字符串中，则返回原字符串和两个空字符串。

```py
s = "apple,peach,banana,pear"
s.partition(',')
('apple', ',', 'peach,banana,pear')
```

###### 元素的查找和排序

列表元素的查找：

`t1.index(9)`     查找元素9在哪个位置上  查找单个元素第一次出现的位置。与字符串find相似
`random.choice(t1)`  随机在列表t1中选择一个元素

```py
S=[1,2,3,4,5,6,7,8]
for index,i in enumerate(S):
    print(index,i)    #index和i变量依次取列表S中的索引和对应的元素。
```

列表元素的排序：

|    函数     |         描述         |      案例      |
| :---------: | :------------------: | :------------: |
| `reverse()` | 颠倒列表中元素的顺序 | `t1.reverse()` |

成员函数`sort()`和内置`sorted()`对列表元素进行排序：

其语法格式为：
`list_name.sort/sorted(key=None, reverse=False)`
其中，key表示指定从每个元素中提取一个用于比较的键，默认值为None；reverse表示排序方式，默认为升序排列。
`k=(lambda x:x[1])`
`sort()`会改变原列表的元素的排列顺序
`sorted()`会建立一个原列表的副本，该副本为排序后的列表，而原列表保持不变。
`list1.sort()`    表示升序
`list1.sort(reverse=True)`    表示降序
`list2=sorted(list1)`  建立一个原列表的副本`list2`，该副本为排序后的列表，而原列表保持不变。





#### 字符串与列表之间的转换:

##### 字符串转为列表

###### split() 函数

split()  将字符串中按照特定的元素分隔成列表

```py
s="this is a test"
s.split()
#得到['this', 'is', 'a', 'test']   
```

 `split()`没有参数，就用空格作为分隔符，则字符串中的任何空白符号（空格、换行符\n、制表符等）都将被认为是分隔符，把连续多个空白字符看作一个分隔符。

```py
a="12::35"
a.split('::')
#得到['12', '35']
a.split(':')
#得到['12', '', '35']    ::之间默认有空格
```

###### list()函数

将字符串完全展开成列表，包括中间的空格。
`list(s)`
得到：`['t', 'h', 'i', 's', ' ', 'i', 's', ' ', 'a', ' ', 't', 'e', 's', 't']`



##### 将列表转化为字符串 

###### join()函数

将列表转换为字符串，字符串连接

```py 
t=['this', 'is', 'a', 'test']
' '.join(t)     #用空格连接
#得到: "this is a test"
```

小技巧：使用`split()`和`join()`方法可以删除字符串中多余的空白字符，如果有连续多个空
白字符，只保留一个，例如：

```py
x = 'aaa      bb      c d e   fff    '
' '.join(x.split())
```





### 元组 Tuple

“()”将多个元素存放在一起，多个元素之间用英文逗号界开。与列表几乎差不多，元组用()，元组是一种不可修改的数据。元组可以通过下标进行访问
作用：不想要拿到方可以修改列表，就使用元组。

元组中的元素可以是任何的类型，当元组中只有一个元素时，要加上逗号，不然解释器会当做整形来处理

如果相邻的值用逗号隔开，但是没有圆括号，python也会认为他们是元组。

返回元组中某项（第三项）的数据类型：type(tupleA[3])

可以对于元组中的列表数据类型的数据进行修改：`tupleA[3][0] = 12`，如元组中的第四项是一个列表数据类型，我们可以对其列表的第一项进行修改



#### 元组的创建

`t1=tuple()`     创建名为t1的空元组
`t1=()`  #创建名为t1的空元组，与t1=tuple()等价

元组的操作和列表相似，但是元组不能进行修改，因此元组不能进行增删改操作，只能对元组进行查找

对于元组中元素的查找，还是主要通过切片操作进行

如果元组中的数据项只有一个，我们在创建的时候必须在第一项后面加上一个逗号，如  t1 = (123,)这样才能视为一个元组类型

对元组进行重新赋值/创建，前后两次的内存空间是不一样的



#### 元组的函数

统计元组中某个元素出现了多少次：count()

查找指定元素的下标索引：index()



#### 列表转化为元组

##### tuple()函数

`p=tuple(t)`    p为元组，t为列表

创建元组时，如果只有一个元素时，一定要在元素的后面加“,”，否则无法正确创建元组。
`tuple_t=(1,)`        正确的做法

元组的基本操作同列表类似，唯一不同之处在于元组是不可变数据类型，即不能对元组进行增加、删除、修改和排序等操作，否则会发生`“TypeError: ‘tuple’ object does not support item assignment”`的异常。

当一个元组中包含多个元素时，可采用解包操作将每个元素赋给不同的变量，例：

`tuplea=('zhangsan',18,'nan')`    元组中包含三个元素
`name,age,sex=tuplea`    通过解包操作将不同的元素赋给不同的变量
此时，`name,age,sex`分别被赋值为`'zhangsan',18,'nan'`。这种操作经常用作函数参数传递时，多参数返回值的情况。





### 字典 Dictionary

字典{}是将多个形如“键:值”的元素放在一对英文大括号中，多个元素之间用英文逗号界开`{ 键1 : 值1,  键2 : 值2,  ……  }`的高级数据类型。其中：
	键名不可修改，只有不可变的数据可以充当；而键值是允许修改的，任何类型的数据可以充当键值。
	键名具有唯一性，字典中不允许出现相同的键名，但是不同的键名允许对应相同的键值。
	字典中的键名必须是不可变的类型，一般是字符串、数字或者元组；而键值却可以是任何数据类型。
	如果在字典的定义中确实需要使用多个子元素联合充当键，则需要使用元组。

​	如果出现重复的键，后者会覆盖前者

当我们在字典中去查找元素时，我们通过键去进行查找，键的方法进行查找的效率非常高

字典和列表一样，是可以进行改变的，可以进行增删改查操作

字典不能进行索引，一般通过键去访问，所以键不能重复，键只能是不可变类型，如数字，字符串和元组

字典是一个无序的键值组合，是python中内置的高级数据类型

len()   返回字典中键值对的对数

获取字典中所有的键：dictA.keys()         获取字典中所有的值：dictA.values()

获取字典中所有的数据项(键值对)：dictA.items()     输出结果是元组



#### 字典的产生方法

```pyt
#两种方式创建空字典
dict1={}
dict1=dict()

keys=['name','age','xingbie']
values=['zhou ming',18,'nan']
dict2=dict(zip(keys,values))    #利用zip()函数来生成（键，值）数据对

dict2['name']='zhou ming'
dict2['age']=18
dict2['xingbie']='nan'

dict2=dict('name':'zhou ming','age':18,'xingbie':'nan')

dict2=dict(name='zhou ming',age=18,xingbie='nan')

dict2=dict([('name','zhou ming'),('age',18),('xingbie','nan')])
```



#### 字典的增删改查操作

##### 增加元素

```py
dictb={'name':'zhou ming','age':18,'xingbie':'nan'}
dictb['chengji']=88       #增加了一个’chengji’键，其对应的值为88
print(dictb)   #输出结果为：{'name': 'zhou ming', 'age': 18, 'xingbie': 'nan', 'chengji': 88}
方法二：
dictA.update({'age':32})  #值不存在就是一个添加的操作
```

##### 修改元素

```py
dictb['chengji']=91      #将’chengji’修改为新的值91
dict1['1']=111
#如果1条目存在，就修改里面的值，如果1条目不存在就加一个条目。
方法二：
dictA.update({'age':32})  #值存在就在一个修改的操作
```

##### 删除元素

利用del dictA[键]  的方法删除对应的键及其值

```python
del dict1['1']  将键为1的条目删除
```

利用pop()删除某键对应的元素：

```py
dictb.pop('chengji')   #删除键为’chengji’的元素，同时返回91
print(dictb)#输出结果为：{'name': 'zhou ming', 'age': 18, 'xingbie': 'nan'}  #可看到键为’chengji’的元素已被删除
```

利用clear()方法将字典中的所有元素都删除：

```py
dictb.clear()    #将所有元素删除掉
print(dictb)     #输出结果为：{}
```

##### 查找元素

打印字典对象可以输出完整的字典，通过键，可以去获取相对应的值

键值对被称为字典的条目item、字典中的元素是无序的，不能通过索引来访问，只能通过键名来访问。

```py
dict1={"jiangsu":"nanjing","zhejiang":"hangzhou"}
print(dict1["jiangsu"])  #输出结果为：nanjing

dict1={1:"fer",2:"eddcv",3:56}  #冒号前面为键，后面为值。逗号隔开为字典不同的条目。
print(dict1[1])   #得到fer
```

通过`get()`方法来访问键值，语法格式：字典名.get(键) 。get方法按照指定的“键名”
访问字典中对应条目，并返回其对应的“值”； 如果指定的“键名”在字典中不存在，则返回None。

```py
dict1={"jiangsu":"nanjing","zhejiang":"hangzhou"}
print(dict1.get("jiangsu"))   #输出结果为：nanjing
print(dict1.get("hubei"))    #输出结果为：None
```



#### 字典的遍历

`dictb.keys()`    获取字典中的所有键名
`dictb.values()` 获取字典中的所有键值
`dictb.iterms()` 获取字典中的所有条目
对于字典来说，做for循环，我们实际上在遍历它的键。通过得到的键，我们可以访问他的值。

```py
dict1={1:"fer",2:"eddcv",3:56}
for i in dict1.keys():        #得到键名
   print(i)
#得到：1
#     2
#     3

for i in dict1.values():      #得到键值
   print(i)
#得到："fer"
#     "eddcv"
#      56

for i in dictk.items():      #得到条目
   print(i)
#得到：(1, 'fer')
#     (2, 'eddcv')
#     (3, 56)
```

`min(dictb)`得到字典dictb最小那个键名，`max(dictb)`得到字典dictb最大那个键。



#### 字典的排序

通过python中内置的函数sorted()进行排序，对字典中的值进行排序，排序会按照ASCILL码进行排序

排序选择：对于键和值，哪个排序有意义就选择哪个进行排序

字典排序，对于选择作为排序的指标的数据类型需要保持一致，不然会报错

##### 按照键进行排序

sorted(dictA.items(), key=lambda d:d[0])      d[0] 表示按照键的ASCILL码进行排序，键的第一个字母的ASCILL码小的在前

##### 按照值进行排序

sorted(dictA.items(), key=lambda d:d[1])      d[1] 表示按照值的ASCILL码进行排序，值的第一个字母的ASCILL码小的在前





### 集合

集合里面的值不能重复，如果输入重复的只会保留一个。输入没有顺序的数，会输出从小到大有序的数。集合的顺序不能由程序员来指定。集合是无序的容器。
产生集合的方法：

```py
seta=set()       #定义一个空集合
print(seta)		 #输出结果为：set() 
```

##### 集合的常用方法

去掉列表里面重复的数，集合是不能存在重复的数：

```py
list1=[1,2,3,4,1,2]
print(set(list1))

setc=set('abcdcba')         #利用字符串生成集合
print(setc)		#输出结果为：{'a', 'd', 'c', 'b'}
```

###### 添加元素

```py
s={1,2,3,4,5}
s.add(0)
#得到：{0,1,2,3,4,5}
```

###### 删除元素

`remove()`,`pop()`,`discard()`

```py
seta={1,2,3}
seta.remove(1)
#得到: {2,3}   直接将集合里面的1值删掉。

m=seta.pop()  #弹出集合seta里面任意一个元素，若无元素，显示异常。

seta.discard(1)
#得到: {2,3}   直接将集合里面的1值删掉。和remove()相似。

seta.clear()   #移除集合seta所有元素
```

集合的对象是不能取下标的，s[0]是错误的。
可以用for循环来遍历集合
<在集合里面表示真子集
<=在集合里面表示子集
|表示并集，将两个集合取并集。
&表示交集，将两个集合取交集。
`s1-s2`表示从s1里面去掉在s2里面存在的东西。

###### 统计长度

`len(seta) `  统计元素个数



### 高级数据类型的公有方法

连接字符串，列表和元组，可以使用+来进行连接

复制字符串，列表和元组，可以使用*来进行复制

判断某元素是否存在在字符串，列表，元组和字典（判断某个键是否存在）中，可以用in来进行查找，返回bool类型的数据





## 函数

函数是一个独立功能的代码块，通过代替多次出现的功能，提高编写代码的效率

为什么要使用函数？代码的复用（反复使用）最大化以及最小化冗余代码，整体代码结构清晰，问题局部化

### 内置函数

python中有许多可以直接调用的函数，这些函数叫做内置函数

1.运算类的内置函数如：max函数,min函数

2.判断类的内置函数如：or函数，any函数

3.io操作类的内置函数：input函数，print函数

4.转换类的内置函数：

类型转换函数：
	`bool()`根据传入的参数逻辑值创建一个新的布尔值
	`int()`根据传入的参数创建一个新的整数
	`float()`根据传入的参数创建一个新的浮点数
	`complex()`根据传入的参数创建一个新的复数
	`str()`创建一个字符串

编码类的转换：
	`ord()`返回Unicode字符对应的整数
	`chr()`返回整数对应的Unicode字符
	`bin()`将整数转化为2进制字符串
	`oct()`将整数转化为8进制数字符串
	`hex()`将整数转化为16进制字符串

```py
int()函数：
基本格式：int(x[,base=10])
int("35",8)=29  八进制

ord()函数：
ord('a') #ASCLL码   97
ord('中')#汉字‘中’的Unicode码    20013

chr()函数：
chr(97)      'a'
```

5.创建新的列表的函数：
	`list()`根据传入的参数创建一个新的列表

6.`type()`函数：`type(a)`查看a的数据类型。
	显示结果为`class'str'`表示a为字符串，显示结果为`class'int'`表示a为整形。

7.`del()`函数：`del(sum)`当sum被赋值时，要重新用回sum函数的功能，
	用`del()`函数恢复。所以不要用python的内置函数进行赋值。

8.`id()`函数：可以显示对象的地址。python会将-5到256存放在一个小整数
	对象池中，这样不用对重新对这些对象去进行内存的分配，从而提高效率。
	所以a=1 b=1 id(a)=id(b)=id(1)   a=1000 b=1000 id(a)!=id(b)!=id(1000)
	但是如果a=b=1000，这样分配的地址是一样的，所以id(a)=id(b)



`sorted`函数：对字符串，列表，元组，字典等对象进行排序操作。
`sort`是应用在list上的方法，sorted可以对更多的数据类型进行排序操作。
`sort`是对存在的列表进行操作，而`sorted`返回一个新的list，不是在原来的基础上进行操作。
语法：
	`sorted(iterable,key,reverse)`
	iterable -- 序列，如字符串，列表，元组等。
	key -- 函数，缺少为空。
	reverse -- 排序规则
	reverse = True 降序  reverse = False 升序（默认） 

`map`函数：根据提供的函数对指定序列做映射。
语法：
`map(function,iterable,...)`
function -- 是对参数序列中的每一个元素调用function函数，iterable是序列。
`print(list(map(lambda x:x**2,[1,2,3,4,5])))`
得到{1,4,9,16,25}  一一映射使用

`zip`函数：将对象中对应的元素打包成一个元组，然后返回这些元组。如果元素长度不一致，则返回列表长度与最短的对象相同。
如：

```py
a=[1,2,3]
b=[4,5,6]
c=[4,5,6,7,8]
print(list(zip(a,b)))
#得到：[(1,4),(2,5),(3,6)]
print(list(zip(a,c)))
#得到：[(1,4),(2,5),(3,6)]   多出来的丢掉了
```

`all`函数和`any`函数：
all函数参数都是True,就返回True，否则返回False
any函数参数只要有一个为True,就返回True,全部为False时，返回False.



### 自定义函数

函数要先定义在调用。
函数的定义语法格式：
	`def 函数名(参数表):
	    函数体`

参数表中的参数个数可以是零个，也可以是多个，是根据具体的场景而定的

函数调用是指将一组特定数据传递给被调用函数，然后启动函数体的执行，最后返回到主程序中的调用点并带回返回值的过程。调用方法：
`func_name(par1,par2,…)`

函数的备注说明信息一般加在函数体上方，方便其他人熟悉函数，备注信息一般是用多行注释去添加

#### 函数的参数及参数类型

参数：函数为了实现某项特点的功能，进而为了得到实现功能所需要的外部数据

形参（定义时）：形参只是意义上的一种参数，函数定义时的参数，像变量一样，定义的时不占内存地址
实参（调用时）：调用函数时，函数中的参数值为实参，实参是占用内存地址的
形参指的是函数定义时函数名后面括号里的参数，多个形参用逗号“,”分隔，这些形参用于接收函数调用时传入的具体数据，其作用域为该函数局部
实参是在函数调用时函数名后圆括号中的参数，用于给形参传递具体的值在函数调用时，实参和形参要一一对应，包括参数个数的对应、参数类型的对应，否则将会导致错误。

当参数是数值类型、字符串类型和布尔类型、元组时，形参的改变不会影响实参，这样的数据类型称为不可变数据类型。当参数是列表、字典时，形参的改变意味着实参的改变，这样的数据类型称为可变数据类型。
当实参是不可变对象时，形参值改变不会影响实参。当实参是可变对象，形参值改变可能会影响实参。
赋值是不可变对象，列表是按照地址来寻址的，是可变的。



##### 函数参数类型

###### 位置参数(必选参数)

传入参数的值按照顺序依次赋值给形参，在调用的时候，必选参数必须要一一对应的赋值



###### 关键字参数

调用参数时可以指定对应形式参数的名字。
1.2同时使用，先写位置参数，再写关键字参数。
如`dis(1,2,y2=5,x2=4)`
关键字实参对于实参的位置没有要求。
关键字参数在函数调用时实参采用“形参名=实参”的格式，明确将实参值传递给某个形参，实现一种显式的参数匹配效果，从而摆脱位置的约束。
调用时：
`funcname([位置参数],[关键字参数])`
注意这个前后顺序是严格的，即位置参数在前，关键字参数必须在后面。	



###### 默认值参数(缺省参数)

当调用方没有提供形参的值时，你可以指定默认形式参数值，如果你提供实参，在调用时会代替默认值。
`def power(x,n=2):
    .....
power(5)`
函数调用时，只有一个实参5，那么将5传递给第一个形参x,第二个形参采用默认值2
`power(4,3)`
函数调用时，有两个实参：4和3，那么将4传递给第一个形参x,3传递给第二个形n，此时默认参数采用传递过来的实参值3
注意事项：默认参数只能出现在参数列表的最后，其后面不能出现非默认参数



###### 数量可变参数(不定长参数)

一个星号*：当函数参数数目不确定时，星号将一组可变数量的位置参数集合成参数值的元组。

```python
def func(a, b, *c):
  print("a:",a)
  print("b:",b)
  print("c:",c)
func(1,2,3,4,5)
#得到：
#a: 1
#b: 2
#c: (3, 4, 5)
func(1,2)
#得到：
#a: 1
#b: 2
#c: ()
```

两个星号**：收集参数到字典中，该参数类型又叫关键字可变参数

```python
def count(a,**d):
   print(d)
count(3,x1=9,x2=1,x3=6)
#得到：{'x1':9,'x2':1,'x3':6}
#另外一种参数传递方式
dictA = {"x1":3, "x2":1, "x3":6}
count(**dictA)
```

可选参数接受的数据是一个元组类型；关键字可变参数接受的数据是一个字段类型

当在函数定义时可以既包括元组变长参数，也包括字典变长参数，其一般格式如下：

关键字可变参数必须在数量可变参数的后面，否则会报错

```python
def func_name(formal_args,*args,**kwargs):
  statements
  return expression
```



#### 函数的返回值

返回值就是程序中函数完成一件事情后，最后给调用者返回的一个结果

用return语句返回值。
return后面的表达式的值就成为这次函数调用的返回值。
如果没有return语句返回，函数返回None，None是一个特殊值，不表示任何数据，但有重要作用。
返回值可以返回数字，还可以返回函数。



### partial函数

在普通函数执行时，要带上必要的参数进行调用，partial函数在调用时参数提前获知，有些参数就预先可以用上，使函数能用更少的参数进行调用。

在函数执行时，要先导入functools模块

```python
import functools
def add(a, b):
    return a + b
rst1 = add(4, 2)
plus3 = functools.partial(add, 3)
rst2 = plus3(4)
#结果 rst1 = 6   rst2 = 7
```

partial函数定义了一个匿名函数。

partial函数不会提高效率，但是会使代码更加简洁。



### Lambda函数

函数的另外定义方法：
	lambda表达式；它定义了一个匿名函数。用来编写简单的函数。
如：

```py
g=lambda x,y,z:x+y+z
add=lambda a,b:a+b
print(add(3,4))
#还可以这样使用：
print((lambda a,b:a+b)(3,4))
```



### 变量的作用域

命名空间和作用域：
	变量可被访问的范围为变量的作用域，也称变量命名空间，每一个函数定义自己的命名空间，函数内部定义的变量为局部变量。python解释器建立一个全局命名空间，全局变量就放在这个空间。

全局变量：定义在函数外，作用域为整个程序。
局部变量：定义在函数内，作用域为函数内部，形参也是局部变量。

global关键字：
函数调用不能修改全局变量

```py
num1=6
def fun1():
    num1=2
    print("函数内修改后num1=",num1)
print("运行func1函数前num1=",num1)
fun1()
print("运行func1函数后num1=",num1)
#得到：
#运行func1函数前num1= 6
#函数内修改后num1= 2
#运行func1函数后num1= 6
```

全局变量num1=6，在函数func1内部修改变量num1的值，调用完函数func1后第7行代码输出num的值，发现在函数外部num的值并没有发生改变。这是因为函数内部、的num1是一个局部变量，对局部变量的任何修改不会影响同名的全局变量。

想要在函数内部修改全局变量的值，可以用关键字global进行声明。希望在函数中使用全局变量，而不是创建局部变量，需要用global关键字声明。函数中先声明global s   再s=1   这样全局变量s变成了1

```py
num1=6#全局变量
def fun1():
    global num1 #用global声明变量num1
    num1=2
    print("func1函数内修改后num1=",num1)
print("运行func1函数前num1=",num1)
fun1()
print("运行func1函数后num1=",num1)
#得到：
#运行func1函数前num1= 6
#func1函数内修改后num1= 2
#运行func1函数后num1= 2
```

func1中使用global声明num1，那么在该函数内部访问的num1就是全局变量num1，所以对它的修改也就是对全局变量的修改。



## 面向对象程序设计

在面向对象程序设计中，把数据以及处理数据的方法封装在一起，组成一个整体（对象）

### 类和对象

类是一种对象模板和数据类型，它定义了对象的属性（数据），并提供用于初始化对象的初始化程序和操作这些属性的方法

对象是类的一个实例，使用构造方法来创建一个对象，使用圆点运算符（.）通过引用方法和变量来访问对象的成员

- 创建一个`Students`对象`s1`：`s1 = Students('31700001','zjuzhang')`

- 创建一个字符串对象`s`：`s = 'adghdkjas'`

  > 对象和实例经常可以互换的
  >
  > 类：字符串，列表，字典，整形......
  >
  > 对象：`s1,s2`

***

### 面向对象三个特点

#### 类的封装

类的封装：把有些变量数据封装起来，使通过方法来访问，不允许对象访问，将数据和数据的操作组合起来，类是一个不可分割的独立单位

`python`中类的成员包括变量（数据，属性）和方法（函数）

##### 类和对象的变量

- 类的变量：是一个类的全局变量，可以给该类的所有对象（实例）使用，当某个对象对类的变量做了改动时，这个改动会反映到所有实例上

  类变量：是在类中所有方法之外进行定义的，如：`price = 1000`

- 对象的变量：不同的变量调用该变量，其值改变后互不影响，是类的每个对象/实例拥有的

  实例变量：一般是指在构造方法`__init__()`中定义的，定义和使用时需要以`self`作为前缀，如`self.color = red`

##### 类的方法

类的方法：在类的内部可以使用`def`关键字定义一个方法，类的方法必须包含参数`self`，且作为第一个参数

构造方法`__init__()`

> `__init__`方法：一个类只能有一个`__init__`方法，用于初始化类及其变量

私有方法是在类的内部使用的，两个下划线开头，不能在类的外部调用，只能在内部调用

私有成员与公有成员:

- `_xxx`：受保护成员，不能用`form module import *`导入
- `__xxx__`：系统定义的特殊成员
- `__xxx`：私有成员，只有类内自己能访问，不能使用对象直接访问到这个成员

其他形式名称的成员，都是公有成员，公有成员在类体内和类体外都可以直接访问

#### 类的继承

类的继承：从一个通用类（父类），扩展更多特定的类（子类）

> 私有成员不能继承

```python
 # 父类
class Car():   
    price = 300000   # 定义类变量 
    def __init__(self, name):
        self.name = name    # 定义实例变量
        self.color = ""
        
    def setColor(self, color):  # 定义方法
        self.color = color
 
class ECar(Car):    # 子类ECar继承父类Car
    def __init__(self, name):
        super().__int__(name)   # 初始化父类的属性，使用父类的构造方法
        self.battery_size = 300
```

#### 类的多态

类的多态：子类的对象可以传递给需要父类类型的参数

***

### 类和对象的创建和使用

`python`使用`class`关键字来定义类，`class`关键字之后一个空格，然后是类的名字，再然后是一个冒号，最后换行并定义类的内部实现

```python
class Classname:
    initializer   # 初始化
    methjods      # 定义方法
```

> - `isinstance()`：测试一个对象是否为某个类的实例
> - `isinstance(s1, Student)`：判断对象`s1`是不是`Student`类的实例

访问对象：

通过对象名.成员名的形式访问对象的数据成员或方法成员，如`s1.name`

```py
class Fruit:
    price=0
    def __init__(self):
        self.color = 'Red'     # 定义和设置私有属性color
        self.city = 'Kunming'	 # 定义和设置私有属性city
        
    @ staticmethod
    def getPrice():		    # 定义静态方法getPrice
         return Fruit.price
        
    @ staticmethod
    def setPrice(p):		# 定义静态方法setPrice
        Fruit.price=p
```

> `@ staticmethod`标识的方法是静态方法，静态方法属于类，静态方法通过类名调用，静态方法中不能访问实例属性，只能访问属于类属性

变量值的修改：

1. 直接通过对象进行修改：

   ```python
   s4 = Student("lei", "15415616")
   s4.gpa = 3.8  # 直接通过对象进行修改
   ```

2. 通过方法进行设置(常用)

   ```python
   def setGpa(self, gpa):
      self.gpa = gpa
   s5.setGpa(3.6)
   ```

定义`makeStudent`方法，用于创建对象

```py
def makeStudent(infoStr):
   name,num,credits,qpoints = infoStr.split("\t")
   return StudentGPA(name,num,credits,qpoints)
```



## 文件系统

### 文件操作

计算机文件包括：二进制文件和文本文件
在`Windows`平台中，扩展名为`.txt`、`.log`、`.ini`的文件都属于文本文件。在`Windows`中创建的文本文件默认是`gbk`编码格式，`Pycharm`中默认是`utf-8`编码格式，在打开文件时通常需要设置编码格式参数:

```py
f1 = open( 'file1.txt','r',encoding="gb2312")    # 以读模式打开文件
fp=open(r"C:\Users\Asus\Desktop\111.txt","rt", encoding='UTF-8')# 可以读取中文
```

#### 打开文件

打开文件需要使用`open()`函数：

```py
textFile=open("7-1.txt","rt")   # t表示文本的形式
t = textFile.readline()    # 调用对象的readline()函数来读取文件内容
print(t)  # 把文件的内容显示出来
textFile.close()   # 关闭文件

textFile=open("7-1.txt","rb")   # b表示以二进制形式打开
```

`fileobj = open(filename, mode)`

> - `fileobj`是`open()`返回的文件对象
>
> - `filename`是要打开的文件的路径和名称（文件路径描述方式：不转义，例` r’D:\Python\code\test.txt’`(首选)）
>
> - `mode`的参数值：r(只读)  w(只写)  a(追加)  x(新建)  
>
>   `mode`是文件类型和操作的字符串，有两个字母类型，第一个字母表示对其操作，r只读模式（默认），w覆盖写模式，a追加模式，x创建写模式；第二个是文件类型，t 表示文本的形式（默认形式，可省略），b 表示以二进制形式打开

当对文件内容操作完以后，一定要关闭文件对象`fileobj.close()`，这样才能保证所做的任何修改都确实被保存到文件中

#### 读写操作

##### 文件的读取

文件读写操作的相关函数：

- `read(size) ` ：从文件读取长度为`size`的字符串，如果给定为负值就读取所有内容
- `readline()` ：读取一行
- `readlines()`：读取所有行返回列表

多行文件的读写：

```py
f = open("score.txt", "r")
for line in f.readlines():
  print(line)
f.close()

with open('sample.txt') as fp:
    for line in fp:       # 文件对象是可以迭代的
        print(line)
```

读取文本文件整个内容：

```py
fp = open(r"C:\Users\Asus\Desktop\111.txt", "rt", encoding='UTF-8')
t=fp.read(-1)    # 返回t的类型是字符串
print(t)
fp.close()
```

查找文件时换行符也算一个字符，但是在字符串里面不显示，但会算做一个下标索引

##### 文件的写入

写入文件：`file.write(string)`

```py
s = 'Hello world\n文本文件的读取方法\n文本文件的写入方法\n'
f = open(r"C:\Users\Asus\Desktop\222.txt", "a+", encoding='UTF-8') # 打开文件
f.write(s)  # 写入文件内容
f.close()  # 关闭文件
```

输入输出重定向

```py
sys.stdin   # 标准输入
sys.stdout  # 标准输出
sys.stderr  # 标准错误输出

import sys
s=sys.stdin.readlines()
```



## 语义操作系统

`os`，又叫语义操作系统，管理着操作系统的相关功能，用于处理文件和目录这些我们日常需要手动完成的操作

`os`是`python`中的一个包，使用的时候需要进行导入：`import os`

`os`下面有很多函数，调用方式一般为`os.name`，其中比较特殊的是`path`，`path`模块是`os`的一个子模块，下面又有很多的函数，调用方式一般为`os.path.isfile`

我们可以通过下面的两种方式进行具体函数的查看：

```python
# 查看os下的函数
print(dir(os))
# 查看os.path下的函数
print(dir(os.path))
```

### 常见函数

|      函数       |                             描述                             |                  具体使用                   |
| :-------------: | :----------------------------------------------------------: | :-----------------------------------------: |
|   `os.name()`   | 显示当前使用的平台，`'nt'`表示`Windows`，`'posix'` 表示`Linux` |                  `os.name`                  |
|  `os.getcwd()`  |                    返回当前进程的工作目录                    |                `os.getcwd()`                |
|  `os.chdir()`   |              改变当前工作目录到指定的路径`path`              |              `os.chdir(path)`               |
| `os.makedirs()` | 用于递归创建目录，可以指定创建目录的用户权限设置，默认为`0o777`（十六进制）的权限，表示所有者，所属者和其他用户都有读、写和执行权限 |       `os.makedirs(path, mode=0o777)`       |
|  `os.mkdir()`   |     以数字权限模式创建目录，默认的模式为 `0777 `(八进制)     |         `os.mkdir(path, mode=0777)`         |
| `os.listdir()`  |        列出目录下的所有文件和文件夹，以数组的形式返回        |             `os.listdir(path)`              |
|  `os.remove()`  | 用于删除指定路径的文件，如果指定的路径是一个目录，将抛出`OSError`异常 |              `os.remove(path)`              |
|  `os.rename()`  | 命名文件或目录，能对相应的文件进行重命名，`src`表示要修改的目录/文件名；`dst`表示修改后的目录/文件名 |            `os.rename(src, dst)`            |
| `os.renames()`  | 用于递归重命名目录或文件（目录和文件可以同时进行改名）,类似`rename()`，既可以重命名文件, 也可以重命名文件的上级目录名 | `os.renames("dist/test.py","DIST/TEST.py")` |
| `os.linesep()`  | 显示当前平台用于分隔（或终止）行的字符串，如` POSIX` 上是` '\n'`; `Windows` 上是 `'\r\n'` |                `os.linesep`                 |
| `os.close(fd)`  |        关闭指定的文件描述符，`fd`表示打开文件时的赋值        |               `os.close(fd)`                |
|   `os.stat()`   |                     获取文件或者目录信息                     |               `os.stat(path)`               |
|   `os.sep()`    | 显示当前平台下路径分隔符,在 `POSIX`上是` '/'`，在 `Windows` 上是` '\'` |                  `os.sep`                   |

***

### 子函数`path`中常见的函数

|           函数           |                             描述                             |             具体使用             |
| :----------------------: | :----------------------------------------------------------: | :------------------------------: |
|   `os.path.abspath()`    |                      返回文件的绝对路径                      |     `os.path.abspath(path)`      |
|   `os.path.basename()`   |        返回文件名，纯粹字符串处理逻辑，路径错误也可以        |     `os.path.basename(path)`     |
| `os.path.commonprefix()` | 返回`list`(多个路径)中，所有`path`共有的最长的路径，`list`是数组的形式 |   `os.path.commonprefix(list)`   |
|   `os.path.dirname()`    |     返回文件路径，文件在哪个文件夹下，返回该文件夹的路径     |     `os.path.dirname(path)`      |
|    `os.path.exists()`    | 如果路径 `path` 存在，返回 `True`；如果路径 `path` 不存在，返回 `False` |      `os.path.exists(path)`      |
|   `os.path.lexists()`    | 路径存在则返回`True`，路径损坏也返回`True`， 不存在，则返回 `False` |        `os.path.lexists`         |
|  `os.path.expanduser()`  |         把`path`中包含`~`和`“user”`的转换成用户目录          |            见具体列举            |
|  `os.path.expandvars()`  |   根据环境变量的值替换`path`中包含的`"$name"`和`"${name}"`   |            见具体列举            |
|   `os.path.getatime()`   | 返回最近访问时间（浮点型秒数，时时间戳），从新纪元到访问时的秒数 |     `os.path.getatime(path)`     |
|   `os.path.getmtime()`   |              返回最近文件修改时间，以时间戳返回              |     `os.path.getmtime(path)`     |
|   `os.path.getctime()`   |                   返回文件路径创建的时间戳                   |     `os.path.getctime(path)`     |
|   `os.path.getsize()`    |            返回文件大小，如果文件不存在就返回错误            |     `os.path.getsize(path)`      |
|    `os.path.isabs()`     |                      判断是否为绝对路径                      |      `os.path.isabs(path)`       |
|    `os.path.isfile()`    |    判断路径指向的是否为文件，文件不存在返回的也是`False`     |      `os.path.isfile(path)`      |
|    `os.path.isdir()`     |                   判断路径指向的是否为目录                   |      `os.path.isdir(path)`       |
|     `os.path.join()`     | 把目录和文件名合成一个路径，注意：如果各组件名首字母不包含`’/’`，则函数会自动加上；如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃；如果最后一个组件为空，则生成的路径以一个`’/’`分隔符结尾 |            具体见列举            |
|   `os.path.normcase()`   |                   转换`path`的大小写和斜杠                   |            具体见列举            |
|   `os.path.normpath()`   |                     规范`path`字符串形式                     |     `os.path.normpath(path)`     |
|   `os.path.realpath()`   |                     返回`path`的真实路径                     |     `os.path.realpath(path)`     |
|   `os.path.samefile()`   |                    判断目录或文件是否相同                    | `os.path.samefile(path1, path2)` |
|    `os.path.split()`     | 把路径分割成 `dirname`（目录） 和 `basename`（文件），返回一个元组 |            具体见列举            |
|  `os.path.splitdrive()`  |      一般用在`windows `下，返回驱动器名和路径组成的元组      |            具体见列举            |
|   `os.path.splitext()`   |            分割路径，返回路径名和文件扩展名的元组            |            具体见列举            |
|     `os.path.walk()`     |           遍历`path`，进入每个目录都调用visit函数            |            具体见列举            |

复杂形式的列举：

- `os.path.expanduser()`：把`path`中包含`~`和`“user”`的转换成用户目录

  ```python
  os.path.expanduser('~/Desktop/股票数据分析/')
  'C:\\Users\\jlc/Desktop/股票数据分析/'
  ```

- `os.path.expandvars()`：根据环境变量的值替换`path`中包含的`"$name"`和`"${name}"`

  ```python
  os.environ['KITTIPATH'] = 'D:/thunder'
  path = '$KITTIPATH/train/date.png'
  os.path.expandvars(path)
  'D:/thunder/train/date.png'
  ```

- `os.path.join()`：把目录和文件名合成一个路径，注意：如果各组件名首字母不包含`’/’`，则函数会自动加上；如果有一个组件是一个绝对路径，则在它之前的所有组件均会被舍弃；如果最后一个组件为空，则生成的路径以一个`’/’`分隔符结尾

  ```python
  os.path.join('C:/Users','jlc/Desktop/','date.png')
  'C:/Users\\jlc/Desktop/date.png'
  ```

- `os.path.normcase()`：转换`path`的大小写和斜杠

  ```python
  os.path.normcase('D:\Python\test\data.txt')
  'd:\\python\test\\data.txt'
  ```

- `os.path.split()`：把路径分割成 `dirname`（目录） 和 `basename`（文件），返回一个元组

  ```python
  os.path.split('D:\Python\test\data.txt')
   ('D:\\Python\test', 'data.txt')
  ```

- `os.path.splitdrive()`：一般用在`windows `下，返回驱动器名和路径组成的元组

  ```python
  os.path.splitdrive('C:/Users/date.JPG')
  ('C:', '/Users/date.JPG')
  ```

- `os.path.splitext()`：分割路径，返回路径名和文件扩展名的元组

  ```python
  os.path.splitext('C:/Users/date.JPG')
  ('C:/Users/date', '.JPG')
  ```

- `os.path.walk(path, visit, arg)`：遍历`path`，进入每个目录都调用`visit`函数，`visit`函数必须有3个参数`(arg, dirname, names)`，`dirname`表示当前目录的目录名，`names`代表当前目录下的所有文件名，`args`则为`walk`的第三个参数

  ```python
  # 穷举遍历一个文件夹里面的所有文件，并获取文件的目录名
  abs_cur_dir = 'C:/Users/Desktop/data'
  file_url = []
  for dirs, folders, files in os.walk(abs_cur_dir):
      for i in files:
          file_url.append(os.path.join(dirs, i))
  ```



## 网络爬虫

网络爬虫需要下载以下相关的库：

- `pip install requests`
- `pip install beautifulsoup4`
- `pip install lxml`
- `pip install html5lib`或者`pip install requests-html`

返回网站`html`也的文本代码信息：

```py
import requests
url = "https://jww.zjgsu.edu.cn/2021/1224/c1331a111803/page.html"
res = requests.get(url)
print(res.text.encode("ISO-8859-1").decode("utf-8"))	

res = requests.get('http://www.baidu.com')
print(res)
# 返回200，表示请求网址成功，若为4xx，表示请求失败
```

> - `response.encoding` ：打印网页编码
> - `response.text` ：返回文本信息
> - `response.content` ：返回二进制数据
> - `response.status_code` ：返回响应状态码
> - `response.url`：返回访问的网址
> - `response.headers` ：返回`http`响应报头

`requests-html`全部功能只支持`python3.6`以及以后的版本

```py
from requests-html import HTMLSession
session = HTMLSession()
url = 'https://www.dxsbb.com/news/7566.html'
r = session.get(url)
table = r.html.find('tbody>tr')
for row in table[:21]:
    l=row.text.split()
    s=''
    for i in l:
        s=s+'{0:^14}'.format(i)
    print(s)
    f = open(r"C:\Users\Asus\Desktop\111.txt","a+", encoding='UTF-8') 
    f.write(s + '\n')
f.close() 
```

豆瓣爬取书籍排名：

```py
import requests
from lxml import etree
headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0'}
html = requests.get('https://book.douban.com/top250', headers = headers).text
res = etree.HTML(html)
names = res.xpath('//*[@id="content"]/div/div[1]/div/table/tr/td[2]/div[1]/a/text()')
for name in names:
    print(name.strip())
```

其他爬取：（爬取古诗，分段）

```py
import requests
from lxml import etree
#headers = {'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0'}
html = requests.get('https://so.gushiwen.cn/shiwenv_d16797ee39e4.aspx').text
res = etree.HTML(html)
names = res.xpath('//*[@id="contsond16797ee39e4"]/text()')
print(names)
name='\n'.join(names)
print(name)
f = open(r"C:\Users\Asus\Desktop\111.txt","a+", encoding='UTF-8')
f.write(name)
f.close()
```

爬取图片：

```py
import requests
response = requests.get('https://github.com/favicon.ico')    # 图片链接
with open('favicon.ico','wb')as f:         # favicon.ico 图片名字，可修改
	f.write(response.content)
```



## 使用技巧

### 离线安装`pip`包

有时开发环境需要进行离线使用，或者在线下载的时候由于网络问题我们下载不了这个包，这时我们就需要进行离线安装`pip`包

#### 下载`whl`压缩包

在网上的`pip`镜像网站中下载需要的包的`pip`文件

常用的下载网站有：

- [清华源](https://pypi.tuna.tsinghua.edu.cn/simple/)在`simple`路径后面加需要的包进行搜索即可

  > 有`rc`的表示预发布版本

- [PyPI · The Python Package Index](https://pypi.org/)

#### 离线安装`whl`压缩包

在`python`或者虚拟的`python`环境下，我们运行下面代码安装相关包：

`python -m pip install D:\Myproject\Cesium\linan-server\wheels\wheels\loguru-0.7.2-py3-none-any.whl`

有时候在安装某个包的时候需要预先安装其他的包，那我们就要根据提示去下载安装对应的包，最后在安装这个离线包即可

***

### 使用`loguru`打印日志文件

`loggur`——旨在为` Python` 带来愉快的日志记录

安装：`pip install loguru`

导入：`from loguru import logger`

简单的使用：

```py
logger.debug('this is a debug message')
logger.info('this is a info message')
logger.warning('this is a warning message')
logger.error('this is a error message')
logger.critical('this is a critical message')
```

结果显示：实际终端中会有颜色区分

```ssh
2024-08-07 13:37:18.773 | DEBUG    | __main__:main:225 - this is a debug message
2024-08-07 13:37:18.773 | INFO     | __main__:main:226 - this is a info message
2024-08-07 13:37:18.773 | WARNING  | __main__:main:227 - this is a warning message
2024-08-07 13:37:18.773 | ERROR    | __main__:main:228 - this is a error message
2024-08-07 13:37:18.774 | CRITICAL | __main__:main:229 - this is a critical message
```

默认的输出格式是上面的内容，有时间、级别、模块名、行号以及日志信息，不需要手动创建` logger`，直接使用即可

配置生成的日志文件

之前的日志信息是直接输出到控制台的，并没有输出到其他的地方，如果想要输出到其他的位置，比如存为文件，我们只需要使用一行代码声明即可：

```py
logger.add("./logs/received_message{time}.log", rotation="500 MB", encoding='utf-8')
```

> 配置日志文件：将生成的日志信息存入到log文件下以`received_message`为前缀的`log`文件中，日志文件最大为`500MB`

还有其他的常用功能：

```py
# 使用 format、filter、level 来规定输出的格式
logger.add(sys.stderr, format="{time} {level} {message}", filter="my_module", level="INFO")
# 每超过500M创建一个新文件输出保存
logger.add("./logs/received_message{time}.log", rotation="500 MB")
# 每天12:00创建一个新文件输出保存
logger.add("./logs/received_message{time}.log", rotation="12:00")
# 每隔一周创建一个新文件输出保存
logger.add("./logs/received_message{time}.log", rotation="1 week")
# 设置日志文件最长保留 10 天
logger.add("./logs/received_message{time}.log", retention="10 days")
# 使用 zip 文件格式保存
logger.add("./logs/received_message{time}.log", compression="zip")
```

