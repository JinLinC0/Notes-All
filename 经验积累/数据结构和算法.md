# 数据结构和算法

## 算法的复杂度

### 时间复杂度

时间复杂度指的是算法的执行效率，具体而言是算法的执行时间与算法的输入值之间的关系，时间复杂度使用大`O`表示法进行表示

在写代码的过程中，需要注重时间复杂度，使我们的代码变得更加高效

```python
def test(N):
    total = 0
    for i in range(N):
        total += i
    return total
```

> 对于上述的代码，我们要计算其时间复杂度，我们假设执行`total = 0`的时间为`a`；执行`total += i`的时间为`b`；执行`return total`的时间为`c`，那么执行上述程序的总时间为`a+N*b+c`
>
> 对于小的时间（常量的时间，固定的），我们在计算时间复杂度的时候可以进行忽略
>
> 时间复杂度也不会关心具体的系数，如`N*b`，其`b`是可以进行忽略的
>
> 因此上述代码的时间复杂度为`O(N)`；代码中对时间最大的影响是`for`循环

我们计算时间复杂度，一般观察代码中是否有`for`循环或者`while`循环，如果有，那么其时间复杂度一般是`O(N)`或者`O(logN)`等

#### 常见的时间复杂度

常见的时间复杂度有：

- `O(1)`：表示算法的执行时间和输入的值没有关系，不管输入的值有多大，算法的执行时间都不变

  ```python
  def O1(num):
      i = num
      j = num * 2
      return i + j
  ```

  > 没有`for`和`while`循环的代码，其时间复杂度一般都是`O(1)`

- `O(N)`：

  ```python
  def ON(num):
      total = 0
      for i in range(num):
          total += i
      return total
  ```

  > 循环的常量是0到`num`，执行的循环有`num`次，因此时间复杂度为`O(N)`

- `O(M+N)`

  ```python
  def OMN(num1, num2):
      total = 0
      for i in range(num1):
          total += i
      for j in range(num2):
          total += j
      return total
  ```

  > 并列循环的时间复杂度计算是加法运算
  >
  > 第一个`for`循环的时间复杂度为`O(M)`，第二个`for`循环的时间复杂度为`O(N)`
  >
  > 因此，总的时间复杂度为`O(M+N)`

- `O(logN)`（最典型的是二分查找法）

  ```python
  def OlogN(num):
      i = 1
      while (i<num):
          i = i * 2
      return i
  ```

  > 上述代码循环了`log2N`次，因此时间复杂度为`O(logN)`

- `O(NlogN)`（排序中出现的较多）

  ```python
  def ONLogN(num1, num2):
      total = 0
      j = 1
      for i in range(num1):
          while(j < num2):
              total += i + j
              j = j * 2
      return total
  ```

  > 对于嵌套循环的时间复杂度计算，是一个乘法运算，第一个循环的时间复杂度是`O(N)`，内部循环的时间复杂度是`O(logN)`，因此，总的时间复杂度是`O(NlogN)`

- `O(N^2)`

  ```python
  def ON2(num):
      total = 0
      for i in range(num):
          for j in range(num):
              total += i + j
      return total
  ```

  > 对于嵌套循环的时间复杂度计算，是一个乘法运算，第一个循环的时间复杂度是`O(N)`，内部循环的时间复杂度是`O(N)`，因此，总的时间复杂度是`O(N^2)`

#### 时间复杂度的效率对比

我们在编写代码的时候，需要力求我们写出的代码有最低的时间复杂度，常见时间复杂度的对比关系为：

![image-20250615113335505](../images/image-20250615113335505.png)

***

### 空间复杂度

空间复杂度是算法存储空间与输入值之间的关系

代码中的变量也是要占据空间的

#### 常见的空间复杂度

- `O(1)`

  ```python
  def test(num):
      total = 0
      for i in range(num):
          total += i
      return total
  ```

  > 上述代码的空间复杂度是`O(1)`
  >
  > 声明一个变量`total`是会占据空间的（时间复杂度是常量级别的，只占一个`int`类型大小的空间），但是对于`for`循环是不占据空间的（只是运行，而不在内部存储数据）
  >
  > 如果变量等于某一个常量的情况下，其空间复杂度永远是`O(1)`
  >
  > 但是，特殊情况，对于递归，是一层层往下的，每一层的信息都会保留在递归栈中，因此，空间复杂度一般是`O(N)`

- `O(N)`

  ```python
  def test(nums):
      array = []
      for num in nums:
          array.append(num)
      return array
  ```

  > 数组中的一个元素占据的是一个`int`，四个字节，在`for`循环中，每循环一次，会在数组中插入一个元素，因此`array`占据的空间与输入值之间呈正比
  >
  > 因此，代码的空间复杂度为`O(N)`

常见的空间复杂度一般是`O(1)`和`O(N)`，还有其他用的较少的有`O(N^2)`、`O(logN)`、`O(NlogN)`

#### 空间复杂度的效率对比

对于空间复杂度的效率对比：`O(1)<O(N)<O(N^2)`

空间复杂度越小，表示算法越好

但是，对于时间和空间复杂度只能二选一的情况，有的时候是拿空间换时间，有的时候是拿时间换空间，在面试的时候，将时间复杂度最好的方法和空间复杂度最好的方法都讲清楚；在工作中，一般先考虑时间复杂度最优的方法



## 数组`Array`

数组作为一种重要的数据结构类型，在**连续的内存空间中**，存储一组**相同类型**的元素

数组的索引都是从0开始的（索引表示其元素在内存空间中相对于第一个元素的位置）

数组自带第一个元素存储的位置，如果存储的类型是整数`int`类型，占4个字节，如果第一个元素一开始的内存地址是100，那么第二个元素的内存地址就是104，依次类推

- 数组的访问：通过下标索引去访问数组中对应的元素：`a[1]`
- 数组的搜索：查找数组中的某一个元素，如查找数组中的某个元素的索引是什么，或者查找数组中有没有值为2的元素

***

### 数组操作的时间复杂度

- 访问操作的时间复杂度为`O(1)`

  如果要访问索引为2的元素，其具体的存储地址计算为（默认第一个元素的内存地址为100，且数组存放的是`int`类型的数据）100+2*4 = 108，因此，索引为2的元素，其内存地址为108，最后，直接去地址为108的地方去访问，读取元素的数据即可，因此，其时间复杂度为`O(1)`

- 搜索操作的时间复杂度为`O(N)`

  对于搜索操作，我们需要从头到尾遍历一遍该数组（最坏的情况要从头到尾进行一遍遍历）

- 插入操作的时间复杂度为`O(N)`

  数组是一个连续的内存空间，而且只知道其第一个元素的内存地址，对于插入操作，需要将后面的元素往后进行移动，对于最坏的情况（在第一个元素之前插入数据）我们需要将所有的元素都往后进行移动一位，因此插入操作的时间复杂度是`O(N)`

  插入操作，对于原先数组中，内存空间不足的情况下，我们需要开辟一块新的内存空间，将数据依次填充进去，因此时间复杂度也是`O(N)`

- 删除操作的时间复杂度为`O(N)`

  删除操作和插入操作的时间复杂度原理类似，数组中去除一个元素，后续需要将后面的元素在内存中的存储位置进行向前移动，最坏的情况下（删除第一个元素）我们需要将所有的元素都往前进行移动一位，因此删除操作的时间复杂度是`O(N)`

数组的特点：适合读取，不适合写（在读多写少的情况下适合使用数组）

***

### `Java`中数组的常用操作

#### 创建数组

在`Java`中，创建数据有四种方式：后面两种方法使用的较多

- `int[] a = {1,2,3};`

- `int[] b = new int[]{1,2,3};`

- `int[] c = new int[3];`    开辟三个占位符，默认值为0

- `ArrayList<Integer> arr = new ArrayList<>();`

  创建了一个数组列表，并指定了数组元素的对象类型，使用`ArrayList`创建数组，一开始可以不指定数组的长度，也不需要指定数组一开始有哪些元素，而且内置的方法比较多，但是需要导入`ArrayList`的包

#### 添加元素

对于创建数组的前三种方法进行添加元素是非常麻烦的，我们需要重新的新建一个数组，将原来3个长度的数组，变成4个长度的数组，最后在添加新的元素

但是使用`ArrayList`创建的数组，一开始是不需要指定数组长度的，可以使用内置方法`add()`进行数组元素的添加：`arr.add(4);`  默认插入到原数组的最后，其时间复杂度是`O(1)`（在内存空间充足的情况下），如果内存空间不足时，其添加操作的时间复杂度是`O(N)`

`arr.add(3, 88);`在索引为3的位置，插入元素88，这时的时间复杂度只有一种情况，为`O(N)`

#### 访问元素

在数组中访问元素是通过下标索引进行访问的

- 对于创建数组的前三种方法进行访问元素：`int x = c[1];`
- 对于使用`ArrayList`创建的数组进行访问元素：`int x = arr.get(1);`

访问元素的时间复杂度是`O(1)`

#### 更新元素

- 对于创建数组的前三种方法进行更新元素：`c[1]= 11;`
- 对于使用`ArrayList`创建的数组进行访问元素：`arr.set(1, 11);`

更新元素的时间复杂度是`O(1)`

#### 删除元素

对于创建数组的前三种方法进行删除元素是非常麻烦的，推荐使用`ArrayList`创建的数组进行删除元素的操作

`arr.remove(3);`  传入要删除元素的值；删除元素的时间复杂度是`O(N)`

#### 获取数组的长度

- 对于创建数组的前三种方法进行数组长度的获取：`int cSize = c.length;`
- 对于使用`ArrayList`创建的数组进行数组长度的获取：`int arrSize = arr.size();`

获取数组的长度的时间复杂度是`O(1)`  在创建一个数组时，其内部会维持一个`count`的变量，元素增加和删除时，这个变量会随之改变，获取长度时，会直接返回这个变量

#### 遍历数组

- 对于创建数组的前三种方法进行遍历数组：

  ```java
  for (int i = 0; i < c.length; i++) {
      int current = c[i];
      System.out.println(current);
  }
  ```

- 对于使用`ArrayList`创建的数组进行遍历数组：

  ```java
  for (int i = 0; i < arr.size(); i++) {
      int current = arr.get(i);
      System.out.println(current);
  }
  ```

遍历数组的时间复杂度是`O(N)`

#### 查找元素

- 对于创建数组的前三种方法进行查找元素：

  ```java
  for (int i = 0; i < c.length; i++) {
      if (c[i] == 3) {
          System.out.println("true");
      }
  }
  ```

- 对于使用`ArrayList`创建的数组进行查找元素：

  ```java
  boolean is8 = arr.contains(3);
  System.out.println(is8);
  ```

查找数组中元素的时间复杂度是`O(N)`

#### 数组排序

- 对于创建数组的前三种方法进行数组排序：`Arrays.sort(c);`    从小到大进行排序

- 对于使用`ArrayList`创建的数组进行访问元素：`Collections.sort(arr);`   从小到大进行排序

  从大到小进行排序：`Collections.sort(arr, Collections.reverseOrder());`

数组排序的时间复杂度是`O(NlogN)`

***

### 经典力扣题

#### 最大连续1的个数（485）

给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。

输入：`nums = [1,1,0,1,1,1]`
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count = 0;
        int maxCount = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1) {
                count++;
            } else {
                maxCount = maxCount > count ? maxCount : count;
                count = 0;
            }
        }
        maxCount = maxCount > count ? maxCount : count;
        return maxCount;
    }
}
```

#### 移动零（283）

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。请注意 ，必须在不复制数组的情况下原地对数组进行操作。

输入: `nums = [0,1,0,3,12] `   输出: `[1,3,12,0,0]`

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int index = 0;
        int size = nums.length;
        for (int i = 0; i < size; i++) {
            if (nums[i] != 0) {
                nums[index] = nums[i];
                index = index + 1;
            }
        }
        for (int i = index; i < size; i++) {
            nums[i] = 0;
        }
    }
}
```



## 链表`Linked List`

相对于数组只能在完整且连续的内存空间中存储数据，链表可以在任意的内存地址中存储数据

在链表中，不仅仅有元素数据，还有`next`指针（用于指向下一个元素，最后一个元素的`next`指针指向了`null`节点）将元素串起来了，形成了链的结构

链表有两种形式：单端链表（只能从前一个元素指向后一个元素，做算法题一般都只涉及到单端链表）和双端链表（不仅有`next`指针，用于指向后一个元素，还有前指针，用于指向前一个元素）

***

### 链表操作的时间复杂度

- 访问操作的时间复杂度为`O(N)`

  对于链表的访问操作，最坏的情况需要遍历整个链表（一步步通过当前元素的`next`指针进行查找下一个元素，直到找到符合条件的元素为止）

- 搜索操作的时间复杂度为`O(N)`

  对于搜索操作，我们需要从头到尾遍历一遍该链表（最坏的情况要从头到尾进行一遍遍历）

- 插入操作的时间复杂度为`O(1)`

  在链表中进行元素的插入，消耗的时间复杂度是非常低的，直接在任意的内存中存储元素的数据，然后根据该元素要存储的位置，断开前后节点的`next`指针，连接到新增元素节点的前后即可，因此，链表的插入操作这个过程的时间复杂度为`O(1)`，但是找到要插入位置的索引，需要循环一次该链表

- 删除操作的时间复杂度为`O(1)`

  链表的删除操作与插入操作同理，如果要删除元素，只需断开其前后的指针即可，避开这个要删除的元素，重新连接起来即可，因此对于删除这个操作，其时间复杂度为`O(1)`，但是找到要删除位置的索引，需要循环一次该链表

数组的特点：适合写，不适合读取（在写多读少的情况下适合使用链表）

在刷力扣时，如果要使用链表，对于链表的数据结构，力扣都会给出（`value`（指向当前节点元素的值）和`next`（指向下一个节点））

***

### `Java`中链表的常用操作

#### 创建链表

```java
LinkedList<Integer> list = new LinkedList<>();
```

#### 添加元素

- 在链表的尾部依次进行插入元素：`list.add(1);`   其时间复杂度为`O(1)`
- 在链表的指定位置插入元素：`list.add(2, 99);` 在索引为2的位置插入元素，其值为99，我们要找到索引为2的位置，因此需要循环一次链表，因此时间复杂度为`O(N)`

#### 搜索元素

```java
int index = list.indexOf(99);    // 搜索值为99的元素的索引
```

搜索链表元素，需要从到到尾对链表进行遍历，因此时间复杂度为`O(N)`

#### 更新元素

```java
list.set(2, 88);    // 在索引为2的位置，将元素的值更改为88
```

更新链表元素，需要从到到尾对链表进行遍历，因此时间复杂度为`O(N)`

#### 删除元素

```java
list.remove(2);     // 将链表中，索引为2的元素删除
```

删除链表元素，需要从到到尾对链表进行遍历，因此时间复杂度为`O(N)`

#### 获取链表的长度

```java
int length = list.size();
```

获取链表的长度的时间复杂度为`O(1)`，在初始化链表的时候，有一个变量，当我们在添加元素的时候，就会加一，在删除元素的时候，就会减一，当我们要获取链表长度时，就会将这个值返回，因此，获取链表的长度的时间复杂度为`O(1)`

***

### 经典力扣题

#### 移除链表元素（203）

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 新的头节点 

输入：`head = [1,2,6,3,4,5,6], val = 6`
输出：`[1,2,3,4,5]`

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;    // 当前节点的值是多少
 *     ListNode next;   // 当前节点的下一个节点是哪个节点
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;   // head表示第一个元素所在的位置，后面的元素可以通过next指针进行查找
        ListNode prev = dummy;

        while (head != null) {
            if (head.val == val) {
                // 删除节点，将节点的前一个节点的next指向该节点的后一个节点
                prev.next = head.next;
                head = head.next;  // 移动到下一个节点
            } else {
                prev = head;
                head = head.next;
            }
        }
        return dummy.next;
    }
}
```

> 如果`head`移动后，前面的节点元素就相当于被删除了，链表就是从`head`开始往下进行的，因此我们需要引入一个临时的节点`dummy`，将临时的节点放在最开始的节点前面，其临时节点的`next`指针指向第一个节点
>
> 对于删除链表中的元素节点，我们就需要将该元素节点的前面节点的`next`指针指向要删除元素的后一个节点，为了定义当前节点的前一个节点，我们需要引入一个`prev`节点，每次在`head`节点移动的时候，我们将其值赋值给`prev`节点（用于记录`head`移动之前的节点）

#### 反转链表（206）

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表

输入：`head = [1,2,3,4,5]`
输出：`[5,4,3,2,1]`

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;   
        ListNode dnext = new ListNode(0);   
        ListNode hnext = new ListNode(0);   
        
        while(head != null && head.next != null) {
            dnext = dummy.next;    // dummy的next节点
            hnext = head.next;     // head的next节点
            // 交换操作
            dummy.next = hnext;
            head.next = hnext.next;
            hnext.next = dnext;
        }
        return dummy.next;
    }
}
```



## 队列`Queue`

队列可以理解成排队，先到先得

队列相当于管道，只有一端可以入队（放数据进入管道），另一端作为出队（数据只能从这里出去），队列的特点是先入先出，在队列中有两种分类：

- 单端队列：只有一个口可以进，一个口可以出
- 双端队列：两个口都可以进，两个口都可以出

在刷题的时候，双端队列使用的不多，重点掌握单端队列即可

***

### 队列操作的时间复杂度

- 访问操作的时间复杂度为`O(N)`

  通过某个下标去找到具体的元素，由于队列是按照先进入的顺序排列的，要查找某个元素时，需要遍历整个队列，因此时间复杂度为`O(N)`

- 搜索操作的时间复杂度为`O(N)`

  搜索队列也是需要进行从头到尾进行查找的，因此时间复杂度也为`O(N)`

- 插入操作的时间复杂度为`O(1)`

  由于队列是先进先出，在插入元素的过程中，只能在队列的最后一个元素的末尾进行插入，因此时间复杂度为`O(1)`

- 删除操作的时间复杂度为`O(1)`

  对于删除队列的元素，只能删除最先进来的元素，因此时间复杂度为`O(1)`

***

### `Java`中队列的常用操作

#### 创建队列

```java
Queue<Integer> queue = new LinkedList<>();
```

> `Queue`作为队列的接口，使用链表`LinkedList`作为队列的数据结构，使队列有了链表的特性，删除添加比较快，查询比较慢

#### 添加元素

```java
queue.add(1);     // 在队列最后添加一个元素  添加元素的时间复杂度为O(1)
```

#### 获取即将要出队的元素

```java
int temp1 = queue.peek();   // 获取队列中最早进入的元素   其过程时间复杂度为O(1)
```

#### 删除即将出队的元素

```java
int temp2 = queue.poll();    // 将队列中最早进入的元素删除，并将删除的值进行返回
```

#### 判断队列是否为空

```java
System.out.println(queue.isEmpty());    // 时间复杂度为O(1)
```

#### 队列的长度

```java
System.out.println(queue.size());     // 时间复杂度为O(1)
```

#### 遍历队列

```java
while (!queue.isEmpty()) {
    int temp = queue.poll();    // 一般是边删除边遍历
    System.out.println(temp);
}
```

> 遍历队列的时间复杂度是`O(N)`

***

### 经典力扣题

#### 最近的请求次数（933）

写一个 `RecentCounter` 类来计算特定时间范围内最近的请求。

请你实现 `RecentCounter` 类：

- `RecentCounter()` 初始化计数器，请求数为 0 。
- `int ping(int t)` 在时间 `t` 添加一个新请求，其中 `t` 表示以毫秒为单位的某个时间，并返回过去 `3000` 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 `[t-3000, t]` 内发生的请求数。

保证 每次对 `ping` 的调用都使用比之前更大的 `t` 值。

输入：
`["RecentCounter", "ping", "ping", "ping", "ping"]`
`[[], [1], [100], [3001], [3002]]`
输出：
`[null, 1, 2, 3, 3]`

解释：

- `RecentCounter recentCounter = new RecentCounter();`
- `recentCounter.ping(1);     // requests = [1]，`范围是 [-2999,1]，返回 1
- `recentCounter.ping(100);   // requests = [1, 100]，`范围是 [-2900,100]，返回 2
- `recentCounter.ping(3001);  // requests = [1, 100, 3001]，`范围是 [1,3001]，返回 3
- `recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，`范围是 [2,3002]，返回 3

```java
class RecentCounter {
    private Queue<Integer> queue;
    
    public RecentCounter() {
        queue = new LinkedList<>();
    }
    
    public int ping(int t) {
        queue.add(t);
        while (queue.size() > 0 && t - queue.peek() > 3000) {
            queue.poll();
        }
        return queue.size();
    }
}

/**
 * Your RecentCounter object will be instantiated and called as such:
 * RecentCounter obj = new RecentCounter();
 * int param_1 = obj.ping(t);
 */
```



## 栈`stack`

对于队列，是先进先出的，然而，对于栈，是先进后出的

栈只有一个口进行，一个口出，因此后面进来的需要先出去

在计算机中的应用有，浏览器的回退功能，就使用到了栈的思想

***

### 栈操作的时间复杂度

- 访问操作的时间复杂度为`O(1)`

  对于栈中元素的访问，仅仅只是访问栈中栈顶的元素（最后进去的元素），因此访问操作的时间复杂度为`O(1)`

- 搜索操作的时间复杂度为`O(N)`

  对于搜索操作，我们是不知道具体的元素在哪个具体的位置的，因此我们需要遍历整个栈去搜索元素，因此，搜索操作的时间复杂度为`O(N)`

- 插入操作的时间复杂度为`O(1)`

  由于栈的特殊性，只能在栈的尾端进行元素的插入，因此时间复杂度为`O(1)`

- 删除操作的时间复杂度为`O(1)`

  对于栈的删除操作，只能删除栈顶的元素，因此时间复杂度是`O(1)`

***

### `Java`中栈的常用操作

#### 创建栈

```java
Stack<Integer> stack = new Stack<>();
```

> 通过`Stack`来声明一个栈，`Integer`表示栈中元素的类型

#### 添加元素

```java
stack.push(1);    // 由于栈的特性，每次都需要在尾部进行元素的添加，时间复杂度为O(1)
```

#### 获取栈顶元素

```java
stack.peek();     // 获取栈顶元素，即最后一个进来的元素，时间复杂度为O(1)
```

#### 删除栈顶元素

```java
int temp = stack.pop();   // 删除栈顶的元素，并将元素最为返回值返回，时间复杂度为O(1)
```

#### 获取栈的大小

```java
stack.size();     // 时间复杂度为O(1)
```

#### 判断栈是否为空

```java
stack.isEmpty();    // 时间复杂度为O(1)
```

#### 栈的遍历

```java
while (!stack.isEmpty()) {
    int num = stack.pop();    // 边删除边遍历
    System.out.println(num);
}
```

> 栈的遍历时间复杂度为`O(N)`

***

### 经典力扣题

#### 有效括号（20）

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

示例：

输入：`s = "()[]{}"`

输出：`true`

示例：

输入：`s = "(]"`

输出：`false`

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        if (s.length() == 0) return true;
        for(char c : s.toCharArray()) {
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) return false;
                char temp = stack.pop();
                if (c == ')') {
                    if (temp != '(') return false;
                } else if (c == '}') {
                    if (temp != '{') return false;
                } else if (c == ']') {
                    if (temp != '[') return false;
                } else {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }
}
```

> 使用栈的思想，对字符串进行遍历，将遍历到的左括号依次放到栈中（只要是左边的括号，都放到栈中），如果遍历到右括号，我们就将栈中最后进入的左括号取出来，与遍历到的右括号进行匹配，如果匹配成功，对字符串的循环遍历就继续
>
> 如果对字符串的循环遍历完整后，同时，栈中也没有多余的左括号了，就说明当前的字符串是一个有效的括号
>
> 如果最后栈中还有一个左括号不能和字符串中的右括号进行匹配；或者字符串中的右括号没有左括号进行匹配，说明该字符串不是一个有效括号的字符串

#### 下一个更大元素（496）

`nums1` 中数字 `x` 的 下一个更大元素 是指 `x` 在 `nums2` 中对应位置 右侧 的 第一个 比 `x` 大的元素。

给你两个 没有重复元素 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 下一个更大元素 。

示例：

输入：`nums1 = [4,1,2], nums2 = [1,3,4,2]`.
输出：`[-1,3,-1]`
解释：`nums1` 中每个值的下一个更大元素如下所述：

- 4 ，用加粗斜体标识，`nums2 = [1,3,4,2]`。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，`nums2 = [1,3,4,2]`。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，`nums2 = [1,3,4,2]`。不存在下一个更大元素，所以答案是 -1 。

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        ArrayList<Integer> res = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        for (int num : nums2) {
            stack.add(num);
        }
        for (int num : nums1) {
            Stack<Integer> temp = new Stack<>();
            boolean isFound = false;
            int max = -1;
            int top;
            while (stack.size() != 0 && !isFound) {
                top = stack.pop();
                if (top > num) max = top;
                else if (top == num) isFound = true;
                temp.add(top);
            }
            res.add(max);
            // 将temp栈的内容放回到stack栈中
            while (temp.size() != 0) {
                stack.add(temp.pop());
            }
        }
        // 返回类型是int[]，因此我们要进行转换
        int[] result = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            result[i] = res.get(i);
        }
        return result;
    }
}
```

> 使用两个栈的方式进行该问题的解决
>
> 通过栈数据结构后入先出的概念，将原数组`nums2`中的元素都放到一个栈`stack`中
>
> 对于子数组，我们通过循环遍历的方式，取元素，通过对`stack`栈的边删边取的方式，存入到另一个栈`temp`中，`top`变量用于存储从`stack`栈中取出的元素，并存到`temp`栈中，用于和要子数组遍历出的元素进行对比：
>
> - `top>num`：表示是当前循环取出的值有更大的值，后将`top`赋值给`max`（`max`默认是-1）
> - `top=num`：已经找到与循环遍历出相等的值，后续可以不再进行判断了
> - `top<num`：不需要进行任何操作
>
> 最后，当子数组中的一个元素判断完后，需要将`temp`栈中的内容返回到`stack`栈中，后续循环使用
>
> 上述算法的时间复杂度为`O(MN)`（`M`为`nums1`的长度，`N`为`nums2`的长度）；空间复杂度为`O(N)`



## 哈希表（`Hash Table`）

哈希表也叫散列表，有`key: value`键值对的概念，如学号和名字组成的键值对，我们可以通过`key`去得到具体的`value`

数组在一定意义上属于一种哈希表，哈希表的`key`可以转化为索引，数组的元素对于这个`key`存储的`value`值

每种编程语言中都会写好一种哈希表，在`Java`中 的哈希表是`HashMap`，当我们存储一对`key: value`时，会将其中的`key`取出来，通过一个哈希函数，找到一个内存地址，最后将`key`和对应的`value`放到对应的内存地址上，后续对于我们使用`key`去查找时，只需通过哈希函数，就可以找到对应的内存地址

但是上述的过程会有一个哈希碰撞的问题，即两个不同的`key`通过同一个哈希函数得到相同的内存地址

对于出现哈希碰撞的问题，我们可以通过链表的方式进行解决，通过`next`指针指向后加入的元素

***

### 哈希表操作的时间复杂度

- 在哈希表中，访问操作是不存在的

- 搜索操作的时间复杂度为`O(1)`

  对`key`进行搜索，通过`key`值的哈希函数，定位到具体的内存地址，最后读取其`value`值，就是我们要访问的值，其时间复杂度为`O(1)`

  但是如果是在哈希碰撞的情况下，其时间复杂度为`O(k)`，其中`k`为碰撞元素的个数

- 插入操作的时间复杂度为`O(1)`

  对于插入操作，直接通过哈希函数计算`key`的内存地址，之后再将`value`存入，即完成元素的插入，因此时间复杂度为`O(1)`

- 删除操作的时间复杂度为`O(1)`

  对于删除操作，直接通过哈希函数计算`key`的内存地址，之后再将`value`删除，即完成元素的删除，因此时间复杂度为`O(1)`

***

### `Java`中哈希表的常用操作

#### 创建哈希表

```java
// 方式一：通过数组来创建哈希表
String[] hashTable = new String[4];  // 将数组的索引当作添加元素的key，数组的值当作value
// 方式二：通过系统自带的函数来创建哈希表
HashMap<Integer, String> map = new HashMap<>();
```

#### 添加元素

```java
// 创建元素方式一添加元素
hashTable[1] = "aaa";
hashTable[2] = "bbb";
// 创建元素方式二添加元素
map.put(1, "aaa");
map.put(2, "bbb");
```

#### 更新元素

```java
// 创建元素方式一更新元素
hashTable[1] = "ccc";
// 创建元素方式二更新元素
map.put(1, "ccc");
```

#### 删除元素

```java
// 创建元素方式一删除元素
hashTable[1] = "";
// 创建元素方式二删除元素
map.remove(1);
```

#### 获取元素

通过`key`来获取元素

```java
// 创建元素方式一获取元素
String temp = hashTable[1];
// 创建元素方式二删除元素
map.get(1);
```

#### 检查`key`是否存在

```java
// 只有方式二能检查key是否存在
map.containsKey(3);
```

#### 获取长度

```java
map.size();
```

#### 是否还有元素

```java
map.isEmpty();
```

#### 根据索引遍历元素

```java
for key in map.keys() {
    System.out.println(map.get(key));
}
```

***

### 经典力扣题

#### 存在重复元素（217）

给你一个整数数组 `nums` 。如果任一值在数组中出现 至少两次 ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 

示例：

输入：`nums = [1,2,3,1]`

输出：`true`

解释：元素 1 在下标 0 和 3 出现。

示例：

输入：`nums = [1,2,3,4]`

输出：`false`

解释：所有元素都不同。

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        if (nums.length == 0) return false;
        HashMap<Integer, Integer> map = new HashMap<>();

        for (int num : nums) {
            if (!map.containsKey(num)) {
                map.put(num, 1);
            } else {
                return true;
            }
        }
        return false;
    }
}
```

> 哈希表的其中一个常用功能是用来统计某个元素在数据集中出现的次数
>
> 本题中，创建的哈希表，其中`key`存储数组元素，`value`存储元素出现的次数

#### 找不同（389）

给定两个字符串 `s` 和 `t` ，它们只包含小写字母。

字符串 `t` 由字符串 `s` 随机重排，然后在随机位置添加一个字母。

请找出在 `t` 中被添加的字母。

示例 1：

输入：`s = "abcd", t = "abcde"`
输出：`"e"`
解释：`'e' `是那个被添加的字母。

示例 2：

输入：`s = "", t = "y"`
输出：`"y"`

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int[] hashTable = new int[26];   // 整数类型，初始化值都为0
        char[] sCharArray = s.toCharArray();
        char[] tCharArray = t.toCharArray();

        if (s.length() == 0) {
            return t.charAt(0);
        }

        for (char i : sCharArray) {
            int temp = i - 97;
            hashTable[temp] = hashTable[temp] - 1;
        }

        for (char j : tCharArray) {
            int temp = j - 97;
            hashTable[temp] = hashTable[temp] + 1;
        }

        for (int k = 0; k < hashTable.length; k++) {
            if (hashTable[k] == 1) {
                char res = (char) (k + 97);
                return res;
            }
        }
        return '0';
    }
}
```

> 使用了`ASCII`码的方式，作为索引往数组中添加内容；通过原字符串出现则减一，后续字符串出现则加一的方式，那么最后在数组中值为1的索引，就是最后要返回的字符



## 集合（`Set`）

集合数据结构的特点是无序（元素不是按照某个顺序进行排序的，也不是反映元素插入的顺序）、不重复的（集合中所有的元素都是独一无二的，不论插入多个一样的元素，在集合中只会表现出一个）

集合数据结构的作用：

- 检查某一个元素是否存在
- 使用集合检查是否有重复的元素

`HashSet`集合，我们要将一个元素加入到一个`HashSet`集合中去，其过程为：

先获取元素，再使用哈希函数，得到具体的哈希值（哈希集合实质上背后是一张哈希表），我们要将哈希值放到哈希表中对应的位置，如果对应位置上没有元素，我们直接进行存放；如果对应位置上已经存在其他元素了，我们需要进行对比，对比我们的元素和哈希表上的元素是否相等，如果相等，说明这两个元素重复，我们可以不做任何操作；如果不相等，表明产生了哈希冲突，可以通过链表的方法进行解决，将原位置的元素，通过`next`指针指向新要存放的元素

***

### 集合操作的时间复杂度

- 在集合中，访问操作是不存在的

- 搜索操作的时间复杂度为`O(1)`

  对元素进行搜索，通过元素值的哈希函数，定位到具体的哈希表中的位置，最后读取其`value`值，就是我们要访问的值，其时间复杂度为`O(1)`

  但是如果是在哈希碰撞的情况下，其时间复杂度为`O(k)`，其中`k`为碰撞元素的个数

- 插入操作的时间复杂度为`O(1)`

  对于插入操作，直接通过哈希函数计算元素在哈希表中的位置，之后再将`value`存入，即完成元素的插入，因此时间复杂度为`O(1)`

  但是如果是在哈希碰撞的情况下，其时间复杂度为`O(k)`，其中`k`为碰撞元素的个数

- 删除操作的时间复杂度为`O(1)`

  对于删除操作，直接通过哈希函数计算在哈希表中的位置，之后再将`value`删除，即完成元素的删除，因此时间复杂度为`O(1)`

  但是如果是在哈希碰撞的情况下，其时间复杂度为`O(k)`，其中`k`为碰撞元素的个数

***

### `Java`中集合的常用操作

#### 创建集合

```java
HashSet<Integer> set = new HashSet<>();
```

#### 添加元素

```java
set.add(1);
```

#### 搜索元素

```java
set.contains(2);   // 搜索值为2的元素是否在集合中
```

#### 删除元素

```java
set.remove(2);    // 将值为2的元素从集合中删除
```

#### 获取集合长度

```java
set.size();   // 时间复杂度为O(1)
```

***

### 经典力扣题

#### 存在重复元素（217）

给你一个整数数组 `nums` 。如果任一值在数组中出现 至少两次 ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 

示例：

输入：`nums = [1,2,3,1]`

输出：`true`

解释：元素 1 在下标 0 和 3 出现。

示例：

输入：`nums = [1,2,3,4]`

输出：`false`

解释：所有元素都不同。

通过集合的方式进行解决：对于重复的元素，是不能加入到集合中的，我们只需要比较数据前后的长度就可以进行是否有重复元素的判断

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        if (nums.length == 0) return false;
        HashSet<Integer> set = new HashSet<>();

        for (int num : nums) {
            set.add(num);
        }

        if (set.size() == nums.length) return false;
        else return true;
    }
}
```

#### 设计哈希集合（705）

不使用任何内建的哈希表库设计一个哈希集合（`HashSet`）。

实现 `MyHashSet` 类：

- `void add(key)` 向哈希集合中插入值 `key` 。
- `bool contains(key)` 返回哈希集合中是否存在这个值 `key` 。
- `void remove(key)` 将给定值 `key` 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。

示例：

```java
// 输入：
["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
[[], [1], [2], [1], [3], [2], [2], [2], [2]]
// 输出：
[null, null, null, true, false, null, true, null, false]

// 解释：
MyHashSet myHashSet = new MyHashSet();
myHashSet.add(1);      // set = [1]
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(1); // 返回 True
myHashSet.contains(3); // 返回 False ，（未找到）
myHashSet.add(2);      // set = [1, 2]
myHashSet.contains(2); // 返回 True
myHashSet.remove(2);   // set = [1]
myHashSet.contains(2); // 返回 False ，（已移除）
```

提示：

- `0 <= key <= 10^6`
- 最多调用 `10^4` 次 `add`、`remove` 和 `contains`

```java
class MyHashSet {

    private boolean[] hashSet;

    public MyHashSet() {
        hashSet = new boolean[1000001];
    }
    
    public void add(int key) {
        hashSet[key] = true;
    }
    
    public void remove(int key) {
        hashSet[key] = false;
    }
    
    public boolean contains(int key) {
        return hashSet[key];
    }
}
```

> 其添加，删除和查找操作的时间复杂度都是`O(1)`；但是缺点是，数组的大小会很大，同时题目中要给定具体`key`的大小范围



## 树（`Tree`）

树这种数据结构描述的是一种父子关系，对于不能确定父子关系的节点，这整个结构就不是树（节点封闭，有首尾连接的结构，不是树）

树数据结构中重要的概念：

- 节点：表示树中的每一个元素
- 根节点：对于树中，最上面的一个节点就是根节点，根节点只有子，没有父
- 叶子节点：对于没有孩子的节点，就是叶子节点
- 高度（从最底下开始计算，最底下的高度为0，往上依次加1，根节点的高度是最高的）、深度（从顶部往下计算的，最顶部的深度为0，往下依次加1，根节点的深度为0）和层（表示一层一层的，根节点作为第一层）

![image-20250625203346565](../images/image-20250625203346565.png)

二叉树：对于每个节点，最多有两个孩子节点，这样的树被称为二叉树。常见的二叉树有：

- 普通二叉树：每个节点最多有两个孩子节点
- 满二叉树：除了叶子节点，每个节点都有左右两个孩子，同时所有的叶子节点都在同一层上
- 完全二叉树：从树的根节点，从上往下，从左到右依次填满节点形成的二叉树

如果一个二叉树是满二叉树，那么它一定是一个完全二叉树；反之不成立

二叉树的遍历：

- 前序遍历：根节点-->左子树-->右子树
- 中序遍历：左子树-->根节点-->右子树
- 后序遍历：左子树-->右子树-->根节点

前序、中序和后序都是指根节点所在的位置

对于下面的二叉树：

![image-20250625204453054](../images/image-20250625204453054.png)

其前序、中序和后序遍历依次为：

- 前序：`A->B->D->E->C->F->G`   先访问根节点的左子树，再访问根节点的右子树（对于具体的子树也要根据前序遍历的方式）
- 中序：`D->B->E->A->F->C->G`   先访问左子树，再访问根节点，最后访问右子树
- 后续：`D->E->B->F->G->C->A`   先访问左子树，再访问右子树，最后访问根节点



## 堆（`Heep`）

堆数据类型是一种二叉树的结构，









